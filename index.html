<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
  <!-- 引入外部资源 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <!-- 引入摄像机模块 -->
  <script type="module" src="./camera.mjs"></script>
  <!-- 引入角色表情管理器模块 -->
  <script type="module" src="./role-expression-manager.mjs"></script>
  <!-- 注意：utils.mjs会在Vue应用的setup函数中动态导入 -->
   <script type="module" src="./utils.mjs"></script>
   

    <script src="js/module.js"></script>
    <script src="js/frame.js"></script>
    <script src="js/sprite.js"></script>
    <script src="js/project.js"></script>
    <script src="js/image.js"></script>


  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#10B981',
            dark: '#1E293B',
            light: '#F8FAFC',
            accent: '#8B5CF6',
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {          content-visibility: auto;        }        
      .timeline-track {          @apply h-10 border-b border-gray-300 relative;        }        
      .timeline-marker {          @apply absolute w-1 bg-red-500 top-0 bottom-0 z-10;        }        
      .timeline-marker::after {          content: '';          @apply absolute -top-3 -left-2 w-6 h-6 rounded-full bg-red-500 hidden;        }        
      .shot-item {          @apply absolute top-0 h-full border border-blue-400 bg-blue-50 opacity-70 flex flex-col items-center justify-center text-xs cursor-move transition-all;          min-width: 80px; /* 增加最小宽度确保时间信息可读 */        }        
      .shot-item:hover {          @apply opacity-100 shadow-md border-blue-600;        }        
      .expression-item {      @apply absolute h-8 border border-green-400 bg-green-50 opacity-70 flex items-center justify-center text-xs cursor-move transition-all;
          min-width: 3px; /* 减小最小宽度限制，允许更窄的表情项 */
        }        
        .expression-item:hover {          @apply opacity-100;        }        
        .time-tick {          @apply absolute h-4 w-px bg-gray-400 bottom-0;        }        
        .time-tick-major {          @apply h-6 bg-gray-600;        }        
        .time-tick-medium {          @apply h-5 bg-gray-500;        }        
        .time-tick-minor {          @apply h-4 bg-gray-400;        }        
        .time-label {
            @apply absolute -top-2 bg-white/90 px-2 py-1 rounded-md text-xs font-medium text-gray-700 transform -translate-x-1/2 whitespace-nowrap z-10;
          }        
        .time-label-major {          @apply text-sm font-medium text-gray-700;        }        
        .shot-header {          @apply w-full;        }        
        .shot-time-info {          @apply w-full text-center;        }
      .play-icon {
        clip-path: polygon(0 0, 0 100%, 100% 50%);
      }
      .editing-breathing-bg {
        animation: breathing 2s ease-in-out infinite;
      }
      .selected-role-indicator {
        @apply absolute border-2 border-yellow-500 bg-yellow-100/50 z-20 pointer-events-none;
      }
      @keyframes breathing {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
      }
      
      /* 为时间指针指向的分镜添加高亮效果 */
      .time-pointer-active {
        opacity: 1 !important;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
        border-color: #2563eb !important;
        background-color: #eff6ff !important;
        transition: all 0.2s ease !important;
      }
    }
  </style>
</head>
<body class="bg-gray-100 font-sans text-dark">
  <div id="app" class="flex flex-col h-screen overflow-hidden">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-md  flex justify-between items-center">
      <!-- 动画编辑器 -->
      <h3 class="text-2xl font-bold text-primary"></h3>
      <div class="flex space-x-4">
        <div class="flex items-center space-x-1">
          <!-- 角色编辑按钮 -->
          <a href="animEditor.html" class="p-2 hover:bg-gray-100 rounded" title="角色编辑">
            <i class="fa fa-user-plus" title="角色"></i>角色
          </a>
          <!-- 场景角色开关 -->
          <button @click="showRolePreviewClick" class="p-2 hover:bg-gray-100 rounded" title="显示/隐藏场景角色" 
                  :class="{ 'bg-blue-100': showRolePreview }">
            <i class="fa fa-users" title="场景角色"></i>
          </button>
          <!-- 摄像机开关 -->
          <button @click="showCameraPreviewClick" class="p-2 hover:bg-gray-100 rounded" title="显示/隐藏摄像机" 
                  :class="{ 'bg-red-100': showCameraPreview }">
            <i class="fa fa-video-camera" title="摄像机预览"></i>
          </button>

          <label for="canvasSizeSelect" class="text-sm text-gray-600">画布尺寸:</label>
          <select
            id="canvasSizeSelect"
            v-model="selectedCanvasSize"
            class="w-36 px-2 py-1 border border-gray-300 rounded"
          >
            <option v-for="size in canvasSizes" :key="size.name" :value="size">
              {{ size.name }}
            </option>
          </select>
        </div>
        <div class="flex items-center space-x-1">
          <label for="cameraSizeSelect" class="text-sm text-gray-600">导出尺寸:</label>
          <select
            id="cameraSizeSelect"
            v-model="selectedCameraSize"
            class="w-32 px-2 py-1 border border-gray-300 rounded"
          >
            <option v-for="size in cameraSizes" :key="size.name" :value="size">
              {{ size.name }}
            </option>
          </select>
        </div>
        <div class="flex items-center space-x-1">
          <label for="fpsInput" class="text-sm text-gray-600">FPS:</label>
          <input
            id="fpsInput"
            v-model.number="targetFps"
            type="number"
            min="25"
            max="30"
            class="w-16 px-2 py-1 border border-gray-300 rounded text-center"
          >
        </div>
        <div class="flex items-center space-x-1 border border-gray-300 rounded overflow-hidden">
          <button @click="canvasZoomOut" class="flex items-center space-x-1 px-2 py-1 hover:bg-gray-100 transition">
            <i class="fa fa-search-minus"></i>
            <span class="hidden sm:inline"></span>
          </button>
          <span class="border-l border-gray-300 h-4"></span>
          <button @click="canvasResetZoom" class="flex items-center space-x-1 px-2 py-1 hover:bg-gray-100 transition">
            <i class="fa fa-arrows-alt"></i>
            <span class="hidden sm:inline"></span>
          </button>
          <span class="border-l border-gray-300 h-4"></span>
          <button @click="canvasZoomIn" class="flex items-center space-x-1 px-2 py-1 hover:bg-gray-100 transition">
            <i class="fa fa-search-plus"></i>
            <span class="hidden sm:inline"></span>
          </button>
        </div>
        <button @click="saveProject" class="flex items-center space-x-1 bg-primary text-white px-4 py-2 rounded hover:bg-primary/90 transition">
          <i class="fa fa-save"></i>
          <span>保存</span>
        </button>
        <button @click="exportAnimation" class="flex items-center space-x-1 bg-accent text-white px-4 py-2 rounded hover:bg-accent/90 transition">
          <i v-if="!isRecording" class="fa fa-download"></i>
          <i v-else class="fa fa-stop-circle"></i>
          <span v-if="!isRecording">导出</span>
          <span v-else>停止录制</span>
        </button>
      </div>
    </header>
    
    <!-- 主内容区 -->
    <main class="flex-1 flex flex-col overflow-hidden">
      <!-- 画布区域 -->
      <div class="flex-1 relative bg-gray-200 border-b border-gray-300 overflow-hidden flex items-center justify-center">

        <!-- 底层画布div -->
        <!-- <div id="backgroundCanvas" class="absolute"></div> -->
        
        <!-- Canvas容器，作为摄像机视图 -->
        <div id="canvasContainer" class="relative" :style="cameraStyle">
          <canvas id="animationCanvas" @click="handleCanvasClick" style="border: 2px dashed #e0e0e0; border-radius: 4px;"></canvas>
          <!-- 摄像机边框，仅在显示摄像机时显示 -->
          <!-- <div v-if="showCamera" class="absolute inset-0 border-2 border-red-500 pointer-events-none"></div> -->
        </div>
        
        <!-- 场景角色管理面板 - 作为canvasContainer的同级元素 -->
        <div v-if="showRolePreview" id="rolePreview" class="absolute left-0 top-0 h-full bg-white border border-gray-300 shadow-xl z-50 w-72">
          <div class="bg-gray-800 text-white p-2 rounded-t-lg flex justify-between items-center">
            <span>场景角色管理</span>
            <!-- 关闭按钮 -->
            <button @click="showRolePreview = false" class="text-white hover:text-gray-300">
              <i class="fa fa-times"></i>
            </button>
          </div>
          
          <!-- 分页tab标签 -->
          <div class="flex border-b border-gray-200">
            <button 
              @click="activeTab = 'scenes'" 
              class="flex-1 py-2 px-4 text-sm font-medium transition-colors duration-200" 
              :class="activeTab === 'scenes' ? 'bg-blue-50 text-blue-700 border-b-2 border-blue-500' : 'text-gray-700 hover:bg-gray-50'"
            >
              场景
            </button>
            <button 
              @click="activeTab = 'shots'" 
              class="flex-1 py-2 px-4 text-sm font-medium transition-colors duration-200" 
              :class="activeTab === 'shots' ? 'bg-blue-50 text-blue-700 border-b-2 border-blue-500' : 'text-gray-700 hover:bg-gray-50'"
            >
              分镜
            </button>
          </div>
          
          <!-- 内容区域 -->
          <div class="p-3 h-[calc(100%-85px)] overflow-y-auto">
            <!-- 场景tab -->
            <div v-if="activeTab === 'scenes'">
              <!-- 场景列表 -->
              <div class="mb-4">
                <h4 class="text-sm font-medium text-gray-700 mb-2">场景列表</h4>
                <div class="space-y-2">
                  <div 
                    v-for="scene in timeline.scenes" 
                    :key="scene.id" 
                    @click="selectScene(scene)"
                    class="p-2 rounded bg-white border cursor-pointer transition-all hover:bg-blue-50 hover:border-blue-300"
                    :class="selectedScene && selectedScene.id === scene.id ? 'border-blue-500 bg-blue-50' : ''"
                  >
                    <div class="flex justify-between items-center">
                      <span class="text-sm">{{ scene.id }}</span>
                      <span class="text-xs text-gray-500">{{ scene.shots.length }}个分镜</span>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- 角色列表 -->
              <div class="mt-4">
                <h4 class="text-sm font-medium text-gray-700 mb-2">角色列表</h4>
                <div v-if="selectedScene">
                  <div v-for="role in selectedScene.roles" :key="role.roleId" class="flex items-center justify-between mb-3 pb-3 border-b border-gray-100">
                    <div class="flex items-center space-x-3">
                      <!-- 角色缩略图 -->
                      <div class="w-12 h-12 bg-gray-100 rounded flex items-center justify-center overflow-hidden">
                        <canvas :ref="el => setRoleThumbnailRef(role.roleId, el)" width="48" height="48" class="w-full h-full"></canvas>
                      </div>
                      <!-- 角色名称 -->
                      <div class="text-sm font-medium">
                        {{ getRoleNameById(role.roleId) }}
                      </div>
                    </div>
                    <!-- 显示/隐藏开关 -->
                    <label class="relative inline-flex items-center cursor-pointer">
                      <input type="checkbox" v-model="role.visible" @change="toggleRoleVisibility(role.roleId)" class="sr-only peer">
                      <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                  </div>
                  <!-- 设置初始位置和添加角色按钮 -->
                  <div class="mt-4 pt-3 border-t border-gray-200">
                    <button @click="addSceneProp" class="w-full py-2 bg-primary text-white rounded hover:bg-primary/90 transition text-sm">
                      增加道具
                    </button>
                    <!-- <button @click="setSceneInitialPosition" class="w-full py-2 bg-primary text-white rounded hover:bg-primary/90 transition text-sm">
                      设置初始位置
                    </button> -->
                    
                    <!-- 添加角色按钮和下拉菜单 -->
                    <div class="relative mt-2">
                      <button @click="toggleRoleDropdown" class="w-full py-2 bg-primary text-white rounded hover:bg-primary/90 transition text-sm flex items-center justify-between">
                        添加角色
                        <i class="fa fa-chevron-right" :class="{ 'rotate-90': showRoleDropdown }"></i>
                      </button>
                    </div>
                  </div>
                </div>
                <div v-else class="text-sm text-gray-500 p-2 italic">请选择一个场景</div>
              </div>
            </div>
            
            <!-- 分镜tab -->
            <div v-if="activeTab === 'shots'">
              <h4 class="text-sm font-medium text-gray-700 mb-2">分镜列表</h4>
              <div class="space-y-2">
                <div 
                  v-for="shot in timeline.shots" 
                  :key="shot.id" 
                  @click="selectShot(shot)"
                  class="p-2 rounded bg-white border cursor-pointer transition-all hover:bg-blue-50 hover:border-blue-300"
                  :class="selectedShot && selectedShot.id === shot.id ? 'border-blue-500 bg-blue-50' : ''"
                >
                  <div class="flex justify-between items-center">
                    <span class="text-sm">{{ shot.id }}</span>
                    <span class="text-xs text-gray-500">{{ formatTime(shot.duration) }}</span>
                  </div>
                </div>
              </div>
              
              <!-- 分镜内角色列表 -->
              <div class="mt-4">
                <h4 class="text-sm font-medium text-gray-700 mb-2">角色列表</h4>
                <div v-if="selectedShot && selectedScene">
                  <div v-for="role in selectedScene.roles" :key="role.roleId" class="flex items-center justify-between mb-3 pb-3 border-b border-gray-100">
                    <div class="flex items-center space-x-3">
                      <!-- 角色缩略图 -->
                      <div class="w-12 h-12 bg-gray-100 rounded flex items-center justify-center overflow-hidden">
                        <canvas :ref="el => setRoleThumbnailRef(role.roleId, el)" width="48" height="48" class="w-full h-full"></canvas>
                      </div>
                      <!-- 角色名称 -->
                      <div class="text-sm font-medium">
                        {{ getRoleNameById(role.roleId) }}
                      </div>
                    </div>
                    <!-- 显示/隐藏开关 -->
                    <label class="relative inline-flex items-center cursor-pointer">
                      <input type="checkbox" v-model="role.visible" @change="toggleRoleVisibility(role.roleId)" class="sr-only peer">
                      <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                  </div>
                </div>
                <div v-else class="text-sm text-gray-500 p-2 italic">请选择一个分镜</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- 左侧控制选项 去掉！！！！！！！！！-->
        <!-- <div class="absolute top-4 left-4 bg-white/80 backdrop-blur-sm p-2 rounded-lg shadow-lg flex flex-col space-y-2">
          <label class="flex items-center space-x-2">
            <input type="checkbox" v-model="showCamera" class="form-checkbox rounded">
            <span>显示摄像机</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" v-model="showCameraPreview" class="form-checkbox rounded">
            <span>显示相机预览</span>
          </label>
        </div> -->

        
        <!-- 表情选择面板 -->
        <div 
          v-if="showExpressionPanel && selectedRoleId"
          class="absolute top-0 right-0 h-full w-64 bg-white shadow-lg transform transition-transform duration-300 z-50"
          :style="{ transform: showExpressionPanel ? 'translateX(0)' : 'translateX(100%)' }"
        >
          <div class="p-4">
            <h3 class="text-lg font-bold mb-4">表情选择</h3>
            <div class="space-y-2 max-h-[calc(100%-150px)] overflow-y-auto">
              <!-- 简化的表情列表渲染，使用更严格的安全检查 -->
              <div v-if="selectedRoleId && timeline.roles">
                <!-- 先找到当前选中的角色 -->
                <template v-for="role in timeline.roles">
                  <div v-if="role && role.id === selectedRoleId && role.expressions && role.expressions.length > 0">
                    <!-- 再渲染该角色的表情列表 -->
                    <template v-for="expr in role.expressions">
                      <div 
                        v-if="expr && expr.id && expr.name"
                        :key="expr.id"
                        @click="handleExpressionClick(expr)"
                        class="p-2 border rounded cursor-pointer hover:bg-gray-100 transition flex items-center justify-between"
                        :class="selectedExpressionId === expr.id ? 'bg-green-100 border-green-500' : ''"
                      >
                        <span>{{ expr.name }}</span>
                        <i v-if="selectedExpressionId === expr.id" class="fa fa-check text-green-500"></i>
                      </div>
                    </template>
                    <!-- 当没有表情时显示提示 -->
                    <div v-else class="p-2 text-gray-500 italic">暂无可用表情</div>
                  </div>
                </template>
                <!-- 当未找到角色时显示提示 -->
                <div v-else class="p-2 text-gray-500 italic">未找到选中的角色</div>
              </div>
              <!-- 当未选择角色时显示提示 -->
              <div v-else class="p-2 text-gray-500 italic">请先选择一个角色</div>
            </div>
            <div class="absolute bottom-0 left-0 right-0 p-4 border-t flex space-x-2">
              <button @click="addExpression" class="flex-1 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
                添加
              </button>
              <button @click="replaceExpression" class="flex-1 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
                替换
              </button>
              <button @click="deleteExpression" class="flex-1 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">
                删除
              </button>
            </div>
          </div>
          

        </div>
        
        <!-- 画布控制按钮 -->
        <div class="absolute top-4 right-4 bg-white/80 backdrop-blur-sm p-2 rounded-lg shadow-lg flex space-x-2">

          <!-- <button @click="showCameraPreviewClick" class="p-2 hover:bg-gray-100 rounded" title="显示/隐藏摄像机"
                  :class="{ 'bg-red-100': showCameraPreview }">
            <i class="fa fa-eye " title="摄像机预览"></i>
          </button> -->
          <button @click="resetCamera" class="p-2 hover:bg-gray-100 rounded" title="重置相机位置">
            <i class="fa fa-refresh" ></i>
          </button>
          <button @click="testDrawAudio" class="p-2 bg-purple-500 text-white rounded" title="测试音频显示">
            <i class="fa fa-volume-up"></i>
          </button>

          <button @click="toggleAspectRatio" class="p-2 hover:bg-gray-100 rounded" :class="{ 'bg-blue-100': isMaintainingAspectRatio }" title="切换宽高比锁定">
            <i class="fa fa-arrows-alt"></i>
          </button>
          <button @click="toggleCameraRotation" class="p-2 hover:bg-gray-100 rounded" :class="{ 'bg-blue-100': enableCameraRotation }" title="切换旋转功能">
            <i class="fa fa-refresh fa-rotate-45"></i>
          </button>
          <!-- <button @click="toggleCameraInfo" class="p-2 hover:bg-gray-100 rounded" :class="{ 'bg-blue-100': showCameraInfo }" title="显示相机信息">
            <i class="fa fa-info"></i>
          </button> -->
          <button @click="useSmoothTransition = !useSmoothTransition" class="p-2 hover:bg-gray-100 rounded" :class="{ 'bg-blue-100': useSmoothTransition }" title="平滑过渡">
            <i class="fa fa-film"></i>
          </button>
        </div>
        
        <!-- 虚拟镜头预设控制 - 只有启用镜头编辑时才显示 -->
        <div v-if="enableCameraEdit" class="absolute bottom-4 right-4 bg-white/80 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <div class="text-sm font-medium mb-2">虚拟镜头预设</div>
          <div class="flex space-x-2 items-center mb-2">
            <!-- <select @change="applyCameraPreset($event.target.value)" class="text-sm border border-gray-300 rounded px-2 py-1"> -->
            <select v-model="selectedCameraPreset" @change="applyCameraPreset($event.target.value)" class="text-sm border border-gray-300 rounded px-2 py-1">
              <option value="">选择预设</option>
              <option v-for="preset in cameraPresets" :key="preset.name" :value="preset.name">
                {{ preset.name }} ({{ preset.width }}x{{ preset.height }})
              </option>
            </select>
            <button hidden @click="deleteCameraPreset($event.target.previousElementSibling.value)" class="text-sm px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition"
            :disabled="cameraPresets.length === 0">
              删除预设
            </button>
          </div>
          <!-- 保存景别按钮组 -->
          <div class="flex flex-col space-y-1 mb-2">
            <button @click="saveCameraScenery(null)" class="text-sm px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 transition w-full">
              保存景别
            </button>
            <button @click="saveCameraSceneryToShotStart" class="text-sm px-2 py-1 bg-green-500 text-white rounded hover:bg-green-600 transition w-full">
              保存至当前分镜开始
            </button>
            <button @click="saveCameraSceneryToDialogStart" class="text-sm px-2 py-1 bg-purple-500 text-white rounded hover:bg-purple-600 transition w-full">
              保存至当前对话开始
            </button>
          </div>
          <div class="flex space-x-2 items-center">
            <input hidden type="text" v-model="presetName" placeholder="预设名称" class="text-sm border border-gray-300 rounded px-2 py-1 flex-1" />
            <button hidden @click="saveCameraPreset(presetName); presetName = ''" class="text-sm px-2 py-1 bg-green-500 text-white rounded hover:bg-green-600 transition"
                    :disabled="!presetName">
              保存
            </button>
          </div>
          
          <!-- 默认镜别设置 - 终极解决方案 -->
          <div class="mt-3">
            <div class="text-sm font-medium mb-1">默认镜头</div>
            <!-- 带有默认值的select元素 -->
            <select id="defaultCameraScenerySelect" v-model="defaultCameraScenery" class="text-sm border border-gray-300 rounded px-2 py-1 w-full">
              <!-- 静态添加所有选项，确保页面加载时就有完整选项 -->
              <option value="特写">特写 (854x480)</option>
              <option value="近景">近景 (1080x635)</option>
              <option value="中景">中景 (1280x720)</option>
              <option value="全景">全景 (1920x1080)</option>
            </select>
            
            <!-- 默认对话镜头设置 -->
            <div class="mt-3">
              <div class="text-sm font-medium mb-1">默认对话镜头</div>
              <!-- 带有默认值的select元素 -->
              <select id="defaultDialogCameraScenerySelect" v-model="defaultDialogCameraScenery" class="text-sm border border-gray-300 rounded px-2 py-1 w-full">
                <!-- 静态添加所有选项，确保页面加载时就有完整选项 -->
                <option value="特写">特写 (854x480)</option>
                <option value="近景" selected>近景 (1080x635)</option>
                <option value="中景">中景 (1280x720)</option>
                <option value="全景">全景 (1920x1080)</option>
              </select>
            </div>
          </div>
        </div>
        
        <!-- 相机状态显示 -->
        <div class="absolute top-20 right-4 bg-black/60 text-white p-2 rounded-lg text-sm backdrop-blur-sm">
          <div>缩放: {{ cameraZoom.toFixed(2) }}x</div>
          <div v-if="enableCameraRotation">旋转: {{ cameraRotation.toFixed(1) }}°</div>
        </div>
      </div>
      
      <!-- 相机预览小页面 -->
      <div v-if="showCameraPreview" id="cameraPreview" class="absolute top-0 right-0 bg-white border border-gray-300 rounded-lg shadow-xl z-50">
        <div class="bg-gray-800 text-white p-2 rounded-t-lg flex justify-between items-center cursor-move">
          <span>相机预览</span>
          <!-- 关闭按钮 -->
          <button @click="showCameraPreview = false" class="text-white hover:text-gray-300">
            <i class="fa fa-times"></i>
          </button>
        </div>
        <div class="p-2 preview-canvas-container" style="min-width: 283px; min-height: 166px;">
          <canvas id="previewCanvas" style="width: 267px; height: 150px;"></canvas>
        </div>
      </div>
      
      <!-- 相机预览的专用样式 -->
      <style>
        #cameraPreview {
          max-width: 400px;
          max-height: 300px;
        }
        
        #previewCanvas {
          display: block;
          margin: 0 auto;
          border: 1px solid #ccc;
        }
        
        .preview-canvas-container {
          display: flex;
          align-items: center;
          justify-content: center;
          min-width: 283px; 
          min-height: 166px;
        }
      </style>
      
      <!-- 时间轴控制区 -->
      <div class="timeline-container flex flex-col">
        <!-- 可拖拽分隔条 -->
        <div id="timelineResizer" class="h-1 bg-gray-300 cursor-ns-resize flex items-center justify-center hover:bg-gray-400 transition-colors">
          <div class="w-10 h-1 bg-gray-500 rounded"></div>
        </div>
        <div id="timelineContent" class="h-64 bg-white border-t border-gray-300 flex flex-col">
        <!-- 播放控制 -->
        <div class="h-12 border-b border-gray-300 flex items-center px-4">
          <div class="flex items-center space-x-2">
            <input 
              type="checkbox" 
              id="showAllExpressions" 
              v-model="showAllRoleExpressions" 
              @change="updateTimelineDisplay"
              class="mr-1" 
              checked />
            <label for="showAllExpressions" class="text-sm text-gray-700">角色表情</label>
            <input 
              type="checkbox" 
              id="showCameraTrack" 
              v-model="showCameraTrack" 
              @change="updateTimelineDisplay"
              class="ml-4 mr-1" 
              checked />
            <label for="showCameraTrack" class="text-sm text-gray-700">镜头轨道</label>
            <!-- 时间轴缩放控制按钮 -->
            <div class="flex items-center ml-1 space-x-1 border border-gray-200 rounded overflow-hidden">
              <button @click="timelineZoomIn" class="p-1 hover:bg-gray-100 rounded" title="放大时间轴">
                <i class="fa fa-search-plus"></i>
              </button>
              <span class="border-l border-gray-200 h-5"></span>
              <button @click="timelineResetZoom" class="p-1 hover:bg-gray-100 rounded" title="重置时间轴缩放">
                <i class="fa fa-home"></i>
              </button>
              <span class="border-l border-gray-200 h-5"></span>
              <button @click="timelineZoomOut" class="p-1 hover:bg-gray-100 rounded" title="缩小时间轴">
                <i class="fa fa-search-minus"></i>
              </button>
            </div>
            <!-- 固定在div后面的按钮 -->
            <button @click="goToStart" class="p-2 hover:text-primary transition">
              <i class="fa fa-step-backward"></i>
            </button>
            <button @click="playPause" class="p-3 bg-primary text-white rounded-full hover:bg-primary/90 transition relative w-10 h-10 flex items-center justify-center">
              <div v-if="!isPlaying" class="play-icon bg-white w-4 h-6 ml-0.5"></div>
              <div v-else class="flex space-x-1">
                <div class="bg-white w-2 h-6"></div>
                <div class="bg-white w-2 h-6 ml-1"></div>
              </div>
            </button>
            <button @click="goToEnd" class="p-2 hover:text-primary transition">
              <i class="fa fa-step-forward"></i>
            </button>
            <div class="text-sm text-gray-600 w-12 min-w-12 text-center">
              {{ formatTimess(currentTime) }}
            </div>
            <div class="text-sm text-gray-600 w-16 min-w-16 text-center">
              / {{ formatTime(totalDuration) }}
            </div>
            <button @click="toggleLoop" class="p-2 hover:text-primary transition" :class="loop ? 'text-primary' : ''">
              <i class="fa fa-repeat"></i>
            </button>
          </div>

          
          
          <!-- 角色功能按钮区域 -->
          <div v-if="!isPlaying && selectedRoleId" class="ml-auto flex justify-end space-x-2">
            <button @click="toggleExpressionPanel" class="p-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
              <i class="fa fa-smile-o"></i> 表情
            </button>
            <button class="p-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
              <i class="fa fa-sign-in"></i> 出入场
            </button>
            <button class="p-2 bg-purple-500 text-white rounded hover:bg-purple-600 transition">
              <i class="fa fa-arrows"></i> 朝向
            </button>
            <button class="p-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition">
              <i class="fa fa-child"></i> 姿势
            </button>
            <button class="p-2 bg-red-500 text-white rounded hover:bg-red-600 transition">
              <i class="fa fa-volume-up"></i> 音色
            </button>
            <button class="p-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition">
              <i class="fa fa-layers"></i> 图层
            </button>
            <button class="p-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition">
              <i class="fa fa-user-plus"></i> 角色
            </button>
          </div>
        </div>
        
        <!-- 时间轴区域 - 添加滚动功能 -->
        <div id="timelineContainer" class="flex-1 relative overflow-x-auto ">
          <div class="absolute top-0 left-0 right-0 bottom-0" :style="{ width: '100%'}">
            <!-- 时间刻度 -->
            <!-- 使用sticky定位使时间刻度固定在顶部 -->
              <div class="sticky top-0 z-10 h-8 border-b border-gray-300 relative" ref="timeScale">
                <div id = "timeMarkers" class="timeMarkers absolute top-0 bottom-0 left-0 right-0" ref="timeMarkers"></div>
              </div>
            
            <!-- 分镜轨道 -->
            <div class="timeline-track" ref="shotTrack">
              <div class="absolute top-0 left-0 h-full" ref="shotContainer" style="width: 100%;"></div>
              
              <!-- 场景轨道 - 移到分镜轨道内的最下面 -->
              <div class="absolute bottom-0 left-0 right-0 h-5" ref="sceneTrack">
                <div class="absolute top-0 left-0 h-full w-full" ref="sceneContainer"></div>
              </div>
            </div>
            
            <!-- 镜头轨道 -->
            <template v-if="showCameraTrack">
              <div class="timeline-track" style="height: 30px;">
                <!-- 音频显示区域 -->
                <div class="absolute top-0 left-0 h-1/2" ref="audioContainer" style="width: 100%;"></div>
                <!-- 镜头显示区域 -->
                <div class="absolute top-1/2 left-0 h-1/2" ref="cameraContainer" style="width: 100%;"></div>
                <div class="absolute top-0 left-0 h-full w-20 bg-gray-100 flex items-center justify-center text-xs">
                  <span>镜头/对白</span>
                  <button @click="showCameraClick" class="ml-1 p-1 hover:bg-gray-200 rounded-full" title="显示/隐藏摄像机预览">
                    <i :class="showCamera ? 'fa fa-eye' : 'fa fa-eye-slash '"></i>
                  </button>
                  <button @click="enableCameraEdit = !enableCameraEdit" class="ml-1 p-1 hover:bg-gray-200 rounded-full" title="启用/禁用镜头编辑" :class="{ 'bg-yellow-100': enableCameraEdit, 'bg-gray-300': !enableCameraEdit, 'opacity-50': !enableCameraEdit }">
                    <i class="fa fa-pencil"></i>
                  </button> 
                </div>
              </div>
            </template>
            
            <!-- 角色表情轨道 -->
            <template v-if="showAllRoleExpressions || (selectedRoleId && !showAllRoleExpressions)">
              <!-- 展示所有角色表情 -->
              <template v-if="showAllRoleExpressions">
                <div v-for="(role, index) in timeline.roles" :key="role.id" class="timeline-track" :ref="setExpressionTrackRef(role.id)">
                  <div class="absolute top-1 left-0 h-10"  style="width: 100%;" :ref="setExpressionContainerRef(role.id)"></div>
                  <div class="absolute top-0 left-0 h-full w-20 bg-gray-100 flex items-center justify-center text-xs">
                    <span @click="selectRole(role.id)">{{ role.name }}</span>
                  </div>
                </div>
              </template>
              <!-- 只展示选中角色表情 -->
              <template v-else-if="selectedRoleId">
                <div v-for="(role, index) in timeline.roles.filter(r => r.id === selectedRoleId)" :key="role.id" class="timeline-track" :ref="setExpressionTrackRef(role.id)">
                  <div class="absolute top-1 left-0 h-10"  style="width: 100%;" :ref="setExpressionContainerRef(role.id)"></div>
                  <div class="absolute top-0 left-0 h-full w-20 bg-gray-100 flex items-center justify-center text-xs">
                    <span @click="selectRole(role.id)">{{ role.name }}</span>
                  </div>
                </div>
              </template>
            </template>
            
            <!-- 时间轴指针 -->
            <div class="timeline-marker" :style="{ left: '50%' }"></div>
          </div>
        </div>
      </div>
      
      <!-- 调试信息显示区域 -->
      <div class="p-4 bg-gray-50 border-t border-gray-200 text-sm text-gray-600 hidden">
        <div class="mb-1"><strong>当前指针位置:</strong> {{ markerPosition }}px | <strong>当前时间:</strong> {{ formatTime(currentTime.value) }}</div>
        <div><strong>调试信息:</strong> {{ debugInfo }}</div>
      </div>
    </main>
  </div>

  <script>

     const mockExpressions = [
        {
            id: 'exp1-1',
            name: "普通1",
            type: 0,//0是通用表情、1是男专用，2是女专用
            imageUrls: ["https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/n1.png", "https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/n2.png"]
        },
        {
            id: 'exp1-2',
            name: "普通2",
            type: 0,//0是通用表情、1是男专用，2是女专用
            imageUrls: ["https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal1.png", "https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal2.png"]
        },
        {
            id: 'exp1-3',
            name: "开心",
            type: 0,//0是通用表情、1是男专用，2是女专用
            imageUrls: ["https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal1.png", "https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal2.png"]
        },
        {
            id: 'exp2-1',
            name: "开心",
            type: 0,//0是通用表情、1是男专用，2是女专用
            imageUrls: ["https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal1.png", "https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal2.png"]
        },
        {
            id: 'exp2-2',
            name: "开心2",
            type: 0,//0是通用表情、1是男专用，2是女专用
            imageUrls: ["https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal1.png", "https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/express/normal2.png"]
        },
    ];

    const allExpressions = {

    }
    

    const mockAvatars = {

    }

    // 模拟数据 - 角色 (使用新的角色表情图)
    const mockRoles = [
      {
        id: 'role1',
        name: '陈知行',
        defaultAnimId:0,
        defaultExpressionId: 'exp1-1',
        avatarId: '2',
        voice: 'voice1',
      },
      {
        id: 'role2',
        name: '混江龙',
        defaultAnimId:0,
        defaultExpressionId: 'exp2-1',
        avatarId: '1',
        voice: 'voice2',
      },
      {
        id: 'role3',
        name: '璎珞',
        defaultAnimId:0,
        defaultExpressionId: 'exp3-1',
        avatarId: '2',
        voice: 'voice3',
      }
    ];

    // 模拟数据 - 场景
    const mockScenes = [
      {
        id: 'scene1',
        shots: ['shot1'],
        roles: [
          {
            roleId: 'role1',
            animId: 0,
            expressionId: 'exp1-1',
            x: 150,
            y: 200,
            angle: 0,
            scale: 1,
            visible: true
          },
          {
            roleId: 'role2',
            animId: 0,
            expressionId: 'exp2-1',
            x: 1750,
            y: 200,
            angle: 0,
            scale: 1,
            visible: true
          },
        ]
      },
      {
        id: 'scene2',
        shots: ['shot2'],
        roles: [
          {
            roleId: 'role1',
            animId: 0,
            expressionId: 'exp1-2',
            x: 150,
            y: 200,
            angle: 0,
            scale: 1,
            visible: true
          },
          {
            roleId: 'role2',
            animId: 0,
            expressionId: 'exp2-1',
            x: 350,
            y: 320,
            angle: 0,
            scale: 1,
            visible: true
          }
        ]
      },
      {
        id: 'scene3',
        shots: ['shot3', 'shot4'],
        roles: [
          {
            roleId: 'role1',
            animId: 0,
            expressionId: 'exp1-2',
            x: 150,
            y: 200,
            angle: 0,
            scale: 1,
            visible: true
          },
          {
            roleId: 'role2',
            animId: 0,
            expressionId: 'exp2-1',
            x: 350,
            y: 320,
            angle: 0,
            scale: 1,
            visible: true
          },
          {
            roleId: 'role3',
            animId: 0,
            expressionId: 'exp3-1',
            x: 1000,
            y: 580,
            angle: 0,
            scale: 1,
            visible: true
          }
        ]
      }
    ]

    // 模拟数据 - 分镜
    const mockShots = [
      {
        id: 'shot1',
        background: 'https://mints-medias.oss-cn-beijing.aliyuncs.com/bg1.jpeg', 
        //'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg1.webp',
        
        duration: 9500, // 5秒
        audioDuration: 9500,
        startTime: 0,
        audios: [
          {
            id: 'audio1',
            roleId: 'role1',
            text: '混江龙魏爷，你刚才不是很威风吗？',
            audio: 'https://rh-images.xiaoyaoyou.com/babfec956cbdabe7f1fb93e2a1d971dc/output/audio/ComfyUI_00002_vieis_1758605920.flac',
            audioDuration: 3224,
            startTime: 0,
          },
          {
            id: 'audio2',
            roleId: 'role2',
            text: '在您面前，哪有什么魏爷，您要是不嫌弃，叫我一声小龙就行',
            audio: 'https://rh-images.xiaoyaoyou.com/babfec956cbdabe7f1fb93e2a1d971dc/output/audio/ComfyUI_00001_domho_1758606891.flac',
            audioDuration: 6000,
            startTime: 3300,
          }
        ],
        cameraTracks: [
          // {
          //   id: 'cameraTrack1-1',
          //   cameraType:'全',
          //   cameraMoveType: '1', //1硬切，2软切
          //   targetRoleId:'role1',
          //   targetX:0,
          //   targetY:0,
          //   startTime: 0,
          //   duration: 500,
          // }
        ]
      },
      {
        id: 'shot2',
        background: 'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg2.webp',
        duration: 4000, // 4秒
        audioDuration: 4000,
        startTime: 9500,
        audios: [
          {
            id: 'audio3',
            roleId: 'role1',
            text: '我路过这，请问这是哪？',
            audio: 'audio1.mp3',
            audioDuration: 2000,
            startTime: 0,
          },
          {
            id: 'audio4',
            roleId: 'role2',
            text: '这是xxx楼，是集团总部，你有什么事',
            audio: 'audio1.mp3',
            audioDuration: 2000,
            startTime: 2000,
          }
        ],
        cameraTracks: [
          // {
          //   id: 'cameraTrack2-1',
          //   cameraType:'全',
          //   cameraMoveType: '1', //1硬切，2软切
          //   x:0,
          //   y:0,
          //   width:0,
          //   height:0,
          //   startTime: 0,
          //   duration: 1000,
          // },
          // {
          //   id: 'cameraTrack2-2',
          //   cameraType:'中',
          //   cameraMoveType: '1', //1硬切，2软切
          //   x:0,
          //   y:0,
          //   x1:0,
          //   y1:0,
          //   startTime: 2000,
          //   duration: 1000,
          // }
        ]
      },
      {
        id: 'shot3',
        background: 'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg4.webp',
        duration: 6000, // 6秒
        audioDuration: 6000,
        startTime: 13500,
        audios: [],
        cameraTracks: [{
          id: 'cameraTrack3-1',
          cameraType:'全',
          cameraMoveType: '1', //1硬切，2软切
          x:0,
          y:0,
          x1:0,
          y1:0,
          startTime: 0,
          duration: 5000,
        }]
      },
      {
        id: 'shot4',
        background: 'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg4.webp',
        duration: 5000, // 6秒
        audioDuration: 5000,
        startTime: 19500,
        audios: [],
        cameraTracks: [
          {
            id: 'cameraTrack4-1',
            cameraType:'近',
            cameraMoveType: '2', //1硬切，2软切
            x:0,
            y:0,
            x1:0,
            y1:0,
            startTime: 0,
            duration: 1000,
          }
        ]
      }
    ];

    // 模拟数据 - 角色表情轨道 (添加了角色3的轨道)
    const mockExpressionTracks = [
      {
        id: 'expTrack1-1',
        roleId: 'role1',
        animId: 2,//动作索引
        startTime: 0,
        endTime: 5000,
        expressionId: 'exp1-1',//表情id
        x: 310,
        y: 0,
        x1: 914,
        y1: 0,
        flipX: 0,
        angle: 0,
        scale: 1
      },
      {
        id: 'expTrack1-2',
        roleId: 'role1',
        animId: 2,//动作索引
        startTime: 7000,
        endTime: 9000,
        expressionId: 'exp1-2',
        x: 300,
        y: 250,
        x1: 450,
        y1: 350,
        flipX: 0,
        angle: 0,
        scale: 1
      },
      {
        id: 'expTrack1-3',
        roleId: 'role1',
        animId: 2,//动作索引
        startTime: 12000,
        endTime: 20000,
        expressionId: 'exp1-4',
        x: 250,
        y: 300,
        flipX: 0,
        angle: 0,
        scale: 1
      },
      {
        id: 'expTrack2-1',
        roleId: 'role2',
        animId: 2,//动作索引
        startTime: 5000,
        endTime: 9000,
        expressionId: 'exp2-1',
        x: 1350,
        y: 320,
        flipX: 0,
        angle: 0,
        scale: 1
      },
      {
        id: 'expTrack2-2',
        roleId: 'role2',
        animId: 1,//动作索引
        startTime: 15250,
        endTime: 20000,
        expressionId: 'exp2-2',
        x: 40,
        y: 320,
        flipX: 0,
        angle: 0,
        scale: 1,
      },
      {
        id: 'expTrack3-1',
        roleId: 'role3',
        animId: 1,//动作索引
        startTime: 11000,
        endTime: 19050,
        expressionId: 'exp3-1',
        x: 1000,
        y: 580,
        flipX: 0,
        angle: 0,
        scale: 1,
      }
    ];

    // 创建Vue应用
    const { createApp, ref, onMounted, computed, watch, nextTick } = Vue;

    function initMockData(name,avatarId) {
      const savedData = localStorage.getItem(name);
        if (!savedData) {
            console.log('没有找到保存的avatar数据');
            return false;
        }

      // 重建项目、角色、动作、帧等数据
        const avatar = new Avatar();
        avatar.id = avatarId;
        const imageManager = avatar.imageManager;
        const avatarData = JSON.parse(savedData);
        
        avatarData.images.forEach(savedImage => {
            const imageItem = new ImageItem(savedImage.id, savedImage.src, savedImage.name);
            imageItem.modulesList = savedImage.modulesList || [];
            imageManager.addImage(imageItem);
        });
        

        avatarData.project.m_spriteList.forEach(savedSprite => {
            const sprite = new Sprite(savedSprite.name);
            avatar.addSprite(sprite);
            
            // 为角色添加图片引用
            avatarData.images.forEach(savedImage => {
                const imageItem = imageManager.getImage(savedImage.id);
                if (imageItem) {
                    sprite.addImage(imageItem);
                }
            });
            
            // 重建动作
            savedSprite.mAnimList.forEach(savedAnim => {
                const anim = new Anim(savedAnim.name);
                sprite.mAnimList.push(anim);
                
                // 重建动画帧
                savedAnim.aframeList.forEach(savedAFrame => {
                    const frame = new Frame();
                    frame.fmList = savedAFrame.frame.fmList.map(savedFm => {
                        const fm = new FrameModule(savedFm.module, savedFm.x, savedFm.y, savedFm.flag);
                        return fm;
                    });
                    const aframe = new AnimFrame(frame, savedAFrame.KeyFrameState);
                    
                    // 恢复表情区域数据
                    if (savedAFrame.expressionRect) {
                        aframe.expressionRect = savedAFrame.expressionRect;
                    }
                    
                    anim.aframeList.push(aframe);
                });
            });
        });
        
        // 选择默认的角色和动作
        if (avatar.m_spriteList.length > 0) {
            currentSprite = avatar.m_spriteList[0];
            if (currentSprite.mAnimList.length > 0) {
                currentAnim = currentSprite.mAnimList[0];
                if (currentAnim.aframeList.length > 0) {
                    currentFrame = currentAnim.aframeList[0].frame;
                }
            }
        }

        
        console.log('avatar加载成功！');
        mockAvatars[avatar.id] = avatar;
    }

    createApp({
      
      setup() {

        // 创建Expression对象
        mockExpressions.forEach(exprData => {
          const expression = new Expression(exprData.id,exprData.name,exprData.type, exprData.imageUrls);
          allExpressions[exprData.id] = expression;
        });

        initMockData('animationEditorProject',0);
        initMockData('spriteName',1);
        initMockData('sprite1',2);//男主
        console.log('mockAvatar:',mockAvatars);


        
        // 动态导入工具类 - 优化版本
        let utilsModuleLoaded = false;
        let loadImageWithCORS = null;
        let getCacheImage = null;
        let CUSTOM_CAMERA_TYPE = null;
        let round = null;
        
        // 角色管理面板相关状态
        const activeTab = ref('scenes'); // 'scenes' 或 'shots'
        const selectedScene = ref(null);
        const selectedShot = ref(null);


        // 添加重试机制
        const importUtilsModule = () => {
          import('./utils.mjs').then(utilsModule => {
            console.log('✅ import utils module success');
            loadImageWithCORS = utilsModule.loadImageWithCORS;
            getCacheImage = utilsModule.getCacheImage;
            round = utilsModule.round;
            CUSTOM_CAMERA_TYPE = utilsModule.CUSTOM_CAMERA_TYPE;
            utilsModuleLoaded = true;
            console.log('✅ loadImageWithCORS loaded:');
            // 预加载所有背景图
            preloadBackgroundImages();
            // 触发组件更新，确保模板能使用最新的方法
            if (typeof forceUpdate === 'function') {
              forceUpdate();
              renderFrame();
            }
          }).catch(error => {
            console.error('❌ load tools err:', error);
            console.error('❌ err detail:', error.message);
            // 1秒后重试
            setTimeout(importUtilsModule, 1000);
          });
        };
        // 立即开始导入
        importUtilsModule();
        
        // 定义getter以便在模板中安全使用
        const safeLoadImageWithCORS = () => {
          if (loadImageWithCORS) {
            return loadImageWithCORS;
          }
          console.warn('⚠️ loadImageWithCORS尚未加载完成，正在使用占位函数');
          return (url, onSuccess, onError) => {
            // 如果模块未加载完成，使用延时重试策略
            // if (!utilsModuleLoaded) {
            //   setTimeout(() => {
            //     if (loadImageWithCORS) {
            //       loadImageWithCORS(url, onSuccess, onError);
            //     } else {
            //       if (onError) onError('模块加载超时');
            //     }
            //   }, 100);
            // }
          };
        };
        
            
        console.log('⚙️ Vue组件setup中，loadImageWithCORS初始状态:', typeof loadImageWithCORS);


        // 状态
        const canvas = ref(null);
        const ctx = ref(null);

        // 离屏Canvas
        let offscreenCanvas = null;
        let offscreenCtx = null;
        const isPlaying = ref(false);
        const currentTime = ref(0); // 修改为响应式引用
        const loop = ref(false);
        const zoom = ref(1);
        const animationFrameId = ref(null);
        let lastTime = 0;
        const selectedShotId = ref(null); // 选中的分镜
        const selectedRoleId = ref(null); // 选中的角色
        // FPS相关变量
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        // 目标FPS，范围25-30，默认25
        const targetFps = ref(25);
        // 背景图缓存对象，用于预加载
        const bgImagesCache = ref({});
        
        // 画布尺寸选项 - 添加1K、2K、4K分辨率
        const canvasSizes = ref([
          { name: '高清 (1920 × 1080)', width: 1920, height: 1080 },
          { name: '2k (2560 × 1440)', width: 2560, height: 1440 },
          { name: '4K (4096 × 2160)', width: 4096, height: 2160 }
        ]);
        
        // 导出摄像机尺寸选项
        const cameraSizes = ref([
          { name: '854 × 480', width: 854, height: 480 },
          { name: '1280 × 720', width: 1280, height: 720 },
          { name: '1920 × 1080', width: 1920, height: 1080 },
          { name: '2560 × 1440', width: 2560, height: 1440 }
          
        ]);
        //无效位置，如果x1,y1为此值，表明表情属于固定位置表情
        const invalidPos = -999;
        // 摄像机相关状态
        let showCamera = ref(false); // 是否显示摄像机
        const showCameraPreview = ref(false); // 是否显示相机预览
        const showCameraTrack = ref(true); // 是否显示镜头轨道
        const previewCanvas = ref(null); // 预览Canvas
        const enableCameraEdit = ref(false); // 是否启用摄像机编辑功能
        // let cameraX = 0; // 摄像机X位置
        // let cameraY = 0; // 摄像机Y位置
        let cameraWidth = cameraSizes.value[2].width; // 摄像机宽度
        let cameraHeight = cameraSizes.value[2].height; // 摄像机高度
        
        // 虚拟镜头视口系统扩展状态
        const cameraZoom = ref(1); // 摄像机缩放级别，1为原始大小
        const cameraRotation = ref(0); // 摄像机旋转角度，单位为度
        const selectedCameraPreset = ref(''); // 当前选择的镜头预设
        let isTransitioning = false; // 是否正在进行平滑过渡
        let transitionStartTime = 0; // 过渡开始时间
        let transitionDuration = 500; // 过渡持续时间（毫秒）
        let targetCameraX = 0; // 目标摄像机X位置
        let targetCameraY = 0; // 目标摄像机Y位置
        let targetCameraZoom = 1; // 目标摄像机缩放级别
        let targetCameraRotation = 0; // 目标摄像机旋转角度
        let startCameraX = 0; // 过渡开始时的摄像机X位置
        let startCameraY = 0; // 过渡开始时的摄像机Y位置
        let startCameraZoom = 1; // 过渡开始时的摄像机缩放级别
        let startCameraRotation = 0; // 过渡开始时的摄像机旋转角度
        const cameraPresets = ref([
          { name: '特写', width: 854, height: 480, rotation: 0 },
          { name: '近景', width: 1080, height: 635, rotation: 0 },
          { name: '中景', width: 1280, height: 720, rotation: 0 },
          { name: '全景', width: 1920, height: 1080, rotation: 0 }
        ]); // 摄像机预设配置数组，包含初始预设
        
        // 默认镜别设置
        const defaultCameraScenery = ref('全景');
        // 默认对话镜别设置
        const defaultDialogCameraScenery = ref('近景');
        
        // 当默认镜别改变时，将其存储到localStorage
        watch(defaultCameraScenery, (newValue) => {
          console.log('步骤2: 已在localStorage中设置defaultCameraScenery为', newValue);
          localStorage.setItem('defaultCameraScenery', newValue);
        });
        // 当默认对话镜别改变时，将其存储到localStorage
        watch(defaultDialogCameraScenery, (newValue) => {
          console.log('已在localStorage中设置defaultDialogCameraScenery为', newValue);
          localStorage.setItem('defaultDialogCameraScenery', newValue);
        });
        watch(enableCameraEdit, (newValue) => {
          console.log('enableCameraEdit 变化:', newValue);
          if(newValue){
            showCamera.value = true;
            if (cameraModule) cameraModule.showCameraClick(true);
          }
        })
        
        // 在组件挂载后
        onMounted(() => {
          console.log('on1Mounted localStorage');
          // 从localStorage加载保存的值
          // 加载默认镜头设置
          const savedValue = localStorage.getItem('defaultCameraScenery');
          if (savedValue) {
            console.log('步骤1: 从localStorage加载defaultCameraScenery值:', savedValue);
            defaultCameraScenery.value = savedValue;
          }
          // 加载默认对话镜头设置
          const savedDialogValue = localStorage.getItem('defaultDialogCameraScenery');
          if (savedDialogValue) {
            console.log('从localStorage加载defaultDialogCameraScenery值:', savedDialogValue);
            defaultDialogCameraScenery.value = savedDialogValue;
          }
          
          Vue.nextTick(() => {
            // 更新默认镜头select值
            const selectElement = document.querySelector('select[v-model="defaultCameraScenery"]');
            if (selectElement) {
              // 确保select值与defaultCameraScenery保持一致
              selectElement.value = defaultCameraScenery.value || '全景';
              // 触发change事件，确保Vue实例能够感知到这个变化
              const event = new Event('change', { bubbles: true });
              selectElement.dispatchEvent(event);
            }
            // 更新默认对话镜头select值
            const dialogSelectElement = document.querySelector('select[v-model="defaultDialogCameraScenery"]');
            if (dialogSelectElement) {
              // 确保select值与defaultDialogCameraScenery保持一致
              dialogSelectElement.value = defaultDialogCameraScenery.value || '近景';
              // 触发change事件，确保Vue实例能够感知到这个变化
              const dialogEvent = new Event('change', { bubbles: true });
              dialogSelectElement.dispatchEvent(dialogEvent);
            }
          });
        });
        
        
        // 用于预设命名的变量
        const presetName = ref('');
        
        // 虚拟镜头控制选项
        const enableCameraRotation = ref(false); // 是否启用摄像机旋转
        const showCameraInfo = ref(false); // 是否显示摄像机信息
        const useSmoothTransition = ref(true); // 是否使用平滑过渡
        const isMaintainingAspectRatio = ref(true); // 是否保持宽高比

        // 角色预览相关
        const showRolePreview = ref(false); // 控制角色预览显示
        const currentSceneRoles = ref([]); // 当前场景的角色信息
        const roleThumbnailRefs = ref({}); // 存储角色缩略图画布引用
        const showRoleDropdown = ref(false); // 控制添加角色下拉菜单的显示
        
        // 选中的摄像机尺寸 - 设置为1280 × 720比例
        const selectedCameraSize = ref(cameraSizes.value[2]);
        
        // 声明expressionManager变量
        let expressionManager;
        
        // 初始化摄像机模块
        let cameraModule;
        // 先定义一个空的renderFrame函数骨架，解决初始化顺序问题
        // let renderFrame = () => {
        //   // 实际实现会在后面定义
        // };
        
        // 声明setupCameraEvents变量，稍后在摄像机模块初始化后赋值
        let setupCameraEvents;
        
        // 声明音频管理器变量
        let audioManager;
        
        // 先导入RoleExpressionManager类并初始化expressionManager
        import('./role-expression-manager.mjs').then(roleModule => {
          // 创建RoleExpressionManager实例
          expressionManager = new roleModule.RoleExpressionManager();
        }).catch(error => {
          console.error('导入角色表情管理器模块失败:', error);
        });
        
        // 导入音频管理器模块
        import('./audio-manager.mjs').then(({ default: AudioManager }) => {
          // 创建AudioManager实例
          audioManager = new AudioManager();
        }).catch(error => {
          console.error('导入音频管理器模块失败:', error);
        });

          // 使用ES模块导入摄像机模块
        import('./camera.mjs').then(module => {

          try {
            // 传入必要的应用对象给摄像机模块
            cameraModule = module.initCamera({
              showCameraPreview,
              previewCanvas,
              cameraSizes,
              cameraZoom,
              cameraRotation,
              isMaintainingAspectRatio,
              enableCameraRotation,
              showCameraInfo,
              useSmoothTransition,
              cameraPresets,
              defaultCameraScenery,
              canvas,
              ctx,
              offscreenCanvas,
              offscreenCtx,
              renderFrame,
              selectedCameraSize,
              timeline,
              expressionManager,
              getExpressionTrackByRoleId,
              calculateCurrentExpressPosition,
              enableCameraEdit
            });
            
            // 更新引用
            // cameraX = cameraModule.cameraX;
            // cameraY = cameraModule.cameraY;
            // cameraWidth = cameraModule.cameraWidth;
            // cameraHeight = cameraModule.cameraHeight;
            // let size = {
            //   'width':cameraWidth,
            //   'height':cameraHeight
            // }
            // cameraModule.resetCamera(size);
            // 在摄像机模块初始化后设置setupCameraEvents
            setupCameraEvents = cameraModule.setupCameraEvents;
            
            // 确保设置摄像机事件监听，即使initCanvas已经执行过
            if (canvas.value && setupCameraEvents && typeof setupCameraEvents === 'function') {
              setupCameraEvents();
              //console.log('摄像机事件监听已在模块加载完成后设置');
            }else{
              console.error('camera event listener setup failed ！！！！！');
            }
          } catch (error) {
            console.error('init camera module err:', error);
          }
        }).catch(error => {
          console.error('import camera module err:', error);
        });


        // DOM引用
        const timeScale = ref(null);
        const timeMarkers = ref(null);
        const shotTrack = ref(null);
        const shotContainer = ref(null);
        const expressionContainers = ref({});
        const expressionTracks = ref({});
        
        // 用于设置动态ref的函数
        const setExpressionContainerRef = (roleId) => {
          return (el) => {
            if (el) {
              expressionContainers.value[roleId] = el;
            }
          }
        };


        
        // 添加拖拽功能
        let isDragging = false;
        let offsetX, offsetY;
        // 关闭相机预览
        const closeCameraPreview = () => {
          showCameraPreview.value = false;
        };

        // 监听摄像机关键属性变化，实时更新预览
        const unwatchCameraProperties = watch(
          [//cameraX, cameraY, cameraModule.cameraX, cameraModule.cameraY,????
          // cameraWidth, cameraHeight,
           cameraZoom, cameraRotation],
          () => {
            if (showCameraPreview.value && cameraModule) {
              // cameraModule.updateCameraPreview();
            }
          },
          { deep: true }
        );

        // 监听currentTime变化，更新显示
        // watch(currentTime, () => {
        //   updateTimelineDisplay();
        //   renderFrame(30);
        // });
        // 确保在主画布渲染完成后也更新预览
        watch([currentTime /*, isPlaying*/], () => {
          // 强制重新绘制时间轴及分镜轨道
          updateTimelineDisplay();

          if (showCameraPreview.value && cameraModule) {
            // 使用setTimeout确保在主渲染完成后再更新预览
            // setTimeout(() => {
              // cameraModule.updateCameraPreview(currentTime.value);
            // }, 0);
            //
            //渲染一帧，如果当前不是播放状态，且预览界面打开，就渲染当前时间的一帧
            if(!isPlaying.value){
              // console.log('111');
              renderFrame();
            }
            if(currentTime.value==0){

            }
          }

          // 然后额外应用高亮效果
          setTimeout(() => updateShotHighlights(), 0);
        });


        // 确保showCameraPreview复选框的变化能够触发强制刷新
        document.querySelectorAll('input[type="checkbox"][v-model="showCameraPreview"]').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
              console.log('打开相机预览');
              // 使用setTimeout确保DOM更新完成后再刷新
              // setTimeout(() => {
              //   if (cameraModule) {
              //     // cameraModule.forceUpdateCameraPreview();
              //   }
              // }, 100);
            }
          });
        });
        
                
        // 控制是否显示所有角色表情轨道的响应式变量
        const showAllRoleExpressions = ref(true);
        
        // 显示提示信息
        const showAlert = (message) => {
          // 创建提示框元素
          const alertElement = document.createElement('div');
          alertElement.className = 'fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-all duration-300 opacity-0 transform translate-y-[-20px]';
          alertElement.textContent = message;
          
          // 添加到文档
          document.body.appendChild(alertElement);
          
          // 显示提示框
          setTimeout(() => {
            alertElement.style.opacity = '1';
            alertElement.style.transform = 'translateY(0)';
          }, 10);
          
          // 3秒后隐藏并移除提示框
          setTimeout(() => {
            alertElement.style.opacity = '0';
            alertElement.style.transform = 'translateY(-20px)';
            setTimeout(() => {
              document.body.removeChild(alertElement);
            }, 300);
          }, 3000);
        };




        
        

        
        const setExpressionTrackRef = (roleId) => {
          return (el) => {
            if (el) {
              expressionTracks.value[roleId] = el;
            }
          }
        };
        
        const MARGIN = 20;//刻度间的间隔，像素

        // 添加一个调试信息的响应式数据
        const debugInfo = ref('');

        // 时间轴数据
        const timeline = ref({
          scenes: [...mockScenes],
          shots: [...mockShots],
          roles: [...mockRoles],
          avatars: mockAvatars,
          expressions: allExpressions,
          expressionTracks: [...mockExpressionTracks]
        });
        
        // 根据当前时间获取所属场景中的角色信息
        const getSceneRolesByTime = (time) => {
          // 找到当前时间所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            time >= shot.startTime && time < shot.startTime + shot.duration
          );
          
          if (!currentShot) {
            // 如果没有找到当前分镜，返回空数组
            return [];
          }
          
          // 找到包含当前分镜的场景
          const currentScene = timeline.value.scenes.find(scene => 
            scene.shots.includes(currentShot.id)
          );
          
          // 返回场景中的角色信息，如果场景不存在或没有角色信息，则返回空数组
          return currentScene && currentScene.roles ? [...currentScene.roles] : [];
        };
        

        // 计算属性
        const totalDuration = computed(() => {
          if (timeline.value.shots.length === 0) return 0;
          return Math.max(...timeline.value.shots.map(shot => shot.startTime + shot.duration));
        });
        
        // 计算时间轴总宽度 (像素) - 增加足够的宽度以确保标签不会重叠
        const timelineWidth = computed(() => {
          // 增加更多的宽度，确保即使在低缩放级别下也有足够的空间
          // 计算总时长的秒数
          const totalSeconds = Math.ceil(totalDuration.value / 1000) + 30;
          // 根据缩放级别和总时长计算宽度，并增加足够的余量
          return (totalSeconds * zoom.value * 1.5) + 200; // 增加1.5倍的空间和200px的余量
        });
        

        
        // 时间轴指针位置 (固定在父div的正中间)
        const markerPosition = computed(() => {
          // 获取时间轴指针的直接父元素
          // 直接父元素是带有":style="{ width: '100%'}"的div
          const timelineMarkerElement = document.querySelector('.timeline-marker');
          
          if (timelineMarkerElement && timelineMarkerElement.parentElement) {
            const parentDiv = timelineMarkerElement.parentElement;
            const parentWidth = parentDiv.offsetWidth;
            const position = parentWidth / 2;
            
            // 更新调试信息
            // debugInfo.value = `使用直接父div的width/2: width=${parentWidth}px, position=${position}px`;
            // console.log(debugInfo.value);
            
            return position;
          }
          //console.log('指针找不到父div');

          
          // 后备方案1：使用timelineContainer的宽度
          const timelineContainer = document.getElementById('timelineContainer');
          if (timelineContainer) {
            const width = timelineContainer.offsetWidth;
            //debugInfo.value = `使用timelineContainer: width=${width}px`;
            // console.log(debugInfo.value);
            return width / 2;
          }
          
          // 后备方案2：使用视口宽度的70%
          //debugInfo.value = '未找到父元素，使用视口宽度的70%';
          // console.log(debugInfo.value);
          return (window.innerWidth * 0.5);
        });
        
        // 获取选中角色当前的表情信息
        const selectedRoleExpression = computed(() => {
          if (!selectedRoleId.value) return null;

          console.log('选中角色id:',selectedRoleId.value)
          // 找到当前时间点该角色的表情轨道
          selectedTrack = getExpressionTrackByRoleId(selectedRoleId.value,currentTime.value) || null;
          if (selectedTrack) {
            console.log('选中角色设置的表情轨道:',selectedTrack)
            return selectedTrack
          }
          
          selectedTrack = timeline.value.expressionTracks.find(track => 
            track.roleId === selectedRoleId.value
          ) || null;
          console.log('选中角色默认轨道:',selectedTrack)
          return selectedTrack
        });
        
        // 格式化时间显示 (毫秒 -> mm:ss)
        const formatTime = (ms) => {
          const seconds = Math.floor(ms / 1000) % 60;
          const minutes = Math.floor(ms / 60000);
          return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };

        const formatTimess = (ms) => {
          const seconds = Math.floor(ms / 1000) % 60;
          const minutes = Math.floor(ms / 60000);
          const milliseconds = Math.floor(ms % 1000);
          return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        };
        
        // 获取表情名称
        const getExpressionName = (expressionId) => {
          if (!expressionId) {
            console.warn('尝试获取空的表情ID');
            return '未选择表情';
          }
          
          for (const role of timeline.value.roles) {
            if (!role || !role.expressions) continue;
            const exp = role.expressions.find(e => e && e.id === expressionId);
            if (exp) return exp.name;
          }
          return '未知表情';
        };
        
        
        // 选中的摄像机尺寸定义已移到setup函数开始部分
        
        // 监听摄像机尺寸变化
        // 监听相机尺寸变化
        watch(selectedCameraSize, () => {
          if (selectedCameraSize.value) {
            const cameraWidth = selectedCameraSize.value.width;
            const cameraHeight = selectedCameraSize.value.height;
            
            console.log('selectedCameraSize:',selectedCameraSize.value)
            let tmp_cameraAspectRatio = cameraWidth/cameraHeight;
            if (cameraModule) {
              //tmp_cameraAspectRatio
              let tmpSize = cameraSizes.value[0];
              cameraModule.resetCamera(tmpSize);
              //cameraModule.resetCamera(selectedCameraSize.value); // 重置摄像机位置到画布中心
            }
            renderFrame(1); // 重新渲染
          }
        });
        
        // 表情面板相关状态
        const showExpressionPanel = ref(false);
        const selectedExpressionId = ref(null);
        const sceneData = {
            width: 2560,    // 全景宽度 4096 2560
            height: 1440,   // 全景高度 2160  1440
        }
        
        // 当前选中的画布尺寸
        const selectedCanvasSize = ref(canvasSizes.value[1]); // 默认选择超高清选项
        
        // 监听画布尺寸变化
        watch(selectedCanvasSize, (newSize) => {
          console.log('selectedCanvasSize:',newSize)
          sceneData.width = newSize.width;
          sceneData.height = newSize.height;
          resizeCanvas(); // 重新调整画布尺寸
        });

        // 镜头设置
        const camera = {
            x: 0,           // 镜头X位置 (0-100百分比)
            y: 0,           // 镜头Y位置 (0-100百分比)
            zoom: 100,      // 缩放百分比
            rotation: 0,    // 旋转角度
            width: 1280,    // 镜头宽度 (导出尺寸)
            height: 720,   // 镜头高度 (导出尺寸)
            isDragging: false,
            dragOffset: { x: 0, y: 0 },
            resizeHandle: null
        };

        // 缩放比例状态（1表示100%，0.5表示50%，2表示200%）
        const canvasZoom = ref(1);
        
                 
        // 设置画布尺寸并应用等比缩放
        const resizeCanvas = () => {
          const container = document.getElementById('canvasContainer');
          if (container) {
            // 获取父容器的可用尺寸
            const parentWidth = container.parentElement.clientWidth;
            const parentHeight = container.parentElement.clientHeight;
            
            // 设置Canvas实际像素大小
            canvas.value.width = sceneData.width;
            canvas.value.height = sceneData.height;
            
            // 同步调整离屏Canvas尺寸
            offscreenCanvas.width = canvas.value.width;
            offscreenCanvas.height = canvas.value.height;
            
            // 应用缩放比例，保持原始宽高比
            const canvasRatio = canvas.value.width / canvas.value.height;
            const containerRatio = parentWidth / parentHeight;
            
            let displayWidth, displayHeight;
            
            // 根据容器与画布的宽高比决定如何缩放
            if (containerRatio > canvasRatio) {
              // 容器更宽，按高度缩放
              displayHeight = Math.min(parentHeight, canvas.value.height * canvasZoom.value);
              displayWidth = displayHeight * canvasRatio;
            } else {
              // 容器更高或相等，按宽度缩放
              displayWidth = Math.min(parentWidth, canvas.value.width * canvasZoom.value);
              displayHeight = displayWidth / canvasRatio;
            }
            console.log('resizeCanvas displaySize:',displayWidth, displayHeight);

            // 设置Canvas显示尺寸
            canvas.value.style.width = displayWidth + 'px';
            canvas.value.style.height = displayHeight + 'px';
            
            // 居中显示Canvas
            canvas.value.style.marginLeft = (parentWidth - displayWidth) / 2 + 'px';
            canvas.value.style.marginTop = (parentHeight - displayHeight) / 2 + 'px';
            console.info('resizeCanvas displaySize:',displayWidth, displayHeight,'parentWidth:',parentWidth);
            // 设置 canvas 容器宽度（新增这一行）
            // container.style.width = `${displayWidth}px`;
          }
          
          //if (cameraModule) { cameraModule.resetCamera(); } // 重置摄像机位置到画布中心
          
          // 立即绘制一个简单的背景，测试canvas是否正常工作
          ctx.value.fillStyle = '#f0f0f0';
          ctx.value.fillRect(0, 0, canvas.value.width, canvas.value.height);
          
          console.info('resizeCanvas: ' + canvas.value.width + '×' + canvas.value.height + ', zoom: ' + (canvasZoom.value * 100) + '%');
          renderFrame(2);
        };
          

        // 初始化画布
        const initCanvas = () => {
          canvas.value = document.getElementById('animationCanvas');
          
          // 添加调试信息，检查canvas是否正确获取
          if (!canvas.value) {
            console.error('canvas err');
            // debugInfo.value = 'canvas err';
            return;
          }
          
          ctx.value = canvas.value.getContext('2d');
          
          // 添加调试信息，检查上下文是否正确获取
          if (!ctx.value) {
            console.error('无法获取canvas上下文');
            debugInfo.value = '无法获取canvas上下文';
            return;
          }
          
          // 定义组件级变量，确保所有函数都能访问
          offscreenCanvas = document.createElement('canvas');
          offscreenCtx = offscreenCanvas.getContext('2d');
          
          // 获取Canvas容器引用
          canvasContainer = document.getElementById('canvasContainer');
          if (!canvasContainer) {
            console.error('未找到canvasContainer元素');
            debugInfo.value = '未找到canvasContainer元素';
            return;
          }
          
          // 初始化预览Canvas
          previewCanvas.value = document.getElementById('previewCanvas');
          if (previewCanvas.value) {
            previewCtx = previewCanvas.value.getContext('2d');
            console.log('初始化previewCtx:',previewCtx);
          }
          
          // 初始化摄像机位置在画布中心
          //if (cameraModule) { cameraModule.resetCamera(); }
          
           // 监听窗口尺寸变化
          window.addEventListener('resize', resizeCanvas);
          
          // 监听缩放比例变化
          watch(canvasZoom, () => {
            console.log('watch canvasZoom:',canvasZoom.value);
            resizeCanvas();
          });
          
          // 初始化时调用一次，确保Canvas尺寸正确设置
          resizeCanvas();
        };
        
        // Canvas缩放控制函数
        const canvasZoomIn = () => {
          console.log('canvasZoomIn:',canvasZoom.value);
          canvasZoom.value = Math.min(canvasZoom.value * 1.2, 4); // 最大缩放4倍
        };
        
        const canvasZoomOut = () => {
          console.log('canvasZoomOut:',canvasZoom.value);
          canvasZoom.value = Math.max(canvasZoom.value / 1.2, 0.25); // 最小缩放0.25倍
        };
        
        const canvasResetZoom = () => {
          canvasZoom.value = 1; // 重置为100%
        };
        
        // 绘制时间刻度
        const drawTimeMarkers = () => {
          if (!timeMarkers.value) return;
          
          // 清空现有刻度
          timeMarkers.value.innerHTML = '';
          
          // 计算总时长的秒数
          const totalSeconds = Math.ceil(totalDuration.value / 1000) + 30;
          
          // 根据缩放级别动态调整显示间隔，比原来扩大10倍
          let showInterval;
          if (zoom.value >= 5) {
            showInterval = 5; // 最高缩放级别，每10秒显示一个
          } else if (zoom.value >= 3) {
            showInterval = 10; // 高缩放级别，每20秒显示一个
          } else if (zoom.value >= 1) {
            showInterval = 20; // 中等缩放级别，每50秒显示一个
          } else if (zoom.value >= 0.5) {
            showInterval = 50; // 低缩放级别，每100秒显示一个
          } else {
            showInterval = 100; // 最低缩放级别，每300秒显示一个
          }
          // console.log('showInterval:',showInterval)
          // 计算标签文本最小宽度（估计约60像素）
          const minLabelWidth = 60;
          
          // 确保即使在最高缩放级别下，标签之间也有足够的空间
          let actualShowInterval = showInterval;
          if (zoom.value >= 4) {
            // 计算在当前缩放级别下，两个标签之间需要的最小间隔（秒）
            const requiredSecondsBetweenLabels = minLabelWidth / zoom.value;
            actualShowInterval = Math.max(actualShowInterval, Math.ceil(requiredSecondsBetweenLabels));
          }
          
          // 绘制刻度
          for (let t = 0; t <= totalSeconds; t++) {
            const timeMs = t * 1000;
            const x = (timeMs / 1000) * zoom.value;
            
            // 创建刻度线
            const tick = document.createElement('div');
            // 设置唯一ID
            tick.id = `tick-${t}`;
            tick.className = 'time-tick';
            // 设置正确的位置，使用与其他元素一致的计算方式
            const tickPosition = ((timeMs - currentTime.value) / 1000) * MARGIN * zoom.value;
            tick.style.left = `calc(50% + ${tickPosition}px)`;
            // 设置宽度为父容器的宽度
            // tick.style.width = '100%';
            tick.style.width = '2px';

            // 根据是否是重要时间点调整刻度线高度
            if (t % 30 === 0) {
              tick.classList.add('time-tick-major');
            } else if (t % 5 === 0) {
              tick.classList.add('time-tick-medium');
            } else if (t % showInterval === 0) {
              tick.classList.add('time-tick-minor');
            } else {
              tick.classList.add('time-tick-minor');
            }

            // timeMarkers.style.width = '100%';
            timeMarkers.id = 'timeMarkers';
            timeMarkers.value.appendChild(tick);
            
            // 创建时间标签 (只在主要时间点显示标签)
            if (t % 5 === 0) {
              const label = document.createElement('div');
              label.className = 'time-label';
              // 使用与刻度线相同的位置计算方式
              label.style.left = `calc(50% + ${tickPosition}px)`;
              label.textContent = formatTime(timeMs);
              
              // 重要时间点使用更醒目的样式
              if (t % 30 === 0) {
                label.classList.add('time-label-major');
              }
              
              timeMarkers.value.appendChild(label);
            }
          }
        };
        
        // DOM引用 - 添加场景轨道引用
        const sceneTrack = ref(null);
        const sceneContainer = ref(null);
        const cameraContainer = ref(null); // 镜头轨道容器引用
        const audioContainer = ref(null); // 音频轨道容器引用
        
        
        // 绘制音频轨道
        const drawAudioTracks = () => {
          // 与镜头相同的检查方式
          if (!audioContainer.value) {
            console.warn('audioContainer not found!');
            return;
          }
          
          // 清空现有音频轨道
          audioContainer.value.innerHTML = '';
          
          // 遍历所有分镜
          timeline.value.shots.forEach(shot => {
            // 检查分镜是否有音频数据，与镜头处理方式一致
            if (!shot.audios || !Array.isArray(shot.audios)) {
              console.warn(`shot ${shot.id} no audios`);
              return;
            }
            
            // 遍历分镜中的所有音频
            shot.audios.forEach((audio, index) => {
              // 确保音频有唯一ID
              if (!audio.id) {
                audio.id = `audio_${shot.id}_${Date.now()}_${index}`;
              }
              
              const tmpRound = (x) => {
                return Math.round(x * 10)/10;
              }

              // 计算音频在时间轴上的位置和宽度 - 与镜头相同的计算方式
              const startTime = shot.startTime + (audio.startTime || 0);
              const endTime = startTime + (audio.audioDuration || shot.duration);
              const startX = ((startTime - currentTime.value) / 1000) * MARGIN * zoom.value;
              const width = ((endTime - startTime) / 1000) * MARGIN * zoom.value;              
              const audioDuration = tmpRound(audio.audioDuration / 1000);


              // 创建音频轨道元素，与镜头相同的元素创建方式
              const audioEl = document.createElement('div');
              audioEl.className = 'audio-item';
              audioEl.style.left = `calc(50% + ${startX}px)`;
              audioEl.style.top = '0';
              audioEl.style.width = `${width}px`;
              audioEl.style.maxWidth = `${width}px`;
              audioEl.dataset.audioId = audio.id;
              audioEl.dataset.shotId = shot.id;
              audioEl.style.position = 'absolute';
              audioEl.style.zIndex = '1'; // 提高z-index确保可见 1
              audioEl.style.backgroundColor = 'rgba(16, 185, 129, 0.3)'; // 更明显的绿色 0.2 0.7
              audioEl.style.border = '1px solid rgba(16, 185, 129, 1)';//0.5 1
              audioEl.style.overflow = 'hidden';
              audioEl.style.textOverflow = 'clip';//ellipsis clip
              audioEl.style.whiteSpace = 'nowrap';              
              audioEl.style.textAlign = 'left';    // 文本左对齐（确保左边内容优先显示）
              audioEl.style.direction = 'ltr';     // 文本方向从左到右（默认值，可省略）
              // audioEl.style.fontSize = '12px';
              // audioEl.style.color = 'white'; // 确保在绿色背景上可见 green white
              // audioEl.style.height = '100%'; // 确保高度填充父容器
              audioEl.style.fontSize = '12px';
              audioEl.style.color = 'black';
              audioEl.style.height = '100%';
              audioEl.style.display = 'flex';
              audioEl.style.alignItems = 'center';
              audioEl.style.justifyContent = 'flex-start';
              audioEl.style.padding = '0 2px';
              
              // 设置音频显示内容
              const role = timeline.value.roles.find(r => r.id === audio.roleId);
              const roleName = role ? role.name : '未知角色';
              //audioEl.textContent = `${roleName}: ${audio.text || '音频'}`;
              audioEl.textContent = `${roleName}`;
              
              // 在最右侧添加时间点显示，设置更小的字体
              const timeLabel = document.createElement('span');
              timeLabel.className = 'text-xs -mt-1 bg-black/20 px-1 rounded';
              timeLabel.style.position = 'absolute';
              timeLabel.style.right = '2px';
              timeLabel.style.top = '0px';
              timeLabel.style.color = 'white';
              timeLabel.style.fontSize = '10px'; // 比text-xs更小的字体
              timeLabel.textContent = `${audioDuration}s`;
              audioEl.appendChild(timeLabel);
              



              // 添加到容器
              audioContainer.value.appendChild(audioEl);
            });
          });
        };
        
        // 绘制场景轨道
        const drawSceneTrack = () => {
          if (!sceneContainer.value) return;
          
          // 清空现有场景
          sceneContainer.value.innerHTML = '';

          // 为每个场景创建一个横线
          timeline.value.scenes.forEach((scene, sceneIndex) => {
            // 获取场景包含的所有分镜
            const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
            
            if (sceneShots.length === 0) return;
            
            // 按时间顺序排序分镜
            const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
            
            // 计算场景的起始时间和持续时间
            const sceneStartTime = sortedShots[0].startTime;
            const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
            const sceneDuration = sceneEndTime - sceneStartTime;
            
            // 计算场景横线在轨道上的位置和宽度
            let startX = ((sceneStartTime - currentTime.value) / 1000) * MARGIN * zoom.value;
            let width = ((sceneDuration-200) / 1000) * MARGIN * zoom.value;
            
            
            // 创建场景容器元素
            const sceneEl = document.createElement('div');
            sceneEl.className = 'absolute top-0 left-0 h-full';
            sceneEl.style.left = `calc(50% + ${startX}px)`;
            sceneEl.style.width = `${width}px`;
            
            // 创建横线（使用div和border样式）
            const lineEl = document.createElement('div');
            lineEl.className = 'w-full h-full flex items-center justify-center';
            
            // 创建一个更明显的横线
            const lineDiv = document.createElement('div');
            lineDiv.className = 'w-full border-t-2 border-purple-500';
            
            lineEl.appendChild(lineDiv);
            
            // 创建场景标签元素
            const labelEl = document.createElement('div');
            labelEl.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-purple-500 text-white text-[10px] font-medium px-1.5 py-0.25 rounded whitespace-nowrap';
            labelEl.textContent = `场景${sceneIndex + 1}`;
            
            sceneEl.appendChild(lineEl);
            sceneEl.appendChild(labelEl);
            sceneContainer.value.appendChild(sceneEl);
          });
        };
        
        // 绘制分镜轨道
        const drawShotTrack = () => {
          if (!shotContainer.value) return;
          
          // 清空现有分镜
          shotContainer.value.innerHTML = '';
          
          // 按时间顺序对分镜进行排序，确保不重叠
          const sortedShots = [...timeline.value.shots].sort((a, b) => a.startTime - b.startTime);
          
          // 为了确保分镜不重叠，我们需要计算每个分镜的实际起始位置
          // 创建一个数组来存储每个分镜的实际位置信息
          const shotPositions = [];
          
          // 第一步：计算所有分镜的初始位置
          sortedShots.forEach((shot, index) => {
            // 计算分镜在轨道上的位置和宽度
            const startX = ((shot.startTime-currentTime.value) / 1000) * MARGIN * zoom.value;
            const width = ((shot.duration) / 1000) * MARGIN * zoom.value; // 秒数*MARGIN
            const endX = startX + width;
            //console.log('currentTime:',currentTime, currentTime, shot.startTime);
            shotPositions.push({
              shot,
              startX,
              width,
              endX,
              originalStartX: startX
            });
          });
          // console.log('所有分镜坐标信息：',shotPositions);
          // 第二步：检查并修复重叠
          // for (let i = 1; i < shotPositions.length; i++) {
          //   const current = shotPositions[i];
          //   const previous = shotPositions[i - 1];
            
          //   // 如果当前分镜的起始位置早于前一个分镜的结束位置，则发生重叠
          //   if (current.startX < previous.endX) {
          //     // 调整当前分镜的位置以避免重叠
          //     current.startX = previous.endX;
          //     current.endX = current.startX + current.width;
          //   }
          // }
          //console.log('修正分镜坐标信息>：',shotPositions);

          // 第三步：创建并渲染所有分镜元素
          shotPositions.forEach((pos) => {
            const shot = pos.shot;
            
            // 创建分镜元素
            const shotEl = document.createElement('div');
            // 当时间指针在分镜范围内时，应用与鼠标悬停相同的效果
            // 当时间指针在分镜范围内且分镜被选中时，额外添加蒙层效果
            // 使用严格的时间范围判断
            const shotEndTime = shot.startTime + shot.duration;
            const isTimeInShot = currentTime.value >= shot.startTime && currentTime.value < shotEndTime;
            //console.log(`分镜${shot.id}: currentTime=${currentTime.value}, startTime=${shot.startTime}, endTime=${shotEndTime}, isTimeInShot=${isTimeInShot}`);
            let shotClasses = 'shot-item';
            
            // 清除所有内联样式
            shotEl.removeAttribute('style');
            
            if (isTimeInShot) {
              // 当时间指针指向分镜时，添加高亮效果类
              shotClasses = 'shot-item time-pointer-active';
              
              if (selectedShotId.value === shot.id) {
                shotClasses += ' editing-breathing-bg';
              }
            }
            
            shotEl.className = shotClasses;
            shotEl.style.left = `calc(50% + ${pos.startX}px)`;
            shotEl.style.width = `${pos.width}px`; // 使用第一步计算好的宽度，已经是秒数*10px
            
            // 添加分镜时间信息
            const shotDuration = shot.duration / 1000;
            const startTimeFormatted = formatTime(shot.startTime);
            const endTimeFormatted = formatTime(shot.startTime + shot.duration);
            
            shotEl.innerHTML = `
              <div class="shot-header p-0 text-white rounded-sm flex justify-between items-start">
                <span class="text-[10px] -ml-0.5 -mt-1 bg-black/70 px-1 rounded">分镜${shot.id.replace('shot', '')}</span>
                <span class="text-xs -mt-1 bg-black/50 px-1 rounded">${shotDuration}s</span>
              </div>
              <div class="shot-time-info text-xs text-white p-1 rounded-sm mt-1">
                
              </div>
            `;

            //  开始时间-结束时间
            /* ${startTimeFormatted} - ${endTimeFormatted} */
            
            // 确保背景图正确显示
            shotEl.style.backgroundImage = `url(${shot.background})`;
            shotEl.style.backgroundSize = 'cover';
            shotEl.style.backgroundPosition = 'center';
            
            // 添加点击事件以选中分镜
            shotEl.addEventListener('click', (e) => {
              e.stopPropagation();
              selectedShotId.value = shot.id;
              selectedRoleId.value = null; // 选中分镜时取消角色选中
            });
            
            shotContainer.value.appendChild(shotEl);
          });
        };
        
        // 绘制镜头轨道
        const drawCameraTracks = () => {
          if (!cameraContainer.value) return;
          
          // 清空现有镜头轨道
          cameraContainer.value.innerHTML = '';
          
          // 遍历所有分镜
          timeline.value.shots.forEach(shot => {
            // 检查分镜是否有镜头轨道数据
            if (!shot.cameraTracks || !Array.isArray(shot.cameraTracks)) {
              console.warn(`分镜 ${shot.id} 没有镜头轨道数据`);
              return;
            }
            
            // 遍历分镜中的所有镜头轨道
            shot.cameraTracks.forEach((cameraTrack, index) => {
              // 确保镜头轨道有唯一ID
              if (!cameraTrack.id) {
                cameraTrack.id = `camera_track_${shot.id}_${Date.now()}_${index}`;
              }
              
              // 计算镜头轨道在时间轴上的位置和宽度
              const startTime = shot.startTime + (cameraTrack.startTime ||0);
              const endTime = startTime + (cameraTrack.duration || shot.duration);
              const startX = ((startTime - currentTime.value) / 1000) * MARGIN * zoom.value;
              const width = ((endTime - startTime) / 1000) * MARGIN * zoom.value;

              
              // if(cameraTrack.id === 'cameraTrack4-1'){
              //   console.log('shot:',shot,',cameraTrack:',cameraTrack);
              //   console.log(`镜头轨道 ${cameraTrack.id}: startTime=${startTime}, endTime=${endTime}, startX=${startX}, width=${width}`);
              // }
              

              // 创建镜头轨道元素
              const cameraEl = document.createElement('div');
              cameraEl.className = 'camera-item';
              cameraEl.style.left = `calc(50% + ${startX}px)`;
              cameraEl.style.top = '0';
              cameraEl.style.width = `${width}px`;
              cameraEl.style.maxWidth = `${width}px`;
              cameraEl.dataset.trackId = cameraTrack.id;
              cameraEl.dataset.shotId = shot.id;
              cameraEl.style.position = 'absolute';
              cameraEl.style.zIndex = '1';
              cameraEl.style.backgroundColor = 'rgba(59, 130, 246, 0.2)';
              cameraEl.style.border = '1px solid rgba(59, 130, 246, 0.5)';
              cameraEl.style.overflow = 'hidden';
              cameraEl.style.textOverflow = 'clip';
              cameraEl.style.whiteSpace = 'nowrap';
              cameraEl.style.fontSize = '10px';
              
              // 设置镜头轨道显示内容
              let cameraTypeText = '';
              switch(cameraTrack.cameraType) {
                case '远':
                  cameraTypeText = '远景';
                  break;
                case '全':
                  cameraTypeText = '全景';
                  break;
                case '中':
                  cameraTypeText = '中景';
                  break;
                case '近':
                  cameraTypeText = '近景';
                  break;
                case '特':
                  cameraTypeText = '特写';
                  break;
                default:
                  cameraTypeText = cameraTrack.cameraType;
              }
              
              let moveTypeText = cameraTrack.cameraMoveType === '1' ? '硬切' : '软切';
              cameraEl.textContent = `${cameraTypeText}-${moveTypeText}`;
              
              // 添加左右边缘拖拽句柄
              const leftHandle = document.createElement('div');
              leftHandle.className = 'camera-handle camera-handle-left';
              leftHandle.style.position = 'absolute';
              leftHandle.style.left = '0';
              leftHandle.style.top = '0';
              leftHandle.style.width = '3px';
              leftHandle.style.height = '100%';
              leftHandle.style.cursor = 'w-resize';
              leftHandle.style.backgroundColor = 'rgba(239, 68, 68, 0.7)';
              leftHandle.style.zIndex = '2';
              leftHandle.dataset.trackId = cameraTrack.id;
              leftHandle.dataset.shotId = shot.id;
              leftHandle.dataset.edgeType = 'left';
              
              const rightHandle = document.createElement('div');
              rightHandle.className = 'camera-handle camera-handle-right';
              rightHandle.style.position = 'absolute';
              rightHandle.style.right = '0';
              rightHandle.style.top = '0';
              rightHandle.style.width = '3px';
              rightHandle.style.height = '100%';
              rightHandle.style.cursor = 'e-resize';
              rightHandle.style.backgroundColor = 'rgba(239, 68, 68, 0.7)';
              rightHandle.style.zIndex = '2';
              rightHandle.dataset.trackId = cameraTrack.id;
              rightHandle.dataset.shotId = shot.id;
              rightHandle.dataset.edgeType = 'right';
              
              // 添加拖拽句柄到相机轨道元素
              cameraEl.appendChild(leftHandle);
              cameraEl.appendChild(rightHandle);
              
              // 添加到容器
              cameraContainer.value.appendChild(cameraEl);
            });
          });
        };
          

        // 表情片段拖拽状态变量
        let isDraggingExpEdge = false;
        let draggedExpTrack = null;
        let dragEdgeType = null;
        let draggingExpCurrentScene = null; // 'left' 或 'right'
        let lastMouseX = 0;

        // 相机轨道拖拽状态变量
        let isDraggingCameraEdge = false;
        let draggedCameraTrack = null;
        let draggedCameraShot = null;
        let cameraDragEdgeType = null;
        let lastCameraMouseX = 0;

        // 绘制角色表情轨道
        const drawExpressionTracks = () => {
          
          //console.log('开始绘制表情轨道...');
          
          // 首先清空所有表情容器，确保没有残留的表情片段
          for (const roleId in expressionContainers.value) {
            if (expressionContainers.value[roleId]) {
              expressionContainers.value[roleId].innerHTML = '';
            }
          }
          
          // 根据筛选状态决定要绘制的角色列表
          let rolesToDraw = [];
          if (showAllRoleExpressions.value) {
            // 选中状态：绘制所有角色的表情轨道
            rolesToDraw = timeline.value.roles;
          } else {

            if (selectedRoleId.value) {
              console.log('选中角色：', selectedRoleId.value);
              rolesToDraw = timeline.value.roles.filter(role => role.id === selectedRoleId.value);
            }
          }
          
          rolesToDraw.forEach(role => {
            const container = expressionContainers.value[role.id];
            const track = expressionTracks.value[role.id];
            
            if (!container) {
              console.warn(`can't find role container: ${role.id}`);
              return;
            }
            
            if (!track) {
              console.warn(`can't find role track: ${role.id}`);
              return;
            }
            
            //console.log(`处理角色: ${role.id} (${role.name})`);
            
            // 找到该角色的所有表情轨道
            const roleExpressionTracks = timeline.value.expressionTracks.filter(
              track => track.roleId === role.id
            );
            
            //console.log(`${role.name}找到 ${expressions.length} 个表情片段`);
            
            roleExpressionTracks.forEach(expTrack => {
              // console.log('expTrack:',expTrack);
              // 计算表情片段在轨道上的位置和宽度
              const startX = ((expTrack.startTime - currentTime.value) / 1000) * MARGIN * zoom.value;
              const width = ((expTrack.endTime - expTrack.startTime) / 1000) * MARGIN * zoom.value; // 秒数*MARGIN
              if (role.id == 'role2' && expTrack.expressionId === 'exp2-2') {
                // console.trace(`表情片段: ${exp.id}, 宽度: ${width}`);
              }

              const avatar = timeline.value.avatars[role.avatarId];
              const expressionId = expTrack.expressionId;
              const animIdx      = expTrack.animId;

              // 找到对应的表情，添加安全检查              
              const expression = timeline.value.expressions[expressionId];
              if (!expression) {
                console.warn(`can't find expression: ${expressionId}`);
              }

              let animName = '';
              let expName = expression?.name || ' 无表情 ';
              console.log('avatar',avatar, animIdx);
              if(avatar && animIdx >= 0) {
                animName = avatar.getAnimationName(animIdx);
                // console.log('animName:', animName);
              }
              
              // 确保表情轨道有唯一ID
              if (!expTrack.id) {
                expTrack.id = `track_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              }
              
              // 创建表情片段元素
              const expEl = document.createElement('div');
              expEl.className = 'expression-item';
              expEl.style.left = `calc(50% + ${startX}px)`;
              expEl.style.top = '0'; // 明确设置Y坐标为0，确保所有表情从轨道顶部开始
              expEl.style.width = `${width}px`;
              expEl.style.maxWidth = `${width}px`; // 限制最大宽度
              expEl.textContent = animName + ' - ' + expName;
              expEl.dataset.trackId = expTrack.id;
              expEl.dataset.roleId = role.id;
              expEl.style.position = 'absolute'; // 使用绝对定位确保正确定位
              expEl.style.zIndex = '1';
              expEl.style.backgroundColor = 'rgba(74, 222, 128, 0.2)';
              expEl.style.border = '1px solid rgba(0, 0, 0, 0.1)';
              // 处理文本溢出
              expEl.style.overflow = 'hidden';
              expEl.style.textOverflow = 'clip';
              expEl.style.whiteSpace = 'nowrap';
              expEl.style.fontSize = '10px'; // 减小字体大小以适应窄元素
              expEl.style.lineHeight = '1'; // 调整行高
              
              // 添加左右边缘拖拽句柄
              const leftHandle = document.createElement('div');
              leftHandle.className = 'expression-handle expression-handle-left';
              leftHandle.style.position = 'absolute';
              leftHandle.style.left = '0';
              leftHandle.style.top = '0';
              leftHandle.style.width = '3px';
              leftHandle.style.height = '100%';
              leftHandle.style.cursor = 'w-resize';
              leftHandle.style.backgroundColor = 'rgba(59, 130, 246, 0.5)';
              leftHandle.dataset.trackId = expTrack.id;
              leftHandle.dataset.edgeType = 'left';
              leftHandle.dataset.roleId = role.id;
              
              const rightHandle = document.createElement('div');
              rightHandle.className = 'expression-handle expression-handle-right';
              rightHandle.style.position = 'absolute';
              rightHandle.style.right = '0';
              rightHandle.style.top = '0';
              rightHandle.style.width = '3px';
              rightHandle.style.height = '100%';
              rightHandle.style.cursor = 'e-resize';
              rightHandle.style.backgroundColor = 'rgba(59, 130, 246, 0.5)';
              rightHandle.dataset.trackId = expTrack.id;
              rightHandle.dataset.edgeType = 'right';
              rightHandle.dataset.roleId = role.id;
              
              expEl.appendChild(leftHandle);
              expEl.appendChild(rightHandle);

              // 检查是否为带运动轨迹的表情（x,y与x1,y1不同）
              if (expTrack.x1 !== undefined && expTrack.y1 !== undefined &&
                  expTrack.x1 !== invalidPos && expTrack.y1 !== invalidPos && 
                  (expTrack.x !== expTrack.x1 || expTrack.y !== expTrack.y1)) {
                // 创建运动轨迹标记元素
                const trackMarker = document.createElement('div');
                trackMarker.className = 'expression-track-marker';
                trackMarker.style.position = 'absolute';
                trackMarker.style.top = '80%';
                trackMarker.style.transform = 'translateY(-50%)';
                trackMarker.style.left = '10%';
                trackMarker.style.width = '80%';
                trackMarker.style.height = '1px';
                trackMarker.style.backgroundColor = '#3B82F6';
                trackMarker.style.display = 'flex';
                trackMarker.style.alignItems = 'center';
                trackMarker.style.justifyContent = 'flex-end';
                
                // 添加向右的箭头符号
                const arrow = document.createElement('span');
                arrow.textContent = '>';
                arrow.style.color = '#3B82F6';
                arrow.style.fontSize = '8px';
                arrow.style.marginLeft = '2px';
                arrow.style.marginTop = '-2px';
                
                trackMarker.appendChild(arrow);
                expEl.appendChild(trackMarker);
              }
              
              // 确保添加到正确的容器
              // console.log(`  添加表情片段: ${exp.id} (${expression.name}) 到角色: ${role.id} (${role.name})`);
              container.appendChild(expEl);
            });
          });
          
          //console.log('表情轨道绘制完成');
        };

        // 添加表情片段边缘拖拽事件监听
        document.addEventListener('mousedown', (e) => {
          if ((e.button === 0) && e.target.classList.contains('camera-handle')) {
            e.stopPropagation();
            stopPlayback();
            
            const trackId = e.target.dataset.trackId;
            const shotId = e.target.dataset.shotId;
            cameraDragEdgeType = e.target.dataset.edgeType;
            
            // 找到对应的分镜
            draggedCameraShot = timeline.value.shots.find(shot => shot.id === shotId);
            
            // 找到对应的相机轨道
            if (draggedCameraShot && draggedCameraShot.cameraTracks) {
              draggedCameraTrack = draggedCameraShot.cameraTracks.find(track => track.id === trackId);
            }
            
            if (draggedCameraTrack) {
              isDraggingCameraEdge = true;
              lastCameraMouseX = e.clientX;
              // 设置全局鼠标指针样式
              document.body.style.cursor = cameraDragEdgeType === 'left' ? 'w-resize' : 'e-resize';
            }
          } else if ((e.button === 0) && e.target.classList.contains('expression-handle')) {
            e.stopPropagation();
            stopPlayback();
            
            const trackId = e.target.dataset.trackId;
            dragEdgeType = e.target.dataset.edgeType;
            
            // 获取当前点击的角色ID
            const roleId = e.target.dataset.roleId;
            
            // 找到对应的表情轨道 - 优先通过ID匹配
            draggedExpTrack = timeline.value.expressionTracks.find(track => 
              track.id && track.id === trackId
            );
            
            // 如果通过ID没有找到，再通过角色ID和位置进行近似匹配
            if (!draggedExpTrack && roleId) {
              const expItem = e.target.closest('.expression-item');
              if (expItem) {
                // 尝试解析left样式
                const leftStyle = expItem.style.left;
                let parsedLeft = 0;
                try {
                  // 处理calc()表达式或直接像素值
                  if (leftStyle.includes('calc')) {
                    // 简化处理：提取calc中的数值部分
                    const match = leftStyle.match(/calc\(50%\s*([+-])\s*(\d+)px\)/);
                    if (match) {
                      const sign = match[1];
                      const value = parseInt(match[2]);
                      parsedLeft = sign === '+' ? value : -value;
                    }
                  } else {
                    parsedLeft = parseInt(leftStyle);
                  }
                } catch (error) {
                  console.error('解析left样式失败:', error);
                }
                
                // 查找最接近的轨道
                const positionThreshold = 20; // 增大阈值以提高匹配成功率
                draggedExpTrack = timeline.value.expressionTracks.find(track => 
                  track.roleId === roleId &&
                  Math.abs(((track.startTime - currentTime.value) / 1000) * MARGIN * zoom.value - parsedLeft) < positionThreshold
                );
              }
            }
            
            if (draggedExpTrack) {
              isDraggingExpEdge = true;
              console.log(`isDraggingExpEdge = true`);
              lastMouseX = e.clientX;
              // 设置全局鼠标指针样式
              document.body.style.cursor = dragEdgeType === 'left' ? 'w-resize' : 'e-resize';
            }
          }
        });
        
        // 为表情元素添加右键菜单功能
        const setupExpressionRightClickMenu = () => {
          // 创建表情右键菜单元素
          let contextMenu = document.getElementById('expression-context-menu');
          if (!contextMenu) {
            contextMenu = document.createElement('div');
            contextMenu.id = 'expression-context-menu';
            contextMenu.style.cssText = `
              display: none;
              position: fixed;
              background: white;
              border: 1px solid #ccc;
              border-radius: 4px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.2);
              z-index: 1000;
              min-width: 160px;
              padding: 4px 0;
              font-size: 14px;
            `;
            
            // 创建菜单项
            const menuItems = [
              { id: 'set-start', text: '设置开始位置' },
              { id: 'set-end', text: '设置结束位置' },
              { id: 'fix-start', text: '固定开始位置' },
              { id: 'syn-default-pos', text: '使用默认位置' },
              { id: 'syn-pos-other', text: '同步位置到本场景所有分镜' },
              { id: 'scene-start', text: '开始时间同场景开始' },
              { id: 'scene-end', text: '结束时间同场景结束' }
            ];
            
            menuItems.forEach(item => {
              const menuItem = document.createElement('div');
              menuItem.id = `menu-${item.id}`;
              menuItem.textContent = item.text;
              menuItem.style.cssText = `
                padding: 8px 16px;
                cursor: pointer;
                white-space: nowrap;
              `;
              
              menuItem.addEventListener('mouseover', () => {
                menuItem.style.backgroundColor = '#f0f0f0';
              });
              
              menuItem.addEventListener('mouseout', () => {
                menuItem.style.backgroundColor = 'transparent';
              });
              
              menuItem.addEventListener('click', (e) => {
                e.stopPropagation();
                const expItem = document.querySelector('.context-menu-active');
                if (expItem) {
                  const trackId = expItem.dataset.trackId;
                  const roleId = expItem.dataset.roleId;
                  handleContextMenuAction(item.id, trackId, roleId);
                }
                hideContextMenu();
              });
              
              contextMenu.appendChild(menuItem);
            });
            
            document.body.appendChild(contextMenu);
          }
          
          // 创建分镜右键菜单元素
          let shotContextMenu = document.getElementById('shot-context-menu');
          if (!shotContextMenu) {
            shotContextMenu = document.createElement('div');
            shotContextMenu.id = 'shot-context-menu';
            shotContextMenu.style.cssText = `
              display: none;
              position: fixed;
              background: white;
              border: 1px solid #ccc;
              border-radius: 4px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.2);
              z-index: 1000;
              min-width: 160px;
              padding: 4px 0;
              font-size: 14px;
            `;
            
            // 创建分镜菜单项
            const shotMenuItems = [
              { id: 'shot-set-start', text: '设置开始时间' },
              { id: 'shot-set-end', text: '设置结束时间' },
              { id: 'shot-duplicate', text: '复制分镜' },
              { id: 'shot-delete', text: '删除分镜' }
            ];
            
            shotMenuItems.forEach(item => {
              const menuItem = document.createElement('div');
              menuItem.id = `shot-menu-${item.id}`;
              menuItem.textContent = item.text;
              menuItem.style.cssText = `
                padding: 8px 16px;
                cursor: pointer;
                white-space: nowrap;
              `;
              
              menuItem.addEventListener('mouseover', () => {
                menuItem.style.backgroundColor = '#f0f0f0';
              });
              
              menuItem.addEventListener('mouseout', () => {
                menuItem.style.backgroundColor = 'transparent';
              });
              
              menuItem.addEventListener('click', (e) => {
                e.stopPropagation();
                const shotItem = document.querySelector('.shot-context-menu-active');
                if (shotItem) {
                  const shotId = shotItem.dataset.shotId;
                  handleShotContextMenuAction(item.id, shotId);
                }
                hideContextMenu();
                hideShotContextMenu();
              });
              
              shotContextMenu.appendChild(menuItem);
            });
            
            document.body.appendChild(shotContextMenu);
          }
          
          // 显示右键菜单
          const showContextMenu = (e, element) => {
            const menu = document.getElementById('expression-context-menu');
            menu.style.top = e.clientY + 'px';
            menu.style.left = e.clientX + 'px';
            menu.style.display = 'block';
            
            // 添加激活状态类
            element.classList.add('context-menu-active');
          };
          

          
          // 隐藏右键菜单
          const hideContextMenu = () => {
            const menu = document.getElementById('expression-context-menu');
            menu.style.display = 'none';
            
            // 移除所有元素的激活状态
            document.querySelectorAll('.context-menu-active').forEach(el => {
              el.classList.remove('context-menu-active');
            });
          };
          
          // 处理菜单项点击事件
          const handleContextMenuAction = (action, trackId, roleId) => {
            // 找到对应的表情轨道
            const expTrack = timeline.value.expressionTracks.find(track => track.id === trackId);
            if (!expTrack) return;
            
            switch (action) {
              case 'set-start':
                // 设置开始位置为当前时间
                currentTime.value = expTrack.startTime;
                //console.log(`设置表情开始位置: ${trackId}, 时间: ${currentTime.value}`);
                renderFrame(3);
                break;
              case 'set-end':
                // 设置结束位置为当前时间
                currentTime.value = expTrack.endTime-1;
                console.log(`设置表情结束位置: ${trackId}, 时间: ${currentTime.value}`);
                renderFrame(4);
                break;
              case 'fix-start':
                // 固定开始位置（这里可以添加额外的逻辑，比如锁定开始位置防止拖动）
                // expTrack.endTime=expTrack.startTime;
                expTrack.x1 = invalidPos;
                expTrack.y1 = invalidPos;
                renderFrame(5);

                break;
              case 'scene-start':
                // 开始时间同场景开始
                // 找到表情所在的场景
                const containingScene = timeline.value.scenes.find(scene => {
                  const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                  if (sceneShots.length === 0) return false;
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneStartTime = sortedShots[0].startTime;
                  const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
                  // 检查表情轨道是否在该场景时间范围内
                  return expTrack.startTime >= sceneStartTime && expTrack.startTime <= sceneEndTime;
                });
                if (containingScene) {
                  const sceneShots = timeline.value.shots.filter(shot => containingScene.shots.includes(shot.id));
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneStartTime = sortedShots[0].startTime;
                  expTrack.startTime = sceneStartTime;
                  console.log(`设置表情开始时间为场景开始: ${trackId}, 时间: ${sceneStartTime}`);
                  renderFrame(6);
                }
                break;
              case 'scene-end':
                // 结束时间同场景结束
                // 找到表情所在的场景
                const containingSceneEnd = timeline.value.scenes.find(scene => {
                  const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                  if (sceneShots.length === 0) return false;
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneStartTime = sortedShots[0].startTime;
                  const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
                  // 检查表情轨道是否在该场景时间范围内
                  return expTrack.endTime >= sceneStartTime && expTrack.endTime <= sceneEndTime;
                });
                if (containingSceneEnd) {
                  const sceneShots = timeline.value.shots.filter(shot => containingSceneEnd.shots.includes(shot.id));
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
                  expTrack.endTime = sceneEndTime;
                  console.log(`设置表情结束时间为场景结束: ${trackId}, 时间: ${sceneEndTime}`);
                  renderFrame(7);
                }
                break;
            }


            renderFrame();

            // 更新显示 - 改为异步执行以提高性能
            requestAnimationFrame(() => {
              updateTimelineDisplay();
            });
            
          };
          
          // 隐藏分镜右键菜单
          const hideShotContextMenu = () => {
            const menu = document.getElementById('shot-context-menu');
            if (menu) {
              menu.style.display = 'none';
            }
            
            // 移除所有激活状态类
            document.querySelectorAll('.shot-context-menu-active').forEach(el => {
              el.classList.remove('shot-context-menu-active');
            });
          };
          
          // 显示分镜右键菜单
          const showShotContextMenu = (e, element) => {
            // 阻止默认右键菜单
            e.preventDefault();
            
            // 隐藏其他菜单
            hideContextMenu();
            
            // 创建菜单元素（如果不存在）
            let menu = document.getElementById('shot-context-menu');
            if (!menu) {
              menu = document.createElement('div');
              menu.id = 'shot-context-menu';
              menu.style.cssText = `
                display: none;
                position: fixed;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                z-index: 1000;
                min-width: 160px;
                padding: 4px 0;
                font-size: 14px;
              `;
              
              // 创建菜单项
              const menuItems = [
                { id: 'shot-set-start', text: '设置开始时间' },
                { id: 'shot-set-end', text: '设置结束时间' },
                { id: 'shot-duplicate', text: '复制分镜' },
                { id: 'shot-delete', text: '删除分镜' }
              ];
              
              menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.id = `shot-menu-${item.id}`;
                menuItem.textContent = item.text;
                menuItem.style.cssText = `
                  padding: 8px 16px;
                  cursor: pointer;
                  white-space: nowrap;
                `;
                
                menuItem.addEventListener('mouseover', () => {
                  menuItem.style.backgroundColor = '#f0f0f0';
                });
                
                menuItem.addEventListener('mouseout', () => {
                  menuItem.style.backgroundColor = 'transparent';
                });
                
                menuItem.addEventListener('click', (e) => {
                  e.stopPropagation();
                  const shotItem = document.querySelector('.shot-context-menu-active');
                  if (shotItem) {
                    const shotId = shotItem.dataset.shotId || shotItem.id;
                    handleShotContextMenuAction(item.id, shotId);
                  }
                  hideContextMenu();
                  hideShotContextMenu();
                });
                
                menu.appendChild(menuItem);
              });
              
              document.body.appendChild(menu);
            }
            
            menu.style.top = e.clientY + 'px';
            menu.style.left = e.clientX + 'px';
            menu.style.display = 'block';
            
            // 添加激活状态类
            element.classList.add('shot-context-menu-active');
          };
          
          // 处理分镜右键菜单项的点击事件
          const handleShotContextMenuAction = (actionId, shotId) => {
            console.log(`执行分镜操作: ${actionId} 分镜ID: ${shotId}`);
            
            // 根据操作ID执行不同的功能
            switch(actionId) {
              case 'shot-set-start':
                console.log('设置分镜开始时间', shotId);
                // 找到对应的分镜
                const shot = timeline.value.shots.find(s => s.id === shotId);
                if (shot) {
                  shot.startTime = currentTime.value;
                  updateTimelineDisplay();
                  renderFrame(31);
                }
                break;
              case 'shot-set-end':
                console.log('设置分镜结束时间', shotId);
                // 找到对应的分镜
                const shotEnd = timeline.value.shots.find(s => s.id === shotId);
                if (shotEnd) {
                  shotEnd.startTime = Math.max(0, currentTime.value - shotEnd.duration);
                  updateTimelineDisplay();
                  renderFrame(32);
                }
                break;
              case 'shot-duplicate':
                console.log('复制分镜', shotId);
                // 复制分镜的逻辑
                const originalShot = timeline.value.shots.find(s => s.id === shotId);
                if (originalShot) {
                  // 创建新分镜对象，深拷贝原始分镜
                  const newShot = JSON.parse(JSON.stringify(originalShot));
                  // 生成新的ID
                  newShot.id = 'shot-' + Date.now();
                  // 将新分镜添加到时间轴
                  timeline.value.shots.push(newShot);
                  // 找到包含该分镜的场景，并将新分镜添加到场景中
                  const containingScene = timeline.value.scenes.find(scene => scene.shots.includes(originalShot.id));
                  if (containingScene) {
                    containingScene.shots.push(newShot.id);
                  }
                  // 更新显示
                  updateTimelineDisplay();
                  renderFrame(33);
                }
                break;
              case 'shot-delete':
                console.log('删除分镜', shotId);
                // 删除分镜的逻辑
                const shotIndex = timeline.value.shots.findIndex(s => s.id === shotId);
                if (shotIndex !== -1) {
                  // 从所有包含该分镜的场景中移除
                  timeline.value.scenes.forEach(scene => {
                    const sceneShotIndex = scene.shots.indexOf(shotId);
                    if (sceneShotIndex !== -1) {
                      scene.shots.splice(sceneShotIndex, 1);
                    }
                  });
                  // 从时间轴中删除分镜
                  timeline.value.shots.splice(shotIndex, 1);
                  // 更新显示
                  updateTimelineDisplay();
                  renderFrame(34);
                }
                break;
              default:
                console.log('未知操作', actionId);
            }
          };
          
          // 为所有现有的表情元素添加右键菜单事件
          const addRightClickListeners = () => {
            document.querySelectorAll('.expression-item').forEach(item => {
              // 屏蔽浏览器右键菜单
              item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e, item);
              });
            });
          };
          
          // 为所有现有的分镜项添加右键菜单事件
          const addShotRightClickListeners = () => {
            document.querySelectorAll('.shot-item').forEach(item => {
              // 屏蔽浏览器右键菜单
              item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showShotContextMenu(e, item);
              });
            });
          };
          
          // 监听点击其他区域隐藏右键菜单
          document.addEventListener('click', (e) => {
            const menu = document.getElementById('expression-context-menu');
            if (menu && menu.style.display === 'block' && 
                !menu.contains(e.target) && 
                !e.target.classList.contains('expression-item')) {
              hideContextMenu();
            }
            
            // 隐藏分镜右键菜单
            const shotMenu = document.getElementById('shot-context-menu');
            if (shotMenu && shotMenu.style.display === 'block' && 
                !shotMenu.contains(e.target) && 
                !e.target.classList.contains('shot-item')) {
              hideShotContextMenu();
            }
          });
          
          // 额外添加定期检查的机制，确保新创建的分镜也能被监听
          setInterval(() => {
            const newShotItems = document.querySelectorAll('.shot-item:not([data-shot-right-click-bound])');
            if (newShotItems.length > 0) {
              newShotItems.forEach(item => {
                item.setAttribute('data-shot-right-click-bound', 'true');
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  showShotContextMenu(e, item);
                });
              });
            }
          }, 1000);
          
          // 监听drawExpressionTracks完成后的事件，为新创建的表情元素添加右键菜单
          // 创建一个包装器，不直接修改原函数
          const originalDrawExpressionTracks = drawExpressionTracks;
          const wrappedDrawExpressionTracks = function() {
            const result = originalDrawExpressionTracks.apply(this, arguments);
            // 延迟添加监听器，确保元素已完全渲染
            setTimeout(addRightClickListeners, 10);
            return result;
          };
          
          // 替换Vue实例中的方法引用
          if (typeof window !== 'undefined' && window.Vue && Vue._apps && Vue._apps[0]) {
            try {
              const app = Vue._apps[0];
              if (app._instance && app._instance.proxy) {
                // 在应用实例上注册我们的包装函数
                app._instance.proxy.wrappedDrawExpressionTracks = wrappedDrawExpressionTracks;
              }
            } catch (error) {
              console.warn('无法在Vue实例上注册包装函数:', error);
            }
          }
          
          // 额外添加定期检查的机制，确保新创建的元素也能被监听
          setInterval(() => {
            const newExpItems = document.querySelectorAll('.expression-item:not([data-right-click-bound])');
            if (newExpItems.length > 0) {
              newExpItems.forEach(item => {
                // 屏蔽浏览器右键菜单
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  showContextMenu(e, item);
                });
                // 标记为已绑定事件
                item.setAttribute('data-right-click-bound', 'true');
              });
            }
          }, 1000);
          
          // 初始添加监听器
          addRightClickListeners();
        };
        
        // 初始化表情右键菜单功能
        setupExpressionRightClickMenu();
        
        document.addEventListener('mousemove', (e) => {
          // 相机轨道拖拽处理
          if (isDraggingCameraEdge && draggedCameraTrack && draggedCameraShot) {
            const deltaX = e.clientX - lastCameraMouseX;
            lastCameraMouseX = e.clientX;
            
            // 计算时间变化 (像素差 -> 时间差)
            const timeDelta = (deltaX / MARGIN / zoom.value) * 1000;
            
            // 相机轨道最小持续时间（毫秒）
            const MIN_CAMERA_DURATION = 500;
            
            // 重叠检测函数 - 只检查同分值内的其他相机轨道
            const checkCameraOverlap = (newStartTime, newDuration) => {
              if (!draggedCameraShot.cameraTracks) return false;
              
              const newEndTime = newStartTime + newDuration;
              
              // 检查是否与其他相机轨道重叠
              for (const otherTrack of draggedCameraShot.cameraTracks) {
                // 跳过自身
                if (otherTrack.id === draggedCameraTrack.id) continue;
                
                const otherStart = otherTrack.startTime || 0;
                const otherEnd = otherStart + (otherTrack.duration || draggedCameraShot.duration);
                
                // 检查是否重叠
                if (!(newEndTime <= otherStart || newStartTime >= otherEnd)) {
                  return true;
                }
              }
              return false;
            };
            
            if (cameraDragEdgeType === 'left') {
              // 左边拖拽：修改开始时间，结束时间不变
              const currentDuration = draggedCameraTrack.duration || draggedCameraShot.duration;
              const newStartTime = Math.max(0, draggedCameraTrack.startTime + timeDelta);
              const newEndTime = newStartTime + currentDuration;
              
              // 确保不超过分镜结束时间
              const shotEndTime = draggedCameraShot.duration || 0;
              
              // 确保有最小持续时间
              if (currentDuration >= MIN_CAMERA_DURATION && newEndTime <= shotEndTime) {
                if (!checkCameraOverlap(newStartTime, currentDuration)) {
                  draggedCameraTrack.startTime = newStartTime;
                }
              }
            } else if (cameraDragEdgeType === 'right') {
              // 右边拖拽：修改持续时间，开始时间不变
              const currentStartTime = draggedCameraTrack.startTime || 0;
              const currentDuration = draggedCameraTrack.duration || draggedCameraShot.duration;
              const newDuration = Math.max(MIN_CAMERA_DURATION, currentDuration + timeDelta);
              const newEndTime = currentStartTime + newDuration;
              
              // 确保不超过分镜结束时间
              const shotEndTime = draggedCameraShot.duration || 0;
              
              if (newEndTime <= shotEndTime) {
                if (!checkCameraOverlap(currentStartTime, newDuration)) {
                  draggedCameraTrack.duration = newDuration;
                }
              }
            }
            
            updateTimelineDisplay();
            renderFrame(9);
          } else if (isDraggingExpEdge && draggedExpTrack) {
            
            const deltaX = e.clientX - lastMouseX;
            lastMouseX = e.clientX;
            
            // 计算时间变化 (像素差 -> 时间差)
            const timeDelta = (deltaX / MARGIN / zoom.value) * 1000;
            
            // 重叠检测函数 - 允许表情轨道相邻（新开始时间等于其他轨道结束时间或新结束时间等于其他轨道开始时间视为不重叠）
            const checkOverlap = (newStartTime, newEndTime) => {
              // 获取同角色的其他表情轨道
              const otherExpressions = timeline.value.expressionTracks.filter(
                track => track.roleId === draggedExpTrack.roleId && track.id !== draggedExpTrack.id
              );
              
              // 检查是否与任何其他表情轨道重c叠
              for (const exp of otherExpressions) {
                // 如果新的时间范围与其他表情轨道有重叠，则返回true
                // 允许轨道相邻：newEndTime <= exp.startTime 或 newStartTime >= exp.endTime 视为不重叠
                if (!(newEndTime <= exp.startTime || newStartTime >= exp.endTime)) {
                  console.log(`重叠:${exp}`)
                  return true;
                }
              }
              return false;
            };

            // 添加小的时间间隔（10毫秒）来解决浮点数精度问题
            const TIME_GAP = 10;


            const MIN_EXP_DURATION = 700; //表情最小持续时间

            // 找到表情轨道所在的场景
            let containingScene = timeline.value.scenes.find(scene => {
              const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
              if (sceneShots.length === 0) return false;
              const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
              const sceneStartTime = sortedShots[0].startTime;
              const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
              // 检查表情轨道是否在该场景时间范围内, 不能
              return draggedExpTrack.startTime >= sceneStartTime && draggedExpTrack.startTime < sceneEndTime-100 || 
                     draggedExpTrack.endTime >= sceneStartTime+100 && draggedExpTrack.endTime <= sceneEndTime;
            });

            if (containingScene) {

              if(draggingExpCurrentScene === null){
                draggingExpCurrentScene = containingScene;
              }else if(draggingExpCurrentScene.id !== containingScene.id){
                // console.log('表情轨道所在场景发生了变化')
                //表情轨道所在场景发生了变化，不允许变化，只能在同一场景中设置
                containingScene = draggingExpCurrentScene;
              }
              // 定义场景的开始时间和结束时间
              const sceneShots = timeline.value.shots.filter(shot => containingScene.shots.includes(shot.id));
              const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
              const sceneStartTime = sortedShots[0].startTime;
              const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
              
              if (dragEdgeType === 'left') {
                
                // 左边拖拽：修改开始时间，结束时间不变
                // 限制在场景开始时间和场景结束时间 - 最小持续时间之间
                // draggedExpTrack.startTime= Math.max(sceneStartTime, draggedExpTrack.startTime + timeDelta)
                let newStartTime = Math.max(sceneStartTime, 
                                              Math.min(sceneEndTime - MIN_EXP_DURATION, 
                                                       draggedExpTrack.startTime + timeDelta));
                
                //console.log(`左边拖拽：修改开始时间2- newStartTime=${newStartTime}, sceneStartTime=${sceneStartTime},sceneEndTime=${sceneEndTime}, MIN_EXP_DURATION=${MIN_EXP_DURATION}, draggedExpTrack.startTime=${draggedExpTrack.startTime}, timeDelta=${timeDelta}`)
                // 修复两个表情紧挨着时无法调整第二个表情开始时间的问题
                // 使用TIME_GAP来解决浮点数精度问题
                if (newStartTime < draggedExpTrack.endTime - MIN_EXP_DURATION + TIME_GAP) { // 确保有最小持续时间
                  // console.log('左边拖拽：修改开始时间3-'+newStartTime)
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(newStartTime, draggedExpTrack.endTime)) {
                    // console.log('左边拖拽：修改开始时间4 设置成功 -'+newStartTime)
                    draggedExpTrack.startTime = newStartTime;
                  }else{
                    // console.log('左边拖拽：修改开始时间5-'+newStartTime)
                  }
                }
              } else if (dragEdgeType === 'right') {
                // 右边拖拽：修改结束时间，开始时间不变
                // 限制在场景开始时间 + 最小持续时间和场景结束时间之间
                const newEndTime = Math.max(sceneStartTime + MIN_EXP_DURATION, 
                                            Math.min(sceneEndTime, 
                                                     draggedExpTrack.endTime + timeDelta));
                if (newEndTime > draggedExpTrack.startTime + MIN_EXP_DURATION) { // 确保有最小持续时间
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(draggedExpTrack.startTime, newEndTime)) {
                    draggedExpTrack.endTime = newEndTime;
                  }
                }
              }
            } else {
              // 如果没有找到所属场景，保持原有逻辑
              if (dragEdgeType === 'left') {
                // console.log('左边拖拽：修改开始时间')
                // 左边拖拽：修改开始时间，结束时间不变
                const newStartTime = Math.max(0, draggedExpTrack.startTime + timeDelta);
                // 修复两个表情紧挨着时无法调整第二个表情开始时间的问题
                // 使用TIME_GAP来解决浮点数精度问题
                if (newStartTime < draggedExpTrack.endTime - MIN_EXP_DURATION + TIME_GAP) { // 确保有最小持续时间
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(newStartTime, draggedExpTrack.endTime)) {
                    draggedExpTrack.startTime = newStartTime;
                  }
                }
              } else if (dragEdgeType === 'right') {
                // 右边拖拽：修改结束时间，开始时间不变
                const newEndTime = Math.min(totalDuration.value, draggedExpTrack.endTime + timeDelta);
                if (newEndTime > draggedExpTrack.startTime + MIN_EXP_DURATION) { // 确保有最小持续时间
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(draggedExpTrack.startTime, newEndTime)) {
                    draggedExpTrack.endTime = newEndTime;
                  }
                }
              }
            }
            
            updateTimelineDisplay();
            renderFrame(9);
          }
        });

        document.addEventListener('mouseup', () => {
          if (isDraggingCameraEdge && draggedCameraTrack) {
            isDraggingCameraEdge = false;
            // 恢复全局鼠标指针样式
            document.body.style.cursor = 'default';
            
            // 打印修改后的相机轨道数据
            console.log('相机轨道调整后的数据:', {
              shotId: draggedCameraShot.id,
              trackId: draggedCameraTrack.id,
              startTime: draggedCameraTrack.startTime,
              duration: draggedCameraTrack.duration
            });
            
            draggedCameraTrack = null;
            draggedCameraShot = null;
            cameraDragEdgeType = null;
          } else if (isDraggingExpEdge && draggedExpTrack) {
            isDraggingExpEdge = false;
            // 恢复全局鼠标指针样式
            document.body.style.cursor = 'default';
            
            // 打印修改后的表情对象JSON数据
            const expressionObject = {
              roleId: draggedExpTrack.roleId,
              startTime: draggedExpTrack.startTime,
              endTime: draggedExpTrack.endTime,
              expressionId: draggedExpTrack.expressionId,
              x: draggedExpTrack.x,
              y: draggedExpTrack.y
            };
            
            console.log('表情调整后的数据:', JSON.stringify(expressionObject, null, 2));
            
            draggingExpCurrentScene = null;
            draggedExpTrack = null;
            dragEdgeType = null;
          }
        });
        
        // 更新时间轴显示
        const updateTimelineDisplay = () => {
          drawTimeMarkers();
          drawShotTrack();
          drawSceneTrack();
          drawExpressionTracks();
          drawCameraTracks();
          drawAudioTracks();
          
          // 自动滚动到当前时间点，但添加边界检查避免滚动到不合理的位置
            const container = document.querySelector('.overflow-x-auto');
            if (container) { // 添加空值检查，避免访问null的clientWidth
              const scrollPosition = Math.max(0, Math.min(
                (currentTime.value / 1000) * zoom.value + 20 - markerPosition.value,
                timelineWidth.value - container.clientWidth
              ));
              container.scrollLeft = scrollPosition;
            } else {
              console.warn('updateTimelineDisplay: timeline container not found yet');
            }
        };
        
        let lastRenderShot = null;
        // 渲染当前帧 - 重新定义完整的renderFrame函数实现
        let renderFrame = (trace=-1) => {
          if(trace !== -1){
            console.log('renderFrame:', trace)
          }

          // 1. 前置检查
          if (!canvas.value || !ctx.value || !offscreenCanvas || !offscreenCtx) {
            debugInfo.value = `Canvas or context invalid: canvas=${!!canvas.value}, ctx=${!!ctx.value}`;
            return;
          }
          
          // 添加调试信息，显示当前渲染状态
          //debugInfo.value = `render frame: ${formatTime(currentTime.value)}, play=${isPlaying.value}, FPS=${fps}, canvas size=${canvas.value.width}x${canvas.value.height}`;
          
          // 2. 清空离屏画布
          offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
        
          // 3. 找到当前分镜
          let targetShot = null;
          const currentShot = timeline.value.shots.find(shot => 
            currentTime.value >= shot.startTime && 
            currentTime.value < shot.startTime + shot.duration
          );
          if (!currentShot) {
            targetShot = timeline.value.shots.length > 0 ? 
              timeline.value.shots.reduce((last, current) => 
                (current.startTime > last.startTime) ? current : last
              ) : null;
          }
          targetShot = currentShot || targetShot;
          // 检查是否分镜切换
          if (targetShot !== lastRenderShot) {
            lastRenderShot = targetShot;
            // 分镜切换时，重置异步渲染状态
            console.log('shot change:', targetShot.id);
          }

          // 4. 绘制底层背景
          // 设置基础背景色
          offscreenCtx.fillStyle = '#f0f0f0';
          offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
          
          // 如果有当前分镜，绘制分镜背景
          let isBackgroundDrawn = drawBackgroundLayer(targetShot);
          // 为异步加载场景提供备用渲染
          if (currentShot && !isBackgroundDrawn) {
            // 对于正在加载的图片，设置备用渲染
            setupAsyncRenderFallback(currentShot);
          }

          // 保存当前状态，准备应用坐标系变换
          offscreenCtx.save();
          
          // 应用坐标系变换：将原点从左上角移到左下角，并翻转Y轴
          // offscreenCtx.translate(0, offscreenCanvas.height);
          // offscreenCtx.scale(1, -1);
          
          // 5. 绘制角色层（中间层）
          if (expressionManager) {
            drawRoles();
          } else {
            console.log('expressionManager not initialized yet, skipping role drawing');
          }
          
          // 恢复原始坐标系状态
          offscreenCtx.restore();
          
          

          // 6. 绘制上层信息（FPS等）
          //drawTopLayerInfo(offscreenCtx);
          
          // 7. 清空可见画布，防止残影
          ctx.value.clearRect(0, 0, canvas.value.width, canvas.value.height);
          
          // 8. 将离屏Canvas内容复制到可见Canvas（顶层合成）
          ctx.value.drawImage(offscreenCanvas, 0, 0);
          
          // 9. 播放当前分镜的音频
          if (audioManager /*&& isPlaying.value */) {//不播放时也要处理台词
            // 获取当前分镜中应该在当前时间播放的音频
            if (currentShot && currentShot.audios && Array.isArray(currentShot.audios)) {
              const currentTimeInShot = currentTime.value - currentShot.startTime;
              
              currentShot.audios.forEach(audio => {
                // 检查音频是否应该在当前时间播放
                if (audio.startTime <= currentTimeInShot && 
                    (audio.startTime + (audio.audioDuration || 0)) > currentTimeInShot) {

                  // 管理字幕显示
                  cameraModule.manageSubtitleDisplay(audio, currentShot.startTime);

                  if(isPlaying.value && !audioManager.isPlayIng(audio.audio, audio.roleId) ){
                    // 计算音频应该开始播放的时间点（秒）
                    const audioStartTimeInShot = currentTimeInShot - audio.startTime;
                    //console.log('start play audio', audio.audio, audio.roleId, '从', audioStartTimeInShot, '秒开始');
                    audioManager.playAudio(audio.audio, audio.roleId, audioStartTimeInShot/1000);
                  } 

                }else {
                  if(isPlaying.value && audioManager.isPlayIng(audio.audio, audio.roleId)){
                    // 音频不在播放时间范围内，停止播放
                    //console.log('stop play audio', audio.audio, audio.roleId);
                    audioManager.stopAudio(audio.audio, audio.roleId);
                  }
                }
              });
            }
            
            // 如果没有当前分镜，停止所有音频
            if (!currentShot) {
              audioManager.stopAllAudios(currentTime.value);
            }
          }

          // 在播放时根据当前时间动态更新摄像机设置,一定要在绘制角色层之后！！！！！！！
          //否则，在绘制角色层之前，摄像机设置可能获取焦点时，角色状态还未初始化，将获取错误的宽高，导致计算错误的焦点

          // 10. 绘制摄像机边框（如果启用）
          if (cameraModule) {

            // if (cameraModule.updateCameraOnPlayback) {
              cameraModule.updateCameraOnPlayback(currentTime.value, timeline.value);
            // }
            cameraModule.drawCamera();

            // 11. 绘制摄像机预览（如果启用）- 改为异步执行以提高性能
            if (showCameraPreview.value) {
              // 使用requestAnimationFrame异步执行预览更新，不阻塞主渲染流程
              requestAnimationFrame(() => {
                cameraModule.updateCameraPreview(currentTime.value); // 更新预览
              });
            }
          }

          


          drawTopLayerInfo(ctx.value);
        };
        
        // 绘制背景层
        const drawBackgroundLayer = (shot) => {
          const cachedImage = getCacheImage != null && getCacheImage(shot.background);
          if (cachedImage) {
            // 图片已预加载完成，按原始宽高比绘制，避免变形
            // 清空背景
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            
            // 计算缩放比例和位置，保持图片原始宽高比
            const imgRatio = cachedImage.width / cachedImage.height;
            const canvasRatio = offscreenCanvas.width / offscreenCanvas.height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (imgRatio > canvasRatio) {
              // 图片更宽，按宽度缩放
              drawWidth = offscreenCanvas.width;
              drawHeight = offscreenCanvas.width / imgRatio;
              drawX = 0;
              drawY = (offscreenCanvas.height - drawHeight) / 2;
            } else {
              // 图片更高，按高度缩放
              drawHeight = offscreenCanvas.height;
              drawWidth = offscreenCanvas.height * imgRatio;
              drawY = 0;
              drawX = (offscreenCanvas.width - drawWidth) / 2;
            }
            
            // 绘制图片（不填充，保持原始比例）
            offscreenCtx.drawImage(cachedImage, drawX, drawY, drawWidth, drawHeight);
            return true;
          } 
          // else if (cachedImage === null) {
          //   // 图片已标记为加载失败，绘制备用背景
          //   drawErrorBackground();
          //   return true;
          // } else {
          //   // 图片未加载完成，需要异步处理
          //   return false;
          // }
        };
        
        // 绘制错误背景
        const drawErrorBackground = () => {
          const gradient = offscreenCtx.createLinearGradient(0, 0, offscreenCanvas.width, offscreenCanvas.height);
          gradient.addColorStop(0, '#4a5568');
          gradient.addColorStop(1, '#2d3748');
          offscreenCtx.fillStyle = gradient;
          offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
          offscreenCtx.fillStyle = '#cbd5e0';
          offscreenCtx.font = '16px Arial';
          offscreenCtx.textAlign = 'center';
          offscreenCtx.fillText('背景图加载失败', offscreenCanvas.width/2, offscreenCanvas.height/2);
        };
        
        // 绘制顶层信息
        const drawTopLayerInfo = (ctx) => {
          // 在左上角显示FPS信息
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(10, 10, 60, 25);
          ctx.fillStyle = '#ffffff';
          ctx.font = '14px Arial';
          ctx.textAlign = 'left';
          ctx.fillText(`FPS: ${fps}`, 15, 28);
        };
        
        // 设置异步渲染备用方案
        const setupAsyncRenderFallback = (shot) => {
          // 确保loadImageWithCORS可用
          if (loadImageWithCORS) {
            // 异步临时加载背景
            // 使用安全版本的loadImageWithCORS
            const safeLoad = safeLoadImageWithCORS();
            
            safeLoad(
              shot.background,
              (bgImg) => {
                console.log('✅ async load bg-success: ' + shot.background);
                // 直接调用renderFrame函数进行完整重绘
                renderFrame(10);
              },
              (error) => {
                console.error('❌ async load bg-error: ' + shot.background + ' | 错误:', error);
                debugInfo.value = 'load bg error: ' + shot.background;
                //bgImagesCache.value[shot.background] = null; // 标记为加载失败
                // 直接调用renderFrame函数进行完整重绘
                renderFrame(11);
              }
            );
          }
          
          // 立即渲染角色的备用图形，避免图片加载时的空白期
          // 注意：不直接使用renderFrame，因为它会调用setupAsyncRenderFallback导致循环调用
          // drawImmediateFallback是专门设计的轻量级快速渲染函数
          const drawImmediateFallback = () => {
            // 更全面的前置检查，与renderFrame保持一致
            if (!canvas.value || !ctx.value || !offscreenCanvas || !offscreenCtx) {
              console.warn('Canvas not init，skip');
              return;
            }
            
            try {
              // 清空画布并重新绘制当前状态
              offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
              
              // 重绘基础背景
              offscreenCtx.fillStyle = '#f0f0f0';
              offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
              
              // 重绘中间层
              if (expressionManager) {
                drawRoles();
              } else {
                console.log('expressionManager not initialized yet, skipping role drawing in fallback');
              }
              
              // 重绘顶层
              drawTopLayerInfo(offscreenCtx);
              
              // 合成并显示
              ctx.value.drawImage(offscreenCanvas, 0, 0);
            } catch (error) {
              console.error('render backup image error:', error);
            }
          };
          
          // 立即执行一次，确保用户看到内容
          drawImmediateFallback();
          
        };
        

        
        // 绘制角色
        const drawRoles = () => {
          if (!offscreenCtx) {
            // debugInfo.value = 'offscreenCtx null ';
            return;
          }
          
          // 确保总是绘制一些内容，即使没有角色
          if (timeline.value.roles.length === 0) {
            offscreenCtx.fillStyle = '#4a5568';
            offscreenCtx.font = '16px Arial';
            offscreenCtx.textAlign = 'center';
            offscreenCtx.fillText('无角色数据', offscreenCanvas.width/2, offscreenCanvas.height/2 + 30);
            return;
          }
          // console.log('drawRoles start!!!!');
          // 初始化角色表情管理器
          if (expressionManager && Object.keys(expressionManager.expressionCache).length === 0) {
            expressionManager.init(timeline.value.scenes, timeline.value.shots, timeline.value.roles, timeline.value.expressionTracks,timeline.value.expressions,timeline.value.avatars);
          }
          
          // 1. 先用当前时间，寻找对应的场景，获取场景中的角色
          const sceneRoles = getSceneRolesByTime(currentTime.value);
          
          // 2. 获取表情轨道中当前时间包含的角色
          const expressionTracksAtCurrentTime = timeline.value.expressionTracks.filter(track => 
            currentTime.value >= track.startTime && currentTime.value < track.endTime
          );
          
          // 3. 创建一个包含所有需要绘制的角色ID的集合（避免重复）
          const roleIdsToDraw = new Set();
          
          // 添加场景中的角色ID
          sceneRoles.forEach(sceneRole => {
            if(sceneRole.visible) {
              roleIdsToDraw.add(sceneRole.roleId);
            }
          });
          
          // 添加表情轨道中的角色ID
          expressionTracksAtCurrentTime.forEach(track => {
            roleIdsToDraw.add(track.roleId);
          });
          
          // 4. 按角色依次绘制 -- 暂未考虑Z轴排序问题，后续补上
          roleIdsToDraw.forEach(roleId => {

            // 找到对应的角色对象
            const role = timeline.value.roles.find(r => r.id === roleId);
            if (!role) return;

            // 5. 绘制时，先寻找表情轨道中当前时间该角色是否包含表情dr
            let currentExpressionTrack = getExpressionTrackByRoleId(roleId,currentTime.value,false)
            
            // 如果没有找到表情轨道，则使用场景中该角色的缺省表情及位置、宽高角度等信息进行绘制
            if(!currentExpressionTrack) {
              //console.log('draw currentExpressionTrack:',roleId,currentExpressionTrack);
              return;
            }

            // 确保当前表情轨道的roleId与角色ID一致
            if (currentExpressionTrack.roleId !== roleId) {
              console.warn(`表情轨道的角色ID不匹配: ${currentExpressionTrack.roleId} vs ${roleId}`);
              return;
            }
            
            // 获取当前表情对象，从allExpressions中获取
            const expression = allExpressions[currentExpressionTrack.expressionId];
            if (!expression) {
              console.warn(`未找到expressionId为${currentExpressionTrack.expressionId}的表情对象`);
              return;
            }
            
            
            // 使用expressionManager的drawRoleExpression方法进行绘制
            try {
              expressionManager.drawRoleExpression(offscreenCtx, role, currentExpressionTrack, currentTime.value, !isPlaying.value ? selectedRoleId.value : null);
            } catch (error) {
              console.error('绘制角色表情时出错:', error);
            }
            return;

          });
        
          // console.log('drawRoles  finish!!!!');

        };
        
        // 动画循环
        const animate = (timestamp) => {
          if (!isPlaying.value) return;
          
          // 计算时间增量
          if (!lastTime) lastTime = timestamp;
          const deltaTime = timestamp - lastTime;
          
          // 根据目标FPS控制帧更新
          const targetFrameInterval = 1000 / targetFps.value;
          
          // 只有当经过的时间大于目标帧间隔时才更新时间和渲染
          if (deltaTime >= targetFrameInterval) {
            lastTime = timestamp;
            
            // 更新当前时间
            currentTime.value += deltaTime;
            
            // 计算FPS
            frameCount++;
            if (!lastFpsUpdate) lastFpsUpdate = timestamp;
            if (timestamp - lastFpsUpdate >= 1000) { // 每秒更新一次FPS
              fps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdate));
              frameCount = 0;
              lastFpsUpdate = timestamp;
            }
            // 检查是否结束
            if (currentTime.value >= totalDuration.value) {
              if (loop.value) {
                currentTime.value = 0;
              } else {
                stopPlayback();
                currentTime.value = totalDuration.value;
                
                // 如果正在录制，自动停止录制
                if (isRecording.value) {
                  stopRecording();
                }
              }
            }
            
            renderFrame();

            // // 更新显示 - 改为异步执行以提高性能
            // requestAnimationFrame(() => {
            //   updateTimelineDisplay();
            // });
            
          }
          
          // 继续动画
          animationFrameId.value = requestAnimationFrame(animate);
        };
        
        // 播放/暂停切换
        const playPause = () => {
          if (isPlaying.value) {
            stopPlayback();
          } else {
            startPlayback();
          }
        };
        
        // 开始播放
        const startPlayback = () => {
          isPlaying.value = true;
          lastTime = null;
          // 重置角色表情管理器，确保从当前时间点开始正确播放表情
          expressionManager.reset();
          // 重置音频管理器，清除之前的播放状态
          if (audioManager) {
            audioManager.stopAllAudios(currentTime.value);
          }
          // 立即渲染一帧
          renderFrame(13);
          animationFrameId.value = requestAnimationFrame(animate);
        };
        
        // 停止播放
        const stopPlayback = () => {
          isPlaying.value = false;
          if (animationFrameId.value) {
            cancelAnimationFrame(animationFrameId.value);
          }
          // 停止所有正在播放的音频
          if (audioManager) {
            audioManager.stopAllAudios(currentTime.value);
          }
          // 暂停时重新渲染，确保显示正确的画面
          //renderFrame(14);
        };
        
        // 跳转到开始
        const goToStart = () => {
          currentTime.value = 0;
          // 重置角色表情管理器，确保从开始位置重新播放表情
          expressionManager.reset();
          updateTimelineDisplay();
          renderFrame(15);
        };
        
        // 跳转到结束
        const goToEnd = () => {
          currentTime.value = totalDuration.value;
          updateTimelineDisplay();
          renderFrame(16);
        };
        
        // 切换循环模式
        const toggleLoop = () => {
          loop.value = !loop.value;
          // console.log('rednder')
          renderFrame(17);
        };
        
        // 缩放控制
        const timelineZoomIn = () => {
          zoom.value = Math.min(zoom.value * 1.2, 5);
          updateTimelineDisplay();
        };
        
        const timelineZoomOut = () => {
          zoom.value = Math.max(zoom.value / 1.2, 0.1);
          updateTimelineDisplay();
        };
        
        const timelineResetZoom = () => {
          zoom.value = 1;
          updateTimelineDisplay();
        };
        
        // 选中角色
        const selectRole = (roleId) => {
          console.log('设置选中角色：', roleId);
          selectedRoleId.value = roleId;
          selectedShotId.value = null; // 选中角色时取消分镜选中
          
          // 当选择角色时，默认选择其第一个表情
          if (selectedRoleId.value) {
            //const role = timeline.value.roles.find(r => r.id === selectedRoleId.value);
            // 确保角色有表情缓存 ?? 这里处理的到底是表情还是动作
            if (expressionManager.expressionCache.length > 0) {
              selectedExpressionId.value = expressionManager.expressionCache[0].id;
            }
          } else {
            selectedExpressionId.value = null;
          }

          // 刷新表情轨道显示
          drawExpressionTracks();
          renderFrame(19);
        };
        
        // 处理Canvas点击
        const handleCanvasClick = (event) => {
          if (isPlaying.value) return;
          if (enableCameraEdit.value) return;

          // 获取Canvas元素
          const canvasElement = canvas.value;
          const rect = canvasElement.getBoundingClientRect();
          
          // 计算点击位置在Canvas中的坐标（考虑缩放）
          const scaleX = canvasElement.width / rect.width;
          const scaleY = canvasElement.height / rect.height;
          
          const x = (event.clientX - rect.left) * scaleX;
          const y = (event.clientY - rect.top) * scaleY;
          
          // 检测角色点击
          checkRoleClick(x, y);
        };
        
        // 检测角色点击
        const checkRoleClick = (x, y) => {
          const canvasElement = document.getElementById('animationCanvas');
          const canvasHeight = canvasElement.height;
          
          // 在新坐标系下，需要将点击Y坐标转换为内部使用的Y坐标
          // 数学坐标系：原点在左下角，Y轴向上:canvasHeight - y;
          // const flippedY = canvasHeight - y;//
          
          // 使用角色表情管理器检测点击的角色
          const clickedRole = expressionManager.checkRoleClick(x, y, timeline.value.roles, timeline.value.expressionTracks, currentTime.value);
          //console.log('checkRoleClick :', clickedRole);
          if (clickedRole) {
            selectRole(clickedRole.id);
            // 关闭表情面板，下次点击表情按钮再打开
            showExpressionPanel.value = false;
          } else {
            // 点击空白处取消选择
            selectRole(null);
            showExpressionPanel.value = false;
          }
        };
        
        // 切换表情面板显示
        const toggleExpressionPanel = () => {
          showExpressionPanel.value = !showExpressionPanel.value;
        };
        
        // 处理表情点击事件的安全包装器
        const handleExpressionClick = (expression) => {
          console.log('handleExpressionClick调用 - 原始传入:', expression);
          
          try {
            // 检查传入参数是否存在
            if (!expression) {
              console.error('错误: 传入的表情为undefined或null');
              return;
            }
            
            // 确保传入的是一个对象
            if (typeof expression !== 'object') {
              console.error('错误: 传入的不是对象类型:', expression);
              return;
            }
            
            // 安全地调用selectExpression函数
            selectExpression(expression);
          } catch (error) {
            console.error('handleExpressionClick执行出错:', error);
            console.error('错误栈:', error.stack);
          }
        };
        
        // 选择表情
        const selectExpression = (expression) => {
          // 增强的调试信息
          console.log('selectExpression调用 - 传入的表达式:', expression);
          
          // 更严格的类型和属性检查
          if (!expression) {
            console.error('错误: 传入的表情为undefined或null');
            return;
          }
          
          if (typeof expression !== 'object') {
            console.error('错误: 传入的不是对象类型:', expression);
            return;
          }
          
          if (!('id' in expression) || expression.id === undefined || expression.id === null) {
            console.error('错误: 表情对象没有有效的id属性:', expression);
            return;
          }
          
          // 确保表达式id是字符串类型
          const expressionId = String(expression.id);
          selectedExpressionId.value = expressionId;
          console.log('表情选择成功:', expressionId, '表情名称:', getExpressionName(expressionId));
        };
        
        // 添加表情
        const addExpression = () => {
          if (!selectedRoleId.value || !selectedExpressionId.value) return;
          
          // 检查当前时间点是否已有该角色的表情轨道
          const hasExistingTrack = getExpressionTrackByRoleId(selectedRoleId.value,currentTime.value) != null;
          
          if (!hasExistingTrack) {
            // 创建新的表情轨道，时长2秒
            const newTrack = {
              id: 'track_' + Date.now(),
              roleId: selectedRoleId.value,
              expressionId: selectedExpressionId.value,
              x: 100, // 默认x坐标
              y: 300, // 默认y坐标
              x1: 100, // 默认结束x坐标
              y1: 300, // 默认结束y坐标
              startTime: currentTime.value,
              endTime: currentTime.value + 2000 // 2秒时长
            };
            
            // 这里需要获取上一分镜该角色的表情位置
            // 获取角色当前时间点的位置信息（与checkRoleClick函数使用相同的逻辑）
            // const currentTrack = 
            // if (currentTrack) {
            //   newTrack.x = currentTrack.x;
            //   newTrack.y = currentTrack.y;
            // }
            
            timeline.value.expressionTracks.push(newTrack);
            renderFrame(20);
          }else{
            showAlert('当前时间点已存在该角色的表情，无法重复添加');
          }
        };
        
        // 替换表情
        const replaceExpression = () => {
          if (!selectedRoleId.value || !selectedExpressionId.value) return;
          
          // 查找当前时间点该角色的表情轨道
          const currentTrackIndex = timeline.value.expressionTracks.findIndex(track => 
            track.roleId === selectedRoleId.value && 
            track.startTime <= currentTime.value && 
            track.endTime > currentTime.value
          );
          
          if (currentTrackIndex !== -1) {
            // 替换现有轨道的表情
            timeline.value.expressionTracks[currentTrackIndex].expressionId = selectedExpressionId.value;
            renderFrame(21);
          } else {
            // 如果没有现有轨道，则添加新轨道
            addExpression();
          }
        };
        
        // 删除表情
        const deleteExpression = () => {
          if (!selectedRoleId.value) return;
          
          // 查找当前时间点该角色的表情轨道
          const currentTrackIndex = timeline.value.expressionTracks.findIndex(track => 
            track.roleId === selectedRoleId.value && 
            track.startTime <= currentTime.value && 
            track.endTime > currentTime.value
          );
          
          if (currentTrackIndex !== -1) {
            // 删除当前轨道
            timeline.value.expressionTracks.splice(currentTrackIndex, 1);
            renderFrame(22);
          }
        };
        
        // 保存项目
        const saveProject = () => {
          const dataStr = JSON.stringify(timeline.value, null, 2);
          const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
          
          const exportFileDefaultName = 'animation-project.json';
          
          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', exportFileDefaultName);
          linkElement.click();
        };
        
        // 保存景别到当前镜头轨道
        const saveCameraScenery = (startTimeOffset = null) => {
          console.log('saveCameraScenery - 调用',startTimeOffset,startTimeOffset === null);
          // 获取当前时间
          const currentTimeValue = currentTime.value;
          
          // 调试日志：记录当前时间值
          console.log('saveCameraScenery - 当前时间值:', currentTimeValue);
          
          // 查找当前时间点所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            currentTimeValue >= shot.startTime && currentTimeValue < shot.startTime + shot.duration
          );
          
          if (!currentShot) {
            showAlert('未找到当前分镜，请确保时间线指针位于有效分镜内');
            return;
          }
          
          // 调试日志：记录当前分镜信息
          console.log('saveCameraScenery - 当前分镜:', {
            id: currentShot.id,
            startTime: currentShot.startTime,
            duration: currentShot.duration
          });
          
          // 如果分镜没有cameraTracks数组，创建一个
          if (!currentShot.cameraTracks) {
            currentShot.cameraTracks = [];
          }
          
          // 获取当前选择的镜头预设
          let cameraType = selectedCameraPreset.value || CUSTOM_CAMERA_TYPE;
          
          // 确定startTime
          const finalStartTime = startTimeOffset !== null ? startTimeOffset : (currentTimeValue - currentShot.startTime);
          
          // 调试日志：记录计算结果
          console.log('saveCameraScenery - 计算结果:', {
            startTimeOffset: startTimeOffset,
            finalStartTime: finalStartTime
          });
          
          //创建新的镜头轨道
          const newCameraTrack = {
            id: 'camera_' + Date.now(), // 生成唯一ID
            startTime: finalStartTime, // 相对于分镜的开始时间
            cameraType: cameraType,
            duration: 1000, // 默认时长1秒（1000毫秒）
            x: cameraModule.cameraX,
            y: cameraModule.cameraY,
            width: cameraModule.cameraWidth,
            height: cameraModule.cameraHeight,
          };
          
          // 添加到分镜的cameraTracks数组
          currentShot.cameraTracks.push(newCameraTrack);
          console.log('saveCameraScenery - 新建镜头轨道:', newCameraTrack);
          // 重新渲染帧
          renderFrame(36);
          
          // 显示成功提示
          showAlert(startTimeOffset === null ? '景别已保存到当前时间点' : 
                   startTimeOffset === 0 ? '景别已保存到分镜开始时间' : '景别已保存到对话开始时间');
        };
        
        // 保存景别到当前分镜开始
        const saveCameraSceneryToShotStart = () => {
          saveCameraScenery(0); // 0表示相对于分镜的开始时间
        };
        
        // 保存景别到当前对话开始
        const saveCameraSceneryToDialogStart = () => {
          // 获取当前时间
          const currentTimeValue = currentTime.value;
          
          // 查找当前时间点所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            currentTimeValue >= shot.startTime && currentTimeValue < shot.startTime + shot.duration
          );
          
          if (!currentShot) {
            showAlert('未找到当前分镜，请确保时间线指针位于有效分镜内');
            return;
          }
          
          // 在当前分镜的音频轨道中查找当前时间点正在播放的音频
          let dialogStartTime = null;
          if (currentShot.audios && Array.isArray(currentShot.audios)) {
            const currentAudio = currentShot.audios.find(audio => {
              const audioStartTime = currentShot.startTime + (audio.startTime || 0);
              const audioEndTime = audioStartTime + (audio.audioDuration || 0);
              return currentTimeValue >= audioStartTime && currentTimeValue <= audioEndTime;
            });
            
            if (currentAudio) {
              dialogStartTime = currentAudio.startTime || 0; // 对话的开始时间（相对于分镜）
            }
          }
          
          if (dialogStartTime === null) {
            showAlert('未找到当前对话，请确保时间线指针位于有效对话内');
            return;
          }
          
          // 调用保存函数，传入对话开始时间
          saveCameraScenery(dialogStartTime);
        };
        
        // 录制相关状态变量
        const isRecording = ref(false);
        const mediaRecorder = ref(null);
        const videoChunks = ref([]);
        const recordingStartTime = ref(0);
        const videoFps = ref(targetFps);
        
        // 音频相关变量
        let audioContext = null;
        let mainGainNode = null;
        let audioSources = [];
        
        // 初始化音频上下文
        function initAudioContext() {
          // 创建音频上下文
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // 创建主音量控制节点
          mainGainNode = audioContext.createGain();
          mainGainNode.gain.value = 0.8; // 默认音量
          mainGainNode.connect(audioContext.destination);
          
          // 为每个音频元素创建源节点
          audioSources = [];
          // 实际应用中需要获取所有音频元素
          // 这里先预留接口
        }
        
        // 开始录制
        const startRecording = async () => {
          // 检查浏览器支持
          if (!navigator.mediaDevices || !MediaRecorder) {
            alert('您的浏览器不支持视频录制功能，请使用Chrome或Firefox最新版本');
            return;
          }
          
          // 初始化音频上下文
          if (!audioContext) {
            initAudioContext();
          }
          
          // 准备录制
          isRecording.value = true;
          videoChunks.value = [];
          
          // 将音频上下文和增益节点传递给AudioManager，使其能够在播放音频时连接到录制系统
          if (audioManager) {
            audioManager.setRecordingContext(audioContext, mainGainNode);
            console.log('已设置AudioManager的录制上下文');
          }
          
          // 获取Canvas视频流
          const videoStream = canvas.value.captureStream(videoFps.value);
          
          // 创建合并流
          const combinedStream = new MediaStream();
          
          // 添加视频轨道
          videoStream.getVideoTracks().forEach(track => {
            combinedStream.addTrack(track);
          });
          
          // 创建录制专用的音频输出节点
          const audioDestination = audioContext.createMediaStreamDestination();
          // 关键：将主音量节点连接到录制目的地
          mainGainNode.connect(audioDestination);
          
          // 添加音频轨道
          audioDestination.stream.getAudioTracks().forEach(track => {
            console.log('添加音频轨道:', track);
            combinedStream.addTrack(track);
          });

          // 检查支持的MIME类型
          const possibleMimeTypes = ['video/mp4; codecs=avc1', 'video/mp4', 'video/webm; codecs=vp9', 'video/webm'];
          let supportedMimeType = null;
          
          for (const mimeType of possibleMimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
              supportedMimeType = mimeType;
              break;
            }
          }
          
          if (!supportedMimeType) {
            alert('您的浏览器不支持任何视频录制格式');
            isRecording.value = false;
            return;
          }
          
          // 配置MediaRecorder
          const options = {
            mimeType: supportedMimeType,
            videoBitsPerSecond: 5000000, // 5Mbps
            audioBitsPerSecond: 128000,  // 128kbps
            framerate: videoFps.value
          };
          
          try {
            mediaRecorder.value = new MediaRecorder(combinedStream, options);
            
            // 监听数据可用事件
            mediaRecorder.value.ondataavailable = (e) => {
              if (e.data.size > 0) {
                videoChunks.value.push(e.data);
              }
            };
            
            // 监听录制停止事件
            mediaRecorder.value.onstop = () => {
              // 录制结束后创建视频文件
              const blob = new Blob(videoChunks.value, { type: supportedMimeType });
              const url = URL.createObjectURL(blob);
              
              // 创建下载链接
              const a = document.createElement('a');
              a.style.display = 'none';
              a.href = url;
              a.download = `animation_${Date.now()}${supportedMimeType.includes('mp4') ? '.mp4' : '.webm'}`;
              document.body.appendChild(a);
              a.click();
              
              // 清理
              setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                videoChunks.value = [];
              }, 100);
            };
            
            // 开始录制
            mediaRecorder.value.start(100); // 每100ms收集一次数据
            recordingStartTime.value = Date.now();
            
            // 开始渲染动画帧
            goToStart();
            startPlayback();
          } catch (error) {
            console.error('录制失败:', error);
            alert('录制失败: ' + error.message);
            isRecording.value = false;
          }
        };
        
        // 停止录制
        const stopRecording = () => {
          if (mediaRecorder.value && isRecording.value) {
            mediaRecorder.value.stop();
            isRecording.value = false;
            stopPlayback();
            console.log('录制已停止');
            
              
            // 清除AudioManager的录制上下文
            if (audioManager) {
              audioManager.clearRecordingContext();
              console.log('已清除AudioManager的录制上下文');
            }
            
            // 清理音频上下文
            if (audioContext) {
              audioContext.close().then(() => {
                console.log('音频上下文已关闭');
                audioContext = null;
                audioSources = [];
                mainGainNode = null;
              }).catch(error => {
                console.error('关闭音频上下文时出错:', error);
              });
            }
          }
        };
        
        // 导出动画
        const exportAnimation = () => {
          if (!isRecording.value) {
            startRecording();
          } else {
            stopRecording();
          }
        };
        
        // 预加载所有背景图
        const preloadBackgroundImages = () => {
          // 获取所有需要预加载的背景图URL
          const backgroundUrls = timeline.value.shots.map(shot => shot.background);
          const uniqueUrls = [...new Set(backgroundUrls)]; // 去重
          
          // console.log('开始预加载背景图:', uniqueUrls);
          //debugInfo.value = `开始预加载背景图: ${uniqueUrls.length}张`;
          //console.info('开始预加载背景图:', uniqueUrls.length, '张');
          // 预加载每张图片
          uniqueUrls.forEach(url => {
            if (getCacheImage && loadImageWithCORS && !getCacheImage(url)) {
              loadImageWithCORS(
                url,
                (img) => {
                  console.log('load succ bgimg');
                  //预加载成功后，刷新下，否则背景是未渲染状态
                  renderFrame(23);
                },
                () => {
                  console.error('load err bgimg:', url);
                }
              );
            }
          });
        };
        
        const getExpressionTrackByRoleId = (roleId, time, onlyTrack = true) => {
          return expressionManager.getExpressionTrackByRoleId(roleId, time, onlyTrack);
        }

        const calculateCurrentExpressPosition = (currentExpressionTrack, time) => {
          return expressionManager.calculateCurrentExpressPosition(currentExpressionTrack, time);
        }
        // // 获取当前时间点指定角色ID的表情轨道
        // const getExpressionTrackByRoleId = (roleId, time, onlyTrack = true) => {
        //   if (!timeline.value.expressionTracks || !Array.isArray(timeline.value.expressionTracks)) {
        //     return null;
        //   }
          
        //   // 查找当前时间点该角色的表情轨道
        //   let currentExpressionTrack = timeline.value.expressionTracks.find(track => 
        //     track.roleId === roleId && 
        //     time >= track.startTime && 
        //     time < track.endTime
        //   );

        //   if(onlyTrack)
        //     return currentExpressionTrack;

        //   //console.log('getExpresTrackByRoleId', roleId, time, currentExpressionTrack);
        //   // 如果没有找到，检查是否在最后一帧
        //   if (!currentExpressionTrack && time >= totalDuration.value) {
        //     // 找到最后一个结束的轨道
        //     const lastTracks = timeline.value.expressionTracks  
        //       .filter(track => track.roleId === roleId && track.endTime <= time && track.endTime > time-1)
        //       .sort((a, b) => b.endTime - a.endTime);
            
        //     currentExpressionTrack = lastTracks.length > 0 ? lastTracks[0] : null;
        //   }


        //   // 如果没有找到表情轨道，尝试从当前场景中获取角色配置
        //   if (!currentExpressionTrack) {
        //     // 获取当前时间点的场景角色配置
        //     const sceneRoles = getSceneRolesByTime(time);
        //     const sceneRoleConfig = sceneRoles ? sceneRoles.find(r => r.roleId === roleId) : null;
            
        //     // 如果场景中找到了角色配置，创建一个临时的表达式轨道用于位置计算
        //     if (sceneRoleConfig) {
        //       currentExpressionTrack = {
        //         roleId: roleId,
        //         expressionId: sceneRoleConfig.expressionId,
        //         x: sceneRoleConfig.x,
        //         y: sceneRoleConfig.y,
        //         x1: sceneRoleConfig.x1 || sceneRoleConfig.x,
        //         y1: sceneRoleConfig.y1 || sceneRoleConfig.y,
        //         startTime: time,
        //         endTime: time + 1,
        //         scale: sceneRoleConfig.scale?.toFixed(2) || 1,
        //         _isTemp: true
        //       };
        //       //console.log('使用默认表情:',currentExpressionTrack);
        //     }
        //   }
          
        //   return currentExpressionTrack;
        // }

        // 初始化
        onMounted(() => {
          console.log('ondMounted initCanvas');
          // 初始化画布
          initCanvas();
          
          // 预加载所有背景图
          // preloadBackgroundImages();
          
          // 打印初始化结果，用于调试
          //console.log('初始化后的角色表情容器:', expressionContainers.value);
          
          // 初始渲染
          updateTimelineDisplay();
          // renderFrame(24);//无用
          
          // 角色拖拽相关状态
          let isDraggingRole = false; // 角色拖拽状态
          let isDraggingResizeDot = false; // 右上角宽高调整点拖拽状态
          let isDraggingAngleDot = false; // 右下角角度调整点拖拽状态
          let draggedRoleId = null; // 被拖拽的角色ID
          let dragOffsetX = 0; // 拖拽偏移量X
          let dragOffsetY = 0; // 拖拽偏移量Y
          let initialWidth = 0; // 初始宽度
          let initialHeight = 0; // 初始高度
          let initialAngle = 0; // 初始角度
          let initialMouseX = 0; // 初始鼠标X坐标
          let initialMouseY = 0; // 初始鼠标Y坐标
          let cornerDotSize = 12; // 调整圆点大小
          let canvasCurrentScene = null;
          let canvasCurrentRole = null;

          
          // 获取Canvas元素
          const canvasElement = document.getElementById('animationCanvas');
          

          function getCanvasPosition(e) {
            const rect = canvasElement.getBoundingClientRect();
            const scaleX = canvasElement.width / rect.width;
            const scaleY = canvasElement.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            return {rect, scaleX, scaleY, mouseX, mouseY};
          }

          // 添加角色拖拽事件监听
          canvasElement.addEventListener('mousedown', (e) => {
            if (isPlaying.value) return;
            if (enableCameraEdit.value) return;
            
            // const rect = canvasElement.getBoundingClientRect();
            // const scaleX = canvasElement.width / rect.width;
            // const scaleY = canvasElement.height / rect.height;
            // const x = (e.clientX - rect.left) * scaleX;
            // const y = (e.clientY - rect.top) * scaleY;
            const {rect, scaleX, scaleY, mouseX, mouseY} = getCanvasPosition(e);
            // 关键点：使用与渲染时完全相同的Canvas高度（offscreenCanvas）进行坐标系转换
            const canvasHeight = offscreenCanvas.height;
            const x = mouseX;
            const y = mouseY;


            console.log(`点击位置:, ${x}, ${y}`);
            
            // 检查是否点击了选中的角色
            if (selectedRoleId.value) {
              let currentExpTrack = expressionManager.canvasCurrentExpTrack;
              // console.log('mouse down 当前选择表情:',currentExpTrack)
              
              if (currentExpTrack) {

                const currentPressPosition = expressionManager.calculateCurrentExpressPosition(currentExpTrack, currentTime.value);
                console.log('点击表情的 Position:', currentPressPosition);
                // 计算角色当前位置
                // let pos = {x: 0, y: 0};
                let roleWidth = currentPressPosition.width*currentPressPosition.scale || 100;
                let roleHeight = currentPressPosition.height*currentPressPosition.scale || 100;
                let currentAngle = currentPressPosition.angle || 0;
                
                // canvasCurrentRole = selectedRoleId;
                //console.log('mouse down 找到当前选择表情:',currentExpTrack)

                // 在新坐标系下，Y轴需要翻转
                // const flippedY = canvasHeight - y;
                

                //角色坐标为中心点的100*100的矩形
                let currentX = currentPressPosition.x;
                let currentY = currentPressPosition.y;
                let topLeftX = currentPressPosition.x- roleWidth/2;
                let topLeftY = currentPressPosition.y- roleHeight/2;


                // 计算角色右上角宽高调整圆点的位置
                const cornerDotX = currentPressPosition.x + roleWidth/2;
                const cornerDotY = currentPressPosition.y + roleHeight/2;
                //console.log('调整 wh点:',cornerDotX,cornerDotY,roleWidth,roleHeight);
                // 计算角色右下角角度调整圆点的位置
                const angleDotX = currentPressPosition.x + roleWidth/2;
                const angleDotY = currentPressPosition.y + roleHeight/2;
                //console.log('调整 angle点:',angleDotX,angleDotY);

                // 检查点击是否在右上角宽高调整圆点范围内
                const distanceToCornerDot = Math.sqrt(
                  Math.pow(x - cornerDotX, 2) + Math.pow(y - cornerDotY, 2)
                );
                
                // 检查点击是否在右下角角度调整圆点范围内
                const distanceToAngleDot = Math.sqrt(
                  Math.pow(x - angleDotX, 2) + Math.pow(y - angleDotY, 2)
                );
                
                // 优先检测点击是否在右上角宽高调整圆点
                if (distanceToCornerDot <= cornerDotSize) {
                  // 点击了右上角宽高调整圆点
                  isDraggingResizeDot = true;
                  draggedRoleId = selectedRoleId.value;
                  initialWidth = roleWidth;
                  initialHeight = roleHeight;
                  initialAngle = currentAngle;
                  initialMouseX = x;
                  initialMouseY = y;
                  canvasElement.style.cursor = 'nesw-resize';
                }
                // 其次检测点击是否在右下角角度调整圆点
                else if (distanceToAngleDot <= cornerDotSize) {
                  // 点击了右下角角度调整圆点
                  isDraggingAngleDot = true;
                  draggedRoleId = selectedRoleId.value;
                  initialWidth = roleWidth;
                  initialHeight = roleHeight;
                  initialAngle = currentAngle;
                  initialMouseX = x;
                  initialMouseY = y;
                  canvasElement.style.cursor = 'alias';
                }
                // 最后检测点击是否在角色本身
                else if (x >= topLeftX && x <= topLeftX + roleWidth &&
                           y >= topLeftY && y <= topLeftY + roleHeight) {
                  console.log('点击了角色本身，但不在调整圆点上');
                  // 点击了角色本身，但不在调整圆点上
                  isDraggingRole = true;
                  draggedRoleId = selectedRoleId.value;
                  
                  // 精确计算点击位置相对于角色左下角原点的偏移量
                  // 这样无论点击角色的哪个位置，拖拽时都会保持这个相对位置
                  dragOffsetX = x - currentPressPosition.x;
                  dragOffsetY = y - currentPressPosition.y; 
                  
                  //console.log(`拖拽偏移量: X=${dragOffsetX.toFixed(2)}, Y=${dragOffsetY.toFixed(2)}`);
                  canvasElement.style.cursor = 'grabbing';
                }
                //console.log('click initialWidth:',initialWidth,initialHeight);

              }
            }
          });
          
          // 鼠标移动事件（添加到document以确保拖拽过程中鼠标离开Canvas也能继续）
          canvasElement.addEventListener('mousemove', (e) => {
            if (enableCameraEdit.value) return;

            // const rect = canvasElement.getBoundingClientRect();
            // const scaleX = canvasElement.width / rect.width;
            // const scaleY = canvasElement.height / rect.height;
            // // 计算当前鼠标在Canvas中的X坐标，减去偏移量以获得角色左下角应该在的位置
            // const mouseX = (e.clientX - rect.left) * scaleX;
            // const mouseY = (e.clientY - rect.top) * scaleY;

            const {rect, scaleX, scaleY, mouseX, mouseY} = getCanvasPosition(e);
            const x = mouseX - dragOffsetX;
            const y = mouseY - dragOffsetY;
            // 关键点：使用与渲染时完全相同的Canvas高度（offscreenCanvas）进行坐标系转换
            const canvasHeight = offscreenCanvas.height;
            
            //console.log('move ',isDraggingRole,isDraggingResizeDot,isDraggingAngleDot,draggedRoleId);
            if (!isDraggingRole && !isDraggingResizeDot && !isDraggingAngleDot || !draggedRoleId || isPlaying.value) return;


            let currentExpTrack = expressionManager.canvasCurrentExpTrack;
            const currentExpressPosition = expressionManager.calculateCurrentExpressPosition(currentExpTrack, currentTime.value);

            if (isDraggingResizeDot) {
              // 右上角宽高调整点 - 只处理宽高调整
              
              console.log('move, resize current express Position:',currentExpressPosition);
              
              if (currentExpTrack) {
                // 计算鼠标移动的差值
                const deltaX = mouseX - initialMouseX;
                const deltaY = mouseY - initialMouseY;
                //console.log('move 宽高调整:', deltaX,deltaY,currentExpTrack);
                
                // 计算新的宽高
                const scaleFactor = round(1 + (deltaX + deltaY) / (initialWidth + initialHeight)) || 1;
                const newWidth = Math.max(20, initialWidth * scaleFactor);
                const newHeight = Math.max(20, initialHeight * scaleFactor);
                console.log('initialWidth:',initialWidth,initialHeight);
                const newScaleFactor = round(newWidth/currentExpressPosition.width);
                console.log('newWidth newHeight scaleFactor:',newWidth,newHeight,scaleFactor,newScaleFactor);


                

                // let ww = currentPosition.width+newWidth;
                // let hh = currentPosition.height+newHeight;
                // console.log('ww hh:',ww,hh);
                
                if (currentExpTrack._isTemp) {
                  // 如果是临时轨道，直接更新场景中的角色配置
                  //console.log('modify default size-scale：',currentExpTrack)
                  const sceneRoles = getSceneRolesByTime(currentTime.value);
                  if (sceneRoles) {
                    const currentScene = timeline.value.scenes.find(scene => {
                      const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                      return sceneShots.some(shot => 
                        currentTime.value >= shot.startTime && 
                        currentTime.value < shot.startTime + shot.duration
                      );
                    });
                      
                    if (currentScene) {
                      const sceneRoleIndex = currentScene.roles.findIndex(r => r.roleId === draggedRoleId);
                      if (sceneRoleIndex !== -1) {
                        // currentScene.roles[sceneRoleIndex].width = newWidth;
                        // currentScene.roles[sceneRoleIndex].height = newHeight;
                        currentScene.roles[sceneRoleIndex].scale = newScaleFactor;
                      }
                    }
                  }
                } else {
                  // 使用临时变量更新宽高
                  // currentExpTrack._tempWidth = newWidth;
                  // currentExpTrack._tempHeight = newHeight;
                  currentExpTrack.scale = newScaleFactor;
                  console.log('modify expTrack size-scale：', newScaleFactor);
                }
                
                renderFrame(25);
              }
            } else if (isDraggingAngleDot) {
              // 角度调整点 - 只处理角度调整
              let currentExpTrack = expressionManager.canvasCurrentExpTrack;
              console.log('move, angle current express Position:',currentExpressPosition);

              if (currentExpTrack) {
                // 获取当前角色位置
                // const pos = expressionManager.calculateCurrentExpressPosition(currentExpTrack, currentTime.value);
                const roleCenterX = currentExpressPosition.x + initialWidth / 2;
                const roleCenterY = currentExpressPosition.y + initialHeight / 2;
                
                // 计算初始角度（相对于角色中心）
                const initialAngleRad = Math.atan2(initialMouseY - roleCenterY, initialMouseX - roleCenterX);
                // 计算当前角度（相对于角色中心）
                const currentAngleRad = Math.atan2(mouseY - roleCenterY, mouseX - roleCenterX);
                
                // 计算角度差并转换为度数
                let angleDiff = (currentAngleRad - initialAngleRad) * 180 / Math.PI;
                // 确保角度差在合理范围内
                if (angleDiff > 180) angleDiff -= 360;
                if (angleDiff < -180) angleDiff += 360;
                
                // 计算新角度
                const newAngle = (initialAngle - angleDiff) % 360;
                console.log('mov newAngle:',newAngle);
                if (currentExpTrack._isTemp) {
                  // 如果是临时轨道，直接更新场景中的角色配置
                  const sceneRoles = getSceneRolesByTime(currentTime.value);
                  if (sceneRoles) {
                    const currentScene = timeline.value.scenes.find(scene => {
                      const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                      return sceneShots.some(shot => 
                        currentTime.value >= shot.startTime && 
                        currentTime.value < shot.startTime + shot.duration
                      );
                    });
                      
                    if (currentScene) {
                      const sceneRoleIndex = currentScene.roles.findIndex(r => r.roleId === draggedRoleId);
                      if (sceneRoleIndex !== -1) {
                        currentScene.roles[sceneRoleIndex].angle = newAngle;
                      }
                    }
                  }
                } else {
                  // 使用临时变量更新角度
                  currentExpTrack.angle = newAngle;
                  console.log('修改角色角度：tempTrack', currentExpTrack);
                }
                
                renderFrame(26);
              }
            } else if (isDraggingRole) {
              // 只有在拖拽角色时才打印日志
              console.log(`move dragging role 鼠标位置: (${mouseX.toFixed(2)}, ${mouseY.toFixed(2)}), 角色位置: (${x.toFixed(2)}, ${y.toFixed(2)})`);
              // 找到当前时间点该角色的表情轨道或临时轨道
              const currentExpTrack = expressionManager.canvasCurrentExpTrack;
              //console.log('mouse moving 找到当前选择表情:',currentExpTrack)
              if (currentExpTrack) {
                if (currentExpTrack._isTemp) {
                  // 如果是临时轨道，直接更新场景中的角色配置
                  console.log('临时轨道:修改角色缺省位置1', currentExpTrack);
                  const sceneRoles = getSceneRolesByTime(currentTime.value);
                  if (sceneRoles) {
                    const currentScene = timeline.value.scenes.find(scene => {
                      const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                      return sceneShots.some(shot => 
                        currentTime.value >= shot.startTime && 
                        currentTime.value < shot.startTime + shot.duration
                      );
                    });
                     
                    if (currentScene) {
                      const sceneRoleIndex = currentScene.roles.findIndex(r => r.roleId === draggedRoleId);
                      if (sceneRoleIndex !== -1) {
                        //console.log('临时轨道:修改角色缺省位置2');
                        currentScene.roles[sceneRoleIndex].x = x;
                        currentScene.roles[sceneRoleIndex].y = y;
                      }
                    }
                  }
                } else {
                  // 临时更新位置，用于预览
                  //console.log('非临时轨道:修改表情位置2');
                  currentExpTrack._tempX = x;
                  currentExpTrack._tempY = y;
                }
                renderFrame(27);
              }
            }
          });
          
          // 鼠标释放事件
          canvasElement.addEventListener('mouseup', (e) => {
            if (enableCameraEdit.value) return;
            if ((!isDraggingRole && !isDraggingResizeDot && !isDraggingAngleDot) || !draggedRoleId) return;
            
            isDraggingRole = false;
            isDraggingResizeDot = false;
            isDraggingAngleDot = false;
            canvasElement.style.cursor = 'default';
            
            // 找到当前时间点该角色的表情轨道
            const currentExpTrack = expressionManager.canvasCurrentExpTrack;

            //console.log('mouse up 找到当前选择表情，是否临时:',currentExpTrack._isTemp)

            if (currentExpTrack) {
              if (currentExpTrack._isTemp) {
                  // 如果是临时轨道，直接更新场景中的角色配置
                  console.log('临时轨道:修改角色缺省位置1', currentExpTrack);
                  const sceneRoles = getSceneRolesByTime(currentTime.value);
                  if (sceneRoles) {
                    const currentScene = timeline.value.scenes.find(scene => {
                      const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                      return sceneShots.some(shot => 
                        currentTime.value >= shot.startTime && 
                        currentTime.value < shot.startTime + shot.duration
                      );
                    });
                     
                    if (currentScene) {
                      const sceneRoleIndex = currentScene.roles.findIndex(r => r.roleId === draggedRoleId);
                      if (sceneRoleIndex !== -1) {
                        console.log('临时轨道:修改角色缺省位置2');
                        const {rect, scaleX, scaleY, mouseX, mouseY} = getCanvasPosition(e);
                        const x = mouseX - dragOffsetX;
                        const y = mouseY - dragOffsetY;
                        currentScene.roles[sceneRoleIndex].x = x;
                        currentScene.roles[sceneRoleIndex].y = y;
                      }
                    }
                  }

              }else{
                // 检查是否是表情的最后时刻
                const isLastMoment = Math.abs(currentTime.value - (currentExpTrack.endTime - 100)) < 400;
                
                // 保存位置
                if (currentExpTrack._tempX !== undefined && currentExpTrack._tempY !== undefined) {
                  if (isLastMoment) {
                    // 如果是最后时刻，更新x1,y1
                    currentExpTrack.x1 = currentExpTrack._tempX;
                    currentExpTrack.y1 = currentExpTrack._tempY;
                  } else {
                    // 否则更新x,y
                    currentExpTrack.x = currentExpTrack._tempX;
                    currentExpTrack.y = currentExpTrack._tempY;
                  }

                  console.log('mouse up 修改表情位置：tempTrack',currentExpTrack)
                  // 从临时轨道中删除
                  //timeline.value.expressionTracks = timeline.value.expressionTracks.filter(track => track !== currentExpTrack);

                  // 清除临时位置
                  delete currentExpTrack._tempX;
                  delete currentExpTrack._tempY;
                }
                
                // 保存宽高
                if (currentExpTrack._tempWidth !== undefined && currentExpTrack._tempHeight !== undefined) {
                  currentExpTrack.width = currentExpTrack._tempWidth;
                  currentExpTrack.height = currentExpTrack._tempHeight;
                  console.log('mouse up 修改表情宽高：tempTrack',currentExpTrack._tempWidth)
                  // 清除临时宽高
                  delete currentExpTrack._tempWidth;
                  delete currentExpTrack._tempHeight;
                }
                
                // 保存角度
                if (currentExpTrack._tempAngle !== undefined) {
                  currentExpTrack.angle = currentExpTrack._tempAngle;
                  console.log('mouse up 修改表情角度：tempTrack',currentExpTrack)

                  // 清除临时角度
                  delete currentExpTrack._tempAngle;
                }
              }

              
              // 重新渲染
              renderFrame(28);
              // 更新表情轨道显示
              drawExpressionTracks();
            } 
            

            expressionManager.canvasCurrentExpTrack = null;
            draggedRoleId = null;
          });
          


          ///////////////////////////////////////////
          // timeline
          ///////////////////////////////////////////


          // 监听鼠标拖动时间轴和刻度
          let isDragging = false;
          let lastMouseX = 0;
          let isDraggingTick = false;
          let draggedTickId = null;
          
          const timelineArea = document.querySelector('.overflow-x-auto');
          
          timelineArea.addEventListener('mousedown', (e) => {
            // 检查是否正在拖拽表情边缘，如果是则不触发时间轴拖拽
            if (isDraggingExpEdge || isDraggingCameraEdge) {
              //console.log('按下1:',e.button,timeMarkers)
              return;
            }


            //TODO: 检查是否点击了刻度
            if ((e.button === 0) && (e.target.className.includes('time-tick') || e.target == timeMarkers.value)) {

              isDragging = true;
              isDraggingTick = true;
              draggedTickId = e.target.id;
              lastMouseX = e.clientX;
              timelineArea.style.cursor = 'grabbing';
              stopPlayback();
              selectedShotId.value = null; // 取消选中
              //selectedRoleId.value = null;
              
              // 添加拖拽中的样式
              e.target.classList.add('time-tick-dragging');
              
              // 从刻度ID中提取时间（例如 'tick-5' 对应 5 秒）
              const timeStr = draggedTickId.split('-')[1];
              const time = parseInt(timeStr) * 1000; // 转换为毫秒
              //currentTime.value = Math.max(0, Math.min(time, totalDuration.value));
              updateTimelineDisplay();
              //renderFrame(29);
              
            } 
            // 分镜轨道拖拽 - 支持直接点击分镜轨道进行拖拽
            else if ((e.button === 0) && (e.target === timelineArea || e.target.className.includes('timeline-track') || 
                     (e.target.closest('.timeline-track') && !e.target.classList.contains('shot-item')))) {
              isDragging = true;
              lastMouseX = e.clientX;
              timelineArea.style.cursor = 'grabbing';
              stopPlayback();
              selectedShotId.value = null; // 取消选中
              //selectedRoleId.value = null;
            }
            // 分镜项拖拽 - 当点击分镜项但不是点击分镜内部的子元素时，也支持拖拽
            else if (e.target.classList.contains('shot-item') || e.target.closest('.shot-item')) {
              // 如果点击的是分镜的子元素，找到最外层的分镜元素
              const shotItem = e.target.classList.contains('shot-item') ? e.target : e.target.closest('.shot-item');
              
              // 检查点击是否在分镜的特定交互区域外（例如点击的是分镜本身而不是其内部按钮等）
              if (!e.target.classList.contains('shot-header') && !e.target.closest('.shot-header')) {
                isDragging = true;
                lastMouseX = e.clientX;
                timelineArea.style.cursor = 'grabbing';
                stopPlayback();
                selectedShotId.value = null; // 取消选中
                //selectedRoleId.value = null;
                
                // 阻止事件冒泡到分镜点击事件
                e.stopPropagation();
              }
            }
          });
          
          timelineArea.addEventListener('mousemove', (e) => {
            // 检查是否正在拖拽表情边缘，如果是则不触发时间轴拖拽
            if (isDraggingExpEdge || isDraggingCameraEdge) {
              return;
            }
            
            if (isDragging) {
              const deltaX = e.clientX - lastMouseX;
              lastMouseX = e.clientX;
              
              // 计算时间变化 (像素差 -> 时间差)
              const timeDelta = (deltaX / MARGIN / zoom.value) * 1000;
              currentTime.value = Math.max(0, Math.min(currentTime.value - timeDelta, totalDuration.value));
              
              updateTimelineDisplay();
              renderFrame();
            }
          });
          
          timelineArea.addEventListener('mouseup', () => {
            if (isDragging) {
              isDragging = false;
              timelineArea.style.cursor = 'default';
              
              // 如果是拖拽刻度，清除拖拽状态
              if (isDraggingTick) {
                isDraggingTick = false;
                draggedTickId = null;
                
                // 移除所有刻度的拖拽样式
                document.querySelectorAll('.time-tick-dragging').forEach(tick => {
                  tick.classList.remove('time-tick-dragging');
                });
              }
            }
          });
          
          // 添加CSS样式使拖拽更直观
          const style = document.createElement('style');
          style.textContent = `
            .time-tick {
              cursor: grab;
              transition: all 0.2s ease;
            }
            
            .time-tick:hover {
              background-color: #3B82F6;
              opacity: 0.8;
              transform: scaleY(1.2);
            }
            
            .time-tick-dragging {
              cursor: grabbing;
              background-color: #EBF5FF ;
              opacity: 1;
              // transform: scaleY(1.5);
              z-index: 100;
            }
            
            .time-tick-major {
              background-color: #6B7280;
              height: 20px;
            }
            
            .time-tick-medium {
              background-color: #9CA3AF;
              height: 15px;
            }
            
            .time-tick-minor {
              background-color: #D1D5DB;
              height: 10px;
            }
            
            #animationCanvas {
              cursor: default;
            }
            
            #animationCanvas:hover {
              cursor: pointer;
            }
            
            .role-dragging {
              cursor: grabbing !important;
            }
          `;
          document.head.appendChild(style);
        });
        

        
        // 监听选中的分镜变化，更新显示
        watch(selectedShotId, () => {
          drawShotTrack();
        });
        
        // 添加专门的函数来处理分镜高亮，确保在播放时能够正确更新
        const updateShotHighlights = () => {
          if (!shotContainer.value) return;
          
          // 获取所有分镜元素
          const shotElements = shotContainer.value.querySelectorAll('.shot-item');
          
          // 遍历所有分镜元素
          timeline.value.shots.forEach((shot, index) => {
            const shotEl = shotElements[index];
            if (!shotEl) return;
            
            // 使用更严格的计算逻辑
            const shotEndTime = shot.startTime + shot.duration;
            const isTimeInShot = currentTime.value >= shot.startTime && currentTime.value < shotEndTime;
            
            if (isTimeInShot) {
              // 确保添加高亮类
              shotEl.classList.add('time-pointer-active');
              
              if (selectedShotId.value === shot.id) {
                shotEl.classList.add('editing-breathing-bg');
              } else {
                shotEl.classList.remove('editing-breathing-bg');
              }
            } else {
              // 确保移除高亮类
              shotEl.classList.remove('time-pointer-active');
              shotEl.classList.remove('editing-breathing-bg');
            }
          });
        };
        
        
        
        

        // 初始化时更新时间轴显示，确保镜头轨道正确绘制
        //updateTimelineDisplay();
        
        // 角色预览相关方法
        const showRolePreviewClick = () => {
          showRolePreview.value = !showRolePreview.value;
          if(showRolePreview.value){
            // 获取当前场景的角色信息
            loadCurrentSceneRoles();
          }
        }
        
        // 切换添加角色下拉菜单显示状态
        const toggleRoleDropdown = () => {
          showRoleDropdown.value = !showRoleDropdown.value;
        }
        
        // 添加角色到当前场景
        const addRoleToCurrentScene = (roleId) => {
          // 根据当前时间找到所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            currentTime.value >= shot.startTime && currentTime.value < shot.startTime + shot.duration
          );
          
          if (!currentShot) {
            console.error('未找到当前分镜，无法添加角色');
            return;
          }
          
          // 找到包含当前分镜的场景
          const currentScene = timeline.value.scenes.find(scene => 
            scene.shots.includes(currentShot.id)
          );
          
          if (!currentScene) {
            console.error('未找到当前场景，无法添加角色');
            return;
          }
          
          // 检查角色是否已在场景中
          const isRoleAlreadyInScene = currentScene.roles.some(r => r.roleId === roleId);
          if (isRoleAlreadyInScene) {
            console.warn(`角色 ${roleId} 已在当前场景中`);
            // 关闭下拉菜单
            showRoleDropdown.value = false;
            return;
          }
          
          // 获取角色信息
          const role = mockRoles.find(r => r.id === roleId);
          if (!role) {
            console.error(`未找到角色 ${roleId}`);
            return;
          }
          
          // 创建新角色对象，设置默认位置和属性
          const newRole = {
            roleId: roleId,
            expressionId: role.defaultExpressionId || 'default',
            x: (canvas.value.width / 2), // 居中位置
            y: (canvas.value.height / 2), // 居中位置
            angle: 0,
            scale: 1
          };
          
          // 添加到场景的角色数组
          currentScene.roles.push(newRole);
          
          // 更新当前场景角色列表
          loadCurrentSceneRoles();
          
          // 关闭下拉菜单
          showRoleDropdown.value = false;
          
          console.log(`已成功添加角色 ${roleId} 到当前场景`);
        }

        // 加载当前场景的角色信息
        const loadCurrentSceneRoles = () => {
          // 根据当前时间找到所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            currentTime.value >= shot.startTime && currentTime.value < shot.startTime + shot.duration
          );
          
          if (!currentShot) {
            currentSceneRoles.value = [];
            return;
          }
          
          // 找到包含当前分镜的场景
          const currentScene = timeline.value.scenes.find(scene => 
            scene.shots.includes(currentShot.id)
          );
          
          if (!currentScene || !currentScene.roles) {
            currentSceneRoles.value = [];
            return;
          }
          
          // 复制角色信息并添加visible属性（默认为true）
          currentSceneRoles.value = currentScene.roles.map(role => ({
            ...role,
            visible: true
          }));
          
          // 绘制角色缩略图
          nextTick(() => {
            currentSceneRoles.value.forEach(role => {
              drawRoleThumbnail(role.roleId, role.expressionId);
            });
          });
        }

        // 设置角色缩略图引用
        const setRoleThumbnailRef = (roleId, el) => {
          if (el) {
            roleThumbnailRefs.value[roleId] = el;
          }
        }

        // 根据角色ID获取角色名称
        const getRoleNameById = (roleId) => {
          const role = mockRoles.find(r => r.id === roleId);
          return role ? role.name : '未知角色';
        }

        // 切换角色可见性
        const toggleRoleVisibility = (roleId) => {
          const role = currentSceneRoles.value.find(r => r.roleId === roleId);
          if (role) {
            // 切换角色可见性
            role.visible = !role.visible;
            // 这里可以添加实际的角色显示/隐藏逻辑
            console.log(`角色 ${roleId} 可见性切换为: ${role.visible}`);
            // 触发重新渲染
            //currentSceneRoles.value = [...currentSceneRoles.value];
            renderFrame(44);
          }
        }

        // 设置场景初始位置---无用
        const setSceneInitialPosition = () => {
          // 根据当前时间找到所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            currentTime.value >= shot.startTime && currentTime.value < shot.startTime + shot.duration
          );
          
          if (!currentShot) return;
          
          // 找到包含当前分镜的场景
          const currentScene = timeline.value.scenes.find(scene => 
            scene.shots.includes(currentShot.id)
          );
          
          if (!currentScene || !currentScene.shots || currentScene.shots.length === 0) return;
          
          // 找到场景中的第一个分镜
          const firstShot = timeline.value.shots.find(shot => currentScene.shots.includes(shot.id));
          if (!firstShot) return;
          
          // 将时间指针设置到场景的初始位置
          currentTime.value = firstShot.startTime;
          
          // 滚动时间轴到初始位置
          updateTimelineDisplay();
          
          console.log('已将时间指针调整到场景初始位置');
        }

        // 绘制角色缩略图
        const drawRoleThumbnail = (roleId, expressionId) => {
          const canvas = roleThumbnailRefs.value[roleId];
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // 简单绘制角色缩略图（实际项目中应该根据expressionId绘制对应的表情）
          // 这里使用占位符颜色和简单图形代替
          const role = mockRoles.find(r => r.id === roleId);
          if (role) {
            // 根据角色ID生成不同的背景色
            const color = `hsl(${(roleId.charCodeAt(0) * 31) % 360}, 70%, 60%)`;
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制简单的表情图标
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 16, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // 保存角色位置信息（用于后续提交HTTP请求）
        const saveRolePositions = () => {
          // 根据当前时间找到所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            currentTime.value >= shot.startTime && currentTime.value < shot.startTime + shot.duration
          );
          
          if (!currentShot) return null;
          
          // 找到包含当前分镜的场景
          const currentScene = timeline.value.scenes.find(scene => 
            scene.shots.includes(currentShot.id)
          );
          
          if (!currentScene || !currentScene.roles) return null;
          
          const sceneRoles = currentScene.roles;
          
          // 准备要保存的数据格式
          const saveData = {
            sceneId: currentScene.id,
            roles: sceneRoles.map(role => ({
              roleId: role.roleId,
              position: {
                x: role.x,
                y: role.y,
                angle: role.angle,
                scale: role.scale
              },
              expressionId: role.expressionId
            }))
          };
          
          console.log('准备保存的角色位置数据:', saveData);
          return saveData;
        }

        // 选择场景并跳转到对应时间
        const selectScene = (scene) => {
          selectedScene.value = scene;
          // 跳转到场景的第一个分镜的开始时间
          if (scene && scene.shots && scene.shots.length > 0) {
            const firstShot = scene.shots[0];
            const firstShotObj = timeline.value.shots.find(shot => shot.id === firstShot);
            currentTime.value = firstShotObj.startTime;
            renderFrame();
          }
        };
        
        // 选择分镜
        const selectShot = (shot) => {
          selectedShot.value = shot;
          // 找到该分镜所属的场景
          if (shot && timeline.value && timeline.value.scenes) {
            const scene = timeline.value.scenes.find(scene => 
              scene.shots && scene.shots.some(shotInScene => shotInScene.id === shot.id)
            );
            if (scene) {
              selectedScene.value = scene;
            }
          }
        };
        
        return {
          debugInfo,
          canvas,
          fps,
          timeScale,
          timeMarkers,
          shotTrack,
          shotContainer,
          sceneTrack,
          canvasSizes,
          selectedCanvasSize,
          sceneContainer,
          cameraContainer,
          audioContainer,
          expressionContainers,
          expressionTracks,
          timeline,
          isPlaying,
          currentTime,
          loop,
          zoom,
          markerPosition,
          totalDuration,
          timelineWidth,
          selectedRoleExpression,
          formatTime,
          formatTimess,
          getExpressionName,
          playPause,
          goToStart,
          goToEnd,
          toggleLoop,
          timelineZoomIn,
          timelineZoomOut,
          timelineResetZoom,
          canvasZoomIn,
          // 角色管理面板相关状态和方法
          activeTab,
          selectedScene,
          selectedShot,
          selectScene,
          selectShot,
          canvasZoomOut,
          canvasResetZoom,
          saveProject,
          exportAnimation,
          isRecording,
          targetFps,
          selectedShotId,
          selectedRoleId,
          selectRole,
          setExpressionContainerRef,
          setExpressionTrackRef,
          cameraSizes,
          selectedCameraSize,
          handleCanvasClick,
          showExpressionPanel,
          selectedExpressionId,
          toggleExpressionPanel,
          selectExpression,
          handleExpressionClick,
          addExpression,
          replaceExpression,
          deleteExpression,
          showAllRoleExpressions,
          showCameraTrack,
          updateTimelineDisplay,
          // 摄像机相关状态和方法
          showCamera,
          showCameraClick: () => { 
            showCamera.value = !showCamera.value; 
            if(!showCamera.value) enableCameraEdit.value = false; 
            if(cameraModule) cameraModule.showCameraClick(); 
          },
          showCameraPreview,
          enableCameraEdit,
          showCameraPreviewClick: () => { if (cameraModule) cameraModule.showCameraPreviewClick(); },
          closeCameraPreview: () => { if (cameraModule) cameraModule.closeCameraPreview(); },
          // 虚拟镜头系统扩展功能
          cameraZoom,
          cameraRotation,
          isMaintainingAspectRatio,
          enableCameraRotation,
          showCameraInfo,
          useSmoothTransition,
          cameraPresets,
          saveCameraScenery,
          saveCameraSceneryToShotStart,
          saveCameraSceneryToDialogStart,
          defaultCameraScenery,
          defaultDialogCameraScenery,
          // 虚拟镜头控制方法
          toggleAspectRatio: () => { if (cameraModule) cameraModule.toggleAspectRatio(); },
          toggleCameraRotation: () => { if (cameraModule) cameraModule.toggleCameraRotation(); },
          toggleCameraInfo: () => { if (cameraModule) cameraModule.toggleCameraInfo(); },
          zoomCamera: (factor) => { if (cameraModule && enableCameraEdit.value) cameraModule.zoomCamera(factor); },
          rotateCamera: (degrees) => { if (cameraModule && enableCameraEdit.value) cameraModule.rotateCamera(degrees); },
          applyCameraPreset: (presetIndex) => { if (cameraModule) cameraModule.applyCameraPreset(presetIndex); },
          saveCameraPreset: (presetName) => { if (cameraModule) cameraModule.saveCameraPreset(presetName); },
          deleteCameraPreset: (presetIndex) => { if (cameraModule) cameraModule.deleteCameraPreset(presetIndex); },
          resetCamera: () => { if (cameraModule) cameraModule.resetCamera(); },
          forceUpdateCameraPreview: () => { if (cameraModule) cameraModule.forceUpdateCameraPreview(); },
          
          // 角色预览相关
          showRolePreview,
          currentSceneRoles,
          roleThumbnailRefs,
          showRolePreviewClick,
          setRoleThumbnailRef,
          getRoleNameById,
          toggleRoleVisibility,
          setSceneInitialPosition,
          saveRolePositions,
          showRoleDropdown,
          toggleRoleDropdown,
          addRoleToCurrentScene,
            
          };
      }
    }).mount('#app');
    // 添加全局错误处理器，专门捕获表情选择相关的错误
    window.addEventListener('error', function(e) {
      if (e.message && e.message.includes("Cannot read properties of undefined (reading 'id')")) {
        console.error('捕获到表情选择相关错误:', e.message);
        console.error('错误栈:', e.error.stack);
        
        // 尝试找出可能的undefined对象
        if (e.error && e.error.stack && e.error.stack.includes('Proxy.render')) {
          console.error('错误发生在Vue渲染过程中');
          // 尝试打印当前的timeline数据状态
          try {
            const app = Vue._apps[0];
            if (app && app._instance && app._instance.proxy) {
              console.log('当前Vue组件状态:', {
                selectedRoleId: app._instance.proxy.selectedRoleId,
                selectedExpressionId: app._instance.proxy.selectedExpressionId,
                showExpressionPanel: app._instance.proxy.showExpressionPanel,
                timelineRolesCount: app._instance.proxy.timeline?.roles?.length || 0
              });
            }
          } catch (err) {
            console.error('无法获取Vue组件状态:', err);
          }
        }
      }
    });
    
    // 实现时间轴分隔条的拖拽功能
    document.addEventListener('DOMContentLoaded', function() {
      const resizer = document.getElementById('timelineResizer');
      const timelineContent = document.getElementById('timelineContent');
      let isResizing = false;
      
      if (resizer && timelineContent) {
        // 鼠标按下事件
        resizer.addEventListener('mousedown', function(e) {
          isResizing = true;
          document.body.style.cursor = 'ns-resize';
          
          // 阻止默认行为和冒泡，防止文本选择等
          e.preventDefault();
          e.stopPropagation();
        });
        
        // 鼠标移动事件
        document.addEventListener('mousemove', function(e) {
          if (!isResizing) return;
          
          // 计算新的时间轴高度
          // 获取视口高度
          const viewportHeight = window.innerHeight;
          // 获取分隔条位置
          const resizerRect = resizer.getBoundingClientRect();
          // 计算鼠标位置相对于分隔条顶部的偏移量
          const offset = e.clientY - resizerRect.top;
          // 计算新的高度（确保有最小高度）
          const newHeight = Math.max(100, viewportHeight - e.clientY - 20); // 20px的底部边距
          
          // 设置时间轴内容的高度
          timelineContent.style.height = newHeight + 'px';
        });
        
        // 鼠标释放事件
        document.addEventListener('mouseup', function() {
          if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
          }
        });
        
        // 鼠标离开页面事件
        document.addEventListener('mouseleave', function() {
          if (isResizing) {
            isResizing = false;
            document.body.style.cursor = 'default';
          }
        });
       }
    });
  </script>
</body>
</html>
    