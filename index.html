<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>动画编辑器</title>
  <!-- 引入外部资源 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  
  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#10B981',
            dark: '#1E293B',
            light: '#F8FAFC',
            accent: '#8B5CF6',
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {          content-visibility: auto;        }        
      .timeline-track {          @apply h-10 border-b border-gray-300 relative;        }        
      .timeline-marker {          @apply absolute w-1 bg-red-500 top-0 bottom-0 z-10;        }        
      .timeline-marker::after {          content: '';          @apply absolute -top-3 -left-3 w-6 h-6 rounded-full bg-red-500;        }        
      .shot-item {          @apply absolute top-0 h-full border border-blue-400 bg-blue-50 opacity-70 flex flex-col items-center justify-center text-xs cursor-move transition-all;          min-width: 80px; /* 增加最小宽度确保时间信息可读 */        }        
      .shot-item:hover {          @apply opacity-100 shadow-md border-blue-600;        }        
      .expression-item {      @apply absolute h-8 border border-green-400 bg-green-50 opacity-70 flex items-center justify-center text-xs cursor-move transition-all;
          min-width: 3px; /* 减小最小宽度限制，允许更窄的表情项 */
        }        
        .expression-item:hover {          @apply opacity-100;        }        
        .time-tick {          @apply absolute h-4 w-px bg-gray-400 bottom-0;        }        
        .time-tick-major {          @apply h-6 bg-gray-600;        }        
        .time-tick-medium {          @apply h-5 bg-gray-500;        }        
        .time-tick-minor {          @apply h-4 bg-gray-400;        }        
        .time-label {
            @apply absolute -top-2 bg-white/90 px-2 py-1 rounded-md text-xs font-medium text-gray-700 transform -translate-x-1/2 whitespace-nowrap z-10;
          }        
        .time-label-major {          @apply text-sm font-medium text-gray-700;        }        
        .shot-header {          @apply w-full;        }        
        .shot-time-info {          @apply w-full text-center;        }
      .play-icon {
        clip-path: polygon(0 0, 0 100%, 100% 50%);
      }
      .editing-breathing-bg {
        animation: breathing 2s ease-in-out infinite;
      }
      .selected-role-indicator {
        @apply absolute border-2 border-yellow-500 bg-yellow-100/50 z-20 pointer-events-none;
      }
      @keyframes breathing {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
      }
      
      /* 为时间指针指向的分镜添加高亮效果 */
      .time-pointer-active {
        opacity: 1 !important;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
        border-color: #2563eb !important;
        background-color: #eff6ff !important;
        transition: all 0.2s ease !important;
      }
    }
  </style>
</head>
<body class="bg-gray-100 font-sans text-dark">
  <div id="app" class="flex flex-col h-screen overflow-hidden">
    <!-- 顶部导航栏 -->
    <header class="bg-white shadow-md p-4 flex justify-between items-center">
      <h1 class="text-2xl font-bold text-primary">动画编辑器</h1>
      <div class="flex space-x-4">
        <div class="flex items-center space-x-1">
          <label for="canvasSizeSelect" class="text-sm text-gray-600">尺寸:</label>
          <select
            id="canvasSizeSelect"
            v-model="selectedCanvasSize"
            class="w-32 px-2 py-1 border border-gray-300 rounded"
          >
            <option v-for="size in canvasSizes" :key="size.name" :value="size">
              {{ size.name }}
            </option>
          </select>
        </div>
        <div class="flex items-center space-x-1">
          <label for="fpsInput" class="text-sm text-gray-600">FPS:</label>
          <input
            id="fpsInput"
            v-model.number="targetFps"
            type="number"
            min="25"
            max="30"
            class="w-16 px-2 py-1 border border-gray-300 rounded text-center"
          >
        </div>
        <button @click="saveProject" class="flex items-center space-x-1 bg-primary text-white px-4 py-2 rounded hover:bg-primary/90 transition">
          <i class="fa fa-save"></i>
          <span>保存</span>
        </button>
        <button @click="exportAnimation" class="flex items-center space-x-1 bg-accent text-white px-4 py-2 rounded hover:bg-accent/90 transition">
          <i class="fa fa-download"></i>
          <span>导出</span>
        </button>
      </div>
    </header>
    
    <!-- 主内容区 -->
    <main class="flex-1 flex flex-col overflow-hidden">
      <!-- 画布区域 -->
      <div class="flex-1 relative bg-gray-200 border-b border-gray-300 overflow-hidden flex items-center justify-center">
        <!-- Canvas容器，用于等比缩放 -->
        <div id="canvasContainer" class="relative">
          <canvas id="animationCanvas" @click="handleCanvasClick"></canvas>
        </div>
        

        
        <!-- 表情选择面板 -->
        <div 
          v-if="showExpressionPanel && selectedRoleId"
          class="absolute top-0 right-0 h-full w-64 bg-white shadow-lg transform transition-transform duration-300 z-50"
          :style="{ transform: showExpressionPanel ? 'translateX(0)' : 'translateX(100%)' }"
        >
          <div class="p-4">
            <h3 class="text-lg font-bold mb-4">表情选择</h3>
            <div class="space-y-2 max-h-[calc(100%-150px)] overflow-y-auto">
              <!-- 简化的表情列表渲染，使用更严格的安全检查 -->
              <div v-if="selectedRoleId && timeline.roles">
                <!-- 先找到当前选中的角色 -->
                <template v-for="role in timeline.roles">
                  <div v-if="role && role.id === selectedRoleId && role.expressions && role.expressions.length > 0">
                    <!-- 再渲染该角色的表情列表 -->
                    <template v-for="expr in role.expressions">
                      <div 
                        v-if="expr && expr.id && expr.name"
                        :key="expr.id"
                        @click="handleExpressionClick(expr)"
                        class="p-2 border rounded cursor-pointer hover:bg-gray-100 transition flex items-center justify-between"
                        :class="selectedExpressionId === expr.id ? 'bg-green-100 border-green-500' : ''"
                      >
                        <span>{{ expr.name }}</span>
                        <i v-if="selectedExpressionId === expr.id" class="fa fa-check text-green-500"></i>
                      </div>
                    </template>
                    <!-- 当没有表情时显示提示 -->
                    <div v-else class="p-2 text-gray-500 italic">暂无可用表情</div>
                  </div>
                </template>
                <!-- 当未找到角色时显示提示 -->
                <div v-else class="p-2 text-gray-500 italic">未找到选中的角色</div>
              </div>
              <!-- 当未选择角色时显示提示 -->
              <div v-else class="p-2 text-gray-500 italic">请先选择一个角色</div>
            </div>
            <div class="absolute bottom-0 left-0 right-0 p-4 border-t flex space-x-2">
              <button @click="addExpression" class="flex-1 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
                添加
              </button>
              <button @click="replaceExpression" class="flex-1 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
                替换
              </button>
              <button @click="deleteExpression" class="flex-1 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition">
                删除
              </button>
            </div>
          </div>
        </div>
        
        <!-- 画布控制按钮 -->
        <div class="absolute top-4 right-4 bg-white/80 backdrop-blur-sm p-2 rounded-lg shadow-lg flex space-x-2">
          <button @click="zoomIn" class="p-2 hover:bg-gray-100 rounded">
            <i class="fa fa-search-plus"></i>
          </button>
          <button @click="zoomOut" class="p-2 hover:bg-gray-100 rounded">
            <i class="fa fa-search-minus"></i>
          </button>
          <button @click="resetZoom" class="p-2 hover:bg-gray-100 rounded">
            <i class="fa fa-home"></i>
          </button>
        </div>
      </div>
      
      <!-- 时间轴控制区 -->
      <div class="h-64 bg-white border-t border-gray-300 flex flex-col">
        <!-- 播放控制 -->
        <div class="h-12 border-b border-gray-300 flex items-center justify-between px-4">
          <div class="flex items-center mr-2">
            <input 
              type="checkbox" 
              id="showAllExpressions" 
              v-model="showAllRoleExpressions" 
              @change="updateTimelineDisplay"
              class="mr-1" 
              checked />
            <label for="showAllExpressions" class="text-sm text-gray-700">角色表情</label>
          </div>
          <button @click="goToStart" class="p-2 hover:text-primary transition">
            <i class="fa fa-step-backward"></i>
          </button>
          <button @click="playPause" class="p-3 bg-primary text-white rounded-full hover:bg-primary/90 transition relative w-10 h-10 flex items-center justify-center">
            <div v-if="!isPlaying" class="play-icon bg-white w-4 h-6 ml-0.5"></div>
            <div v-else class="flex space-x-1">
              <div class="bg-white w-2 h-6"></div>
              <div class="bg-white w-2 h-6 ml-1"></div>
            </div>
          </button>
          <button @click="goToEnd" class="p-2 hover:text-primary transition">
            <i class="fa fa-step-forward"></i>
          </button>
          <div class="text-sm text-gray-600">
            {{ formatTime(currentTime) }} / {{ formatTime(totalDuration) }}
          </div>
          <button @click="toggleLoop" class="p-2 hover:text-primary transition" :class="loop ? 'text-primary' : ''">
            <i class="fa fa-repeat"></i>
          </button>
          
          <!-- 角色功能按钮区域 -->
          <div v-if="!isPlaying && selectedRoleId" class="ml-auto flex justify-end space-x-2">
            <button @click="toggleExpressionPanel" class="p-2 bg-green-500 text-white rounded hover:bg-green-600 transition">
              <i class="fa fa-smile-o"></i> 表情
            </button>
            <button class="p-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
              <i class="fa fa-sign-in"></i> 出入场
            </button>
            <button class="p-2 bg-purple-500 text-white rounded hover:bg-purple-600 transition">
              <i class="fa fa-arrows"></i> 朝向
            </button>
            <button class="p-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition">
              <i class="fa fa-child"></i> 姿势
            </button>
            <button class="p-2 bg-red-500 text-white rounded hover:bg-red-600 transition">
              <i class="fa fa-volume-up"></i> 音色
            </button>
            <button class="p-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition">
              <i class="fa fa-layers"></i> 图层
            </button>
            <button class="p-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition">
              <i class="fa fa-user-plus"></i> 角色
            </button>
          </div>
        </div>
        
        <!-- 时间轴区域 - 添加滚动功能 -->
        <div id="timelineContainer" class="flex-1 relative overflow-x-auto ">
          <div class="absolute top-0 left-0 right-0 bottom-0" :style="{ width: '100%'}">
            <!-- 时间刻度 -->
            <!-- 使用sticky定位使时间刻度固定在顶部 -->
              <div class="sticky top-0 z-10 h-8 border-b border-gray-300 relative" ref="timeScale">
                <div id = "timeMarkers" class="timeMarkers absolute top-0 bottom-0 left-0 right-0" ref="timeMarkers"></div>
              </div>
            
            <!-- 分镜轨道 -->
            <div class="timeline-track" ref="shotTrack">
              <div class="absolute top-0 left-0 h-full" ref="shotContainer" style="width: 100%;"></div>
            </div>
            
            <!-- 场景轨道 -->
            <div class="timeline-track" ref="sceneTrack" style="height: 20px;">
              <div class="absolute top-0 left-0 h-full" ref="sceneContainer" style="width: 100%;"></div>
            </div>
            
            <!-- 角色表情轨道 -->
            <template v-if="showAllRoleExpressions || (selectedRoleId && !showAllRoleExpressions)">
              <!-- 展示所有角色表情 -->
              <template v-if="showAllRoleExpressions">
                <div v-for="(role, index) in timeline.roles" :key="role.id" class="timeline-track" :ref="setExpressionTrackRef(role.id)">
                  <div class="absolute top-1 left-0 h-10"  style="width: 100%;" :ref="setExpressionContainerRef(role.id)"></div>
                  <div class="absolute top-0 left-0 h-full w-20 bg-gray-100 flex items-center justify-center text-xs">
                    <span @click="selectRole(role.id)">{{ role.name }}</span>
                  </div>
                </div>
              </template>
              <!-- 只展示选中角色表情 -->
              <template v-else-if="selectedRoleId">
                <div v-for="(role, index) in timeline.roles.filter(r => r.id === selectedRoleId)" :key="role.id" class="timeline-track" :ref="setExpressionTrackRef(role.id)">
                  <div class="absolute top-1 left-0 h-10"  style="width: 100%;" :ref="setExpressionContainerRef(role.id)"></div>
                  <div class="absolute top-0 left-0 h-full w-20 bg-gray-100 flex items-center justify-center text-xs">
                    <span @click="selectRole(role.id)">{{ role.name }}</span>
                  </div>
                </div>
              </template>
            </template>
            
            <!-- 时间轴指针 -->
            <div class="timeline-marker" :style="{ left: '50%' }"></div>
          </div>
        </div>
      </div>
      
      <!-- 调试信息显示区域 -->
      <div class="p-4 bg-gray-50 border-t border-gray-200 text-sm text-gray-600">
        <div><strong>调试信息:</strong> {{ debugInfo }}</div>
        <div class="mt-2"><strong>当前指针位置:</strong> {{ markerPosition }}px</div>
        <div class="mt-1"><strong>当前时间:</strong> {{ formatTime(currentTime) }}</div>
      </div>
    </main>
  </div>

  <script>
    // 模拟数据 - 角色 (使用新的角色表情图)
    const mockRoles = [
      {
        id: 'role1',
        name: '老1',
        defaultExpressionId: 'exp1-1',
        voice: 'voice1',
        expressions: [
          {
            id: 'exp1-1',
            name: '默认表情',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/man_1_1.webp',
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/man_1_2.webp'
            ],
            frameInterval: 300
          },
          {
            id: 'exp1-2',
            name: '微笑',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/man_2_1.webp',
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/man_2_2.webp'
            ],
            frameInterval: 400
          },
          {
            id: 'exp1-3',
            name: '惊讶',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r1-3.webp'
            ],
            frameInterval: 200
          },
          {
            id: 'exp1-4',
            name: '悲伤',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r1-4.webp'
            ],
            frameInterval: 250
          },
          {
            id: 'exp1-5',
            name: '生气',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r1-5.webp'
            ],
            frameInterval: 200
          }
        ]
      },
      {
        id: 'role2',
        name: '陈2',
        defaultExpressionId: 'exp2-1',
        voice: 'voice2',
        expressions: [
          {
            id: 'exp2-1',
            name: '默认表情',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r2-1.webp'
            ],
            frameInterval: 300
          },
          {
            id: 'exp2-2',
            name: '开心',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r2-1.webp',
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r2-2.webp'
            ],
            frameInterval: 500
          }
        ]
      },
      {
        id: 'role3',
        name: '张3',
        defaultExpressionId: 'exp3-1',
        voice: 'voice3',
        expressions: [
          {
            id: 'exp3-1',
            name: '默认表情',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r3.webp'
            ],
            frameInterval: 300
          },
          {
            id: 'exp3-2',
            name: '无奈表情',
            frames: [
              'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/r3.webp'
            ],
            frameInterval: 300
          }
        ]
      }
    ];

    // 模拟数据 - 场景
    const mockScenes = [
      {
        id: 'scene1',
        shots: ['shot1'],
        roles: [
          {
            roleId: 'role1',
            expressionId: 'exp1-1',
            x: 150,
            y: 200,
            width: 100,
            height: 150,
            angle: 0
          },
          {
            roleId: 'role2',
            expressionId: 'exp2-1',
            x: 350,
            y: 320,
            width: 120,
            height: 180,
            angle: 0
          }
        ]
      },
      {
        id: 'scene2',
        shots: ['shot2'],
        roles: [
          {
            roleId: 'role1',
            expressionId: 'exp1-2',
            x: 150,
            y: 200,
            width: 100,
            height: 150,
            angle: 0
          },
          {
            roleId: 'role2',
            expressionId: 'exp2-1',
            x: 350,
            y: 320,
            width: 120,
            height: 180,
            angle: 0
          }
        ]
      },
      {
        id: 'scene3',
        shots: ['shot3', 'shot4'],
        roles: [
          {
            roleId: 'role1',
            expressionId: 'exp1-2',
            x: 150,
            y: 200,
            width: 100,
            height: 150,
            angle: 0
          },
          {
            roleId: 'role2',
            expressionId: 'exp2-1',
            x: 350,
            y: 320,
            width: 120,
            height: 180,
            angle: 0
          },
          {
            roleId: 'role3',
            expressionId: 'exp3-1',
            x: 1000,
            y: 580,
            width: 80,
            height: 120,
            angle: 0
          }
        ]
      }
    ]

    // 模拟数据 - 分镜
    const mockShots = [
      {
        id: 'shot1',
        background: 'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg1.webp',
        duration: 5000, // 5秒
        audio: 'audio1.mp3',
        audioDuration: 5000,
        startTime: 0
      },
      {
        id: 'shot2',
        background: 'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg2.webp',
        duration: 4000, // 4秒
        audio: 'audio2.mp3',
        audioDuration: 4000,
        startTime: 5000
      },
      {
        id: 'shot3',
        background: 'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg3.webp',
        duration: 6000, // 6秒
        audio: 'audio3.mp3',
        audioDuration: 6000,
        startTime: 9000
      },
      {
        id: 'shot4',
        background: 'https://mints-web.oss-cn-beijing.aliyuncs.com/sdtool/bg3.webp',
        duration: 5000, // 6秒
        audio: 'audio3.mp3',
        audioDuration: 5000,
        startTime: 15000
      }
    ];

    // 模拟数据 - 角色表情轨道 (添加了角色3的轨道)
    const mockExpressionTracks = [
      {
        roleId: 'role1',
        startTime: 0,
        endTime: 5000,
        expressionId: 'exp1-1',
        x: 0,
        y: 0,
        x1: 300,
        y1: 250
      },
      {
        roleId: 'role1',
        startTime: 7000,
        endTime: 9000,
        expressionId: 'exp1-2',
        x: 300,
        y: 250,
        x1: 450,
        y1: 350
      },
      {
        roleId: 'role1',
        startTime: 12000,
        endTime: 20000,
        expressionId: 'exp1-4',
        x: 250,
        y: 300
      },
      {
        "roleId": "role2",
        "startTime": 5000,
        "endTime": 9000,
        "expressionId": "exp2-1",
        "x": 350,
        "y": 320
      },
      {
        "roleId": "role2",
        "startTime": 15250,
        "endTime": 20000,
        "expressionId": "exp2-2",
        "x": 40,
        "y": 320
      },
      {
        "roleId": "role3",
        "startTime": 11000,
        "endTime": 19050,
        "expressionId": "exp3-1",
        "x": 1000,
        "y": 580
      }
    ];

    // 创建Vue应用
    const { createApp, ref, onMounted, computed, watch } = Vue;
    


    createApp({
      setup() {
        // 状态
        const canvas = ref(null);
        const ctx = ref(null);
        // 离屏Canvas
        let offscreenCanvas = null;
        let offscreenCtx = null;
        const isPlaying = ref(false);
        const currentTime = ref(0);
        const loop = ref(false);
        const zoom = ref(1);
        const animationFrameId = ref(null);
        const lastTime = ref(0);
        const selectedShotId = ref(null); // 选中的分镜
        const selectedRoleId = ref(null); // 选中的角色
        // FPS相关变量
        const fps = ref(0);
        const frameCount = ref(0);
        const lastFpsUpdate = ref(0);
        // 目标FPS，范围25-30，默认25
        const targetFps = ref(25);
        // 背景图缓存对象，用于预加载
        const bgImagesCache = ref({});
        
        // DOM引用
        const timeScale = ref(null);
        const timeMarkers = ref(null);
        const shotTrack = ref(null);
        const shotContainer = ref(null);
        const expressionContainers = ref({});
        const expressionTracks = ref({});
        
        // 用于设置动态ref的函数
        const setExpressionContainerRef = (roleId) => {
          return (el) => {
            if (el) {
              expressionContainers.value[roleId] = el;
            }
          }
        };
        
        // 统一的图片加载函数，强化跨域处理和错误恢复
        // 跟踪正在请求中的图片URL
        const loadingImages = {};
        
        // 控制是否显示所有角色表情轨道的响应式变量
        const showAllRoleExpressions = ref(true);
        
        const loadImageWithCORS = (url, callback, errorCallback) => {
          if (!url) {
            console.error('无效的图片URL');
            if (errorCallback) errorCallback();
            return null;
          }
          
          // 检查URL是否正在请求中
          if (loadingImages[url]) {
            //console.log('图片已在请求中，避免重复请求:', url);
            // 如果已经有回调函数，将新的回调函数也添加进去
            if (callback) {
              loadingImages[url].callbacks.push(callback);
            }
            if (errorCallback) {
              loadingImages[url].errorCallbacks.push(errorCallback);
            }
            return null; // 不返回新的Image对象
          }
          
          const img = new Image();
          img.crossOrigin = "anonymous"; // 解决跨域问题
          
          // 记录请求状态
          loadingImages[url] = {
            callbacks: callback ? [callback] : [],
            errorCallbacks: errorCallback ? [errorCallback] : []
          };
          
          // 添加备用加载策略
          let attempts = 0;
          const maxAttempts = 3;
          
          function attemptLoad() {
            attempts++;
            
            try {
              img.src = url;
            } catch (error) {
              console.error(`图片加载异常 (${attempts}/${maxAttempts}):`, error);
              handleError();
            }
          }
          
          function handleError() {
            if (attempts < maxAttempts) {
              // 指数退避重试
              setTimeout(() => {
                console.log(`尝试重新加载图片 (${attempts+1}/${maxAttempts}):`, url);
                attemptLoad();
              }, 500 * Math.pow(2, attempts));
            } else {
              console.error(`图片加载最终失败 (${maxAttempts}次尝试):`, url);
              // 通知所有错误回调
              const currentErrorCallbacks = loadingImages[url]?.errorCallbacks || [];
              currentErrorCallbacks.forEach(cb => cb());
              // 移除请求状态
              delete loadingImages[url];
            }
          }
          
          img.onload = function() {
            //console.log('成功加载图片:', url);
            // 通知所有成功回调
            const currentCallbacks = loadingImages[url]?.callbacks || [];
            currentCallbacks.forEach(cb => cb(img));
            // 移除请求状态
            delete loadingImages[url];
          };
          
          img.onerror = function() {
            handleError();
          };
          
          // 开始第一次尝试
          attemptLoad();
          
          return img;
        };
        
        const setExpressionTrackRef = (roleId) => {
          return (el) => {
            if (el) {
              expressionTracks.value[roleId] = el;
            }
          }
        };
        
        const MARGIN = 20;//刻度间的间隔，像素

        // 添加一个调试信息的响应式数据
        const debugInfo = ref('');

        // 时间轴数据
        const timeline = ref({
          scenes: [...mockScenes],
          shots: [...mockShots],
          roles: [...mockRoles],
          expressionTracks: [...mockExpressionTracks]
        });
        
        // 根据当前时间获取所属场景中的角色信息
        const getSceneRolesByTime = (time) => {
          // 找到当前时间所在的分镜
          const currentShot = timeline.value.shots.find(shot => 
            time >= shot.startTime && time < shot.startTime + shot.duration
          );
          
          if (!currentShot) {
            // 如果没有找到当前分镜，返回空数组
            return [];
          }
          
          // 找到包含当前分镜的场景
          const currentScene = timeline.value.scenes.find(scene => 
            scene.shots.includes(currentShot.id)
          );
          
          // 返回场景中的角色信息，如果场景不存在或没有角色信息，则返回空数组
          return currentScene && currentScene.roles ? [...currentScene.roles] : [];
        };
        
        // 计算属性
        const totalDuration = computed(() => {
          if (timeline.value.shots.length === 0) return 0;
          return Math.max(...timeline.value.shots.map(shot => shot.startTime + shot.duration));
        });
        
        // 计算时间轴总宽度 (像素) - 增加足够的宽度以确保标签不会重叠
        const timelineWidth = computed(() => {
          // 增加更多的宽度，确保即使在低缩放级别下也有足够的空间
          // 计算总时长的秒数
          const totalSeconds = Math.ceil(totalDuration.value / 1000) + 30;
          // 根据缩放级别和总时长计算宽度，并增加足够的余量
          return (totalSeconds * zoom.value * 1.5) + 200; // 增加1.5倍的空间和200px的余量
        });
        

        
        // 时间轴指针位置 (固定在父div的正中间)
        const markerPosition = computed(() => {
          // 获取时间轴指针的直接父元素
          // 直接父元素是带有":style="{ width: '100%'}"的div
          const timelineMarkerElement = document.querySelector('.timeline-marker');
          
          if (timelineMarkerElement && timelineMarkerElement.parentElement) {
            const parentDiv = timelineMarkerElement.parentElement;
            const parentWidth = parentDiv.offsetWidth;
            const position = parentWidth / 2;
            
            // 更新调试信息
            // debugInfo.value = `使用直接父div的width/2: width=${parentWidth}px, position=${position}px`;
            // console.log(debugInfo.value);
            
            return position;
          }
          //console.log('指针找不到父div');

          
          // 后备方案1：使用timelineContainer的宽度
          const timelineContainer = document.getElementById('timelineContainer');
          if (timelineContainer) {
            const width = timelineContainer.offsetWidth;
            //debugInfo.value = `使用timelineContainer: width=${width}px`;
            // console.log(debugInfo.value);
            return width / 2;
          }
          
          // 后备方案2：使用视口宽度的70%
          //debugInfo.value = '未找到父元素，使用视口宽度的70%';
          // console.log(debugInfo.value);
          return (window.innerWidth * 0.5);
        });
        
        // 获取选中角色当前的表情信息
        const selectedRoleExpression = computed(() => {
          if (!selectedRoleId.value) return null;

          console.log('选中角色id:',selectedRoleId.value)
          // 找到当前时间点该角色的表情轨道
          selectedTrack = timeline.value.expressionTracks.find(track => 
            track.roleId === selectedRoleId.value && 
            currentTime.value >= track.startTime && 
            currentTime.value < track.endTime
          ) || null;
          if (selectedTrack) {
            console.log('选中角色设置的表情轨道:',selectedTrack)
            return selectedTrack
          }
          
          selectedTrack = timeline.value.expressionTracks.find(track => 
            track.roleId === selectedRoleId.value
          ) || null;
          console.log('选中角色默认轨道:',selectedTrack)
          return selectedTrack
        });
        
        // 格式化时间显示 (毫秒 -> mm:ss)
        const formatTime = (ms) => {
          const seconds = Math.floor(ms / 1000) % 60;
          const minutes = Math.floor(ms / 60000);
          return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };
        
        // 获取表情名称
        const getExpressionName = (expressionId) => {
          if (!expressionId) {
            console.warn('尝试获取空的表情ID');
            return '未选择表情';
          }
          
          for (const role of timeline.value.roles) {
            if (!role || !role.expressions) continue;
            const exp = role.expressions.find(e => e && e.id === expressionId);
            if (exp) return exp.name;
          }
          return '未知表情';
        };
        
        // Canvas尺寸选项
        const canvasSizes = ref([
          { name: '720 × 1280', width: 720, height: 1280 },
          { name: '1280 × 720', width: 1280, height: 720 }
        ]);
        
        // 选中的Canvas尺寸 - 默认使用1280×720
         const selectedCanvasSize = ref(canvasSizes.value[1]);
        
        // 表情面板相关状态
        const showExpressionPanel = ref(false);
        const selectedExpressionId = ref(null);
        
        // 初始化画布
        const initCanvas = () => {
          canvas.value = document.getElementById('animationCanvas');
          
          // 添加调试信息，检查canvas是否正确获取
          if (!canvas.value) {
            console.error('canvas err');
            // debugInfo.value = 'canvas err';
            return;
          }
          
          ctx.value = canvas.value.getContext('2d');
          
          // 添加调试信息，检查上下文是否正确获取
          if (!ctx.value) {
            console.error('无法获取canvas上下文');
            debugInfo.value = '无法获取canvas上下文';
            return;
          }
          
          // 定义组件级变量，确保所有函数都能访问
          offscreenCanvas = document.createElement('canvas');
          offscreenCtx = offscreenCanvas.getContext('2d');
          
          // 获取Canvas容器引用
          canvasContainer = document.getElementById('canvasContainer');
          if (!canvasContainer) {
            console.error('未找到canvasContainer元素');
            debugInfo.value = '未找到canvasContainer元素';
            return;
          }
          
          // 设置画布尺寸并应用等比缩放
          const resizeCanvas = () => {
            // 使用选中的尺寸设置Canvas实际像素大小
            canvas.value.width = selectedCanvasSize.value.width;
            canvas.value.height = selectedCanvasSize.value.height;
            
            // 同步调整离屏Canvas尺寸
            offscreenCanvas.width = canvas.value.width;
            offscreenCanvas.height = canvas.value.height;
            
            // 计算Canvas的显示缩放比例，保持宽高比
            const container = document.getElementById('canvasContainer');
            if (container) {
              // 获取父容器的可用尺寸
              const parentWidth = container.parentElement.clientWidth;
              const parentHeight = container.parentElement.clientHeight;
              
              // 计算缩放比例，确保Canvas完全适应容器且保持宽高比
              const widthRatio = parentWidth / canvas.value.width;
              const heightRatio = parentHeight / canvas.value.height;
              const scale = Math.min(widthRatio, heightRatio, 1); // 不超过原始尺寸
              
              // 应用缩放样式
              canvas.value.style.width = (canvas.value.width * scale) + 'px';
              canvas.value.style.height = (canvas.value.height * scale) + 'px';
            }
            
            // 立即绘制一个简单的背景，测试canvas是否正常工作
            ctx.value.fillStyle = '#f0f0f0';
            ctx.value.fillRect(0, 0, canvas.value.width, canvas.value.height);
            
            console.info('resizeCanvas: ' + canvas.value.width + '×' + canvas.value.height);
            renderFrame();
          };
          
          // 监听Canvas尺寸变化
          selectedCanvasSize.value && resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          
          // 监听尺寸选择变化
          watch(selectedCanvasSize, () => {
            resizeCanvas();
          });
        };
        
        // 绘制时间刻度
        const drawTimeMarkers = () => {
          if (!timeMarkers.value) return;
          
          // 清空现有刻度
          timeMarkers.value.innerHTML = '';
          
          // 计算总时长的秒数
          const totalSeconds = Math.ceil(totalDuration.value / 1000) + 30;
          
          // 根据缩放级别动态调整显示间隔，比原来扩大10倍
          let showInterval;
          if (zoom.value >= 5) {
            showInterval = 5; // 最高缩放级别，每10秒显示一个
          } else if (zoom.value >= 3) {
            showInterval = 10; // 高缩放级别，每20秒显示一个
          } else if (zoom.value >= 1) {
            showInterval = 20; // 中等缩放级别，每50秒显示一个
          } else if (zoom.value >= 0.5) {
            showInterval = 50; // 低缩放级别，每100秒显示一个
          } else {
            showInterval = 100; // 最低缩放级别，每300秒显示一个
          }
          // console.log('showInterval:',showInterval)
          // 计算标签文本最小宽度（估计约60像素）
          const minLabelWidth = 60;
          
          // 确保即使在最高缩放级别下，标签之间也有足够的空间
          let actualShowInterval = showInterval;
          if (zoom.value >= 4) {
            // 计算在当前缩放级别下，两个标签之间需要的最小间隔（秒）
            const requiredSecondsBetweenLabels = minLabelWidth / zoom.value;
            actualShowInterval = Math.max(actualShowInterval, Math.ceil(requiredSecondsBetweenLabels));
          }
          
          // 绘制刻度
          for (let t = 0; t <= totalSeconds; t++) {
            const timeMs = t * 1000;
            const x = (timeMs / 1000) * zoom.value;
            
            // 创建刻度线
            const tick = document.createElement('div');
            // 设置唯一ID
            tick.id = `tick-${t}`;
            tick.className = 'time-tick';
            // 设置正确的位置，使用与其他元素一致的计算方式
            const tickPosition = ((timeMs - currentTime.value) / 1000) * MARGIN * zoom.value;
            tick.style.left = `calc(50% + ${tickPosition}px)`;
            // 设置宽度为父容器的宽度
            // tick.style.width = '100%';
            tick.style.width = '2px';

            // 根据是否是重要时间点调整刻度线高度
            if (t % 30 === 0) {
              tick.classList.add('time-tick-major');
            } else if (t % 5 === 0) {
              tick.classList.add('time-tick-medium');
            } else if (t % showInterval === 0) {
              tick.classList.add('time-tick-minor');
            } else {
              tick.classList.add('time-tick-minor');
            }

            // timeMarkers.style.width = '100%';
            timeMarkers.id = 'timeMarkers';
            timeMarkers.value.appendChild(tick);
            
            // 创建时间标签 (只在主要时间点显示标签)
            if (t % 5 === 0) {
              const label = document.createElement('div');
              label.className = 'time-label';
              // 使用与刻度线相同的位置计算方式
              label.style.left = `calc(50% + ${tickPosition}px)`;
              // tick.style.left = `calc(50% + ${(x*1000-currentTime.value)/1000*MARGIN}px)`;
              label.textContent = formatTime(timeMs);
              
              // 重要时间点使用更醒目的样式
              if (t % 30 === 0) {
                label.classList.add('time-label-major');
              }
              
              timeMarkers.value.appendChild(label);
            }
          }
        };
        
        // DOM引用 - 添加场景轨道引用
        const sceneTrack = ref(null);
        const sceneContainer = ref(null);
        
        // 绘制场景轨道
        const drawSceneTrack = () => {
          if (!sceneContainer.value) return;
          
          // 清空现有场景
          sceneContainer.value.innerHTML = '';
          
          // 为每个场景创建一个横线
          timeline.value.scenes.forEach((scene, sceneIndex) => {
            // 获取场景包含的所有分镜
            const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
            
            if (sceneShots.length === 0) return;
            
            // 按时间顺序排序分镜
            const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
            
            // 计算场景的起始时间和持续时间
            const sceneStartTime = sortedShots[0].startTime;
            const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
            const sceneDuration = sceneEndTime - sceneStartTime;
            
            // 计算场景横线在轨道上的位置和宽度
            let startX = ((sceneStartTime - currentTime.value) / 1000) * MARGIN * zoom.value;
            let width = ((sceneDuration-200) / 1000) * MARGIN * zoom.value;
            
            
            // 创建场景容器元素
            const sceneEl = document.createElement('div');
            sceneEl.className = 'absolute top-0 left-0 h-full';
            sceneEl.style.left = `calc(50% + ${startX}px)`;
            sceneEl.style.width = `${width}px`;
            
            // 创建横线（使用div和border样式）
            const lineEl = document.createElement('div');
            lineEl.className = 'w-full h-full flex items-center justify-center';
            
            // 创建一个更明显的横线
            const lineDiv = document.createElement('div');
            lineDiv.className = 'w-full border-t-2 border-purple-500';
            
            lineEl.appendChild(lineDiv);
            
            // 创建场景标签元素
            const labelEl = document.createElement('div');
            labelEl.className = 'absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-purple-500 text-white text-[10px] font-medium px-1.5 py-0.25 rounded whitespace-nowrap';
            labelEl.textContent = `场景${sceneIndex + 1}`;
            
            sceneEl.appendChild(lineEl);
            sceneEl.appendChild(labelEl);
            sceneContainer.value.appendChild(sceneEl);
          });
        };
        
        // 绘制分镜轨道
        const drawShotTrack = () => {
          if (!shotContainer.value) return;
          
          // 清空现有分镜
          shotContainer.value.innerHTML = '';
          
          // 按时间顺序对分镜进行排序，确保不重叠
          const sortedShots = [...timeline.value.shots].sort((a, b) => a.startTime - b.startTime);
          
          // 为了确保分镜不重叠，我们需要计算每个分镜的实际起始位置
          // 创建一个数组来存储每个分镜的实际位置信息
          const shotPositions = [];
          
          // 第一步：计算所有分镜的初始位置
          sortedShots.forEach((shot, index) => {
            // 计算分镜在轨道上的位置和宽度
            const startX = ((shot.startTime-currentTime.value) / 1000) * MARGIN * zoom.value;
            const width = ((shot.duration) / 1000) * MARGIN * zoom.value; // 秒数*MARGIN
            const endX = startX + width;
            //console.log('currentTime:',currentTime, currentTime.value, shot.startTime);
            shotPositions.push({
              shot,
              startX,
              width,
              endX,
              originalStartX: startX
            });
          });
          // console.log('所有分镜坐标信息：',shotPositions);
          // 第二步：检查并修复重叠
          // for (let i = 1; i < shotPositions.length; i++) {
          //   const current = shotPositions[i];
          //   const previous = shotPositions[i - 1];
            
          //   // 如果当前分镜的起始位置早于前一个分镜的结束位置，则发生重叠
          //   if (current.startX < previous.endX) {
          //     // 调整当前分镜的位置以避免重叠
          //     current.startX = previous.endX;
          //     current.endX = current.startX + current.width;
          //   }
          // }
          //console.log('修正分镜坐标信息>：',shotPositions);

          // 第三步：创建并渲染所有分镜元素
          shotPositions.forEach((pos) => {
            const shot = pos.shot;
            
            // 创建分镜元素
            const shotEl = document.createElement('div');
            // 当时间指针在分镜范围内时，应用与鼠标悬停相同的效果
            // 当时间指针在分镜范围内且分镜被选中时，额外添加蒙层效果
            // 使用严格的时间范围判断
            const shotEndTime = shot.startTime + shot.duration;
            const isTimeInShot = currentTime.value >= shot.startTime && currentTime.value < shotEndTime;
            //console.log(`分镜${shot.id}: currentTime=${currentTime.value}, startTime=${shot.startTime}, endTime=${shotEndTime}, isTimeInShot=${isTimeInShot}`);
            let shotClasses = 'shot-item';
            
            // 清除所有内联样式
            shotEl.removeAttribute('style');
            
            if (isTimeInShot) {
              // 当时间指针指向分镜时，添加高亮效果类
              shotClasses = 'shot-item time-pointer-active';
              
              if (selectedShotId.value === shot.id) {
                shotClasses += ' editing-breathing-bg';
              }
            }
            
            shotEl.className = shotClasses;
            shotEl.style.left = `calc(50% + ${pos.startX}px)`;
            shotEl.style.width = `${pos.width}px`; // 使用第一步计算好的宽度，已经是秒数*10px
            
            // 添加分镜时间信息
            const shotDuration = shot.duration / 1000;
            const startTimeFormatted = formatTime(shot.startTime);
            const endTimeFormatted = formatTime(shot.startTime + shot.duration);
            
            shotEl.innerHTML = `
              <div class="shot-header p-0 text-white rounded-sm flex justify-between items-start">
                <span class="text-[10px] -ml-0.5 -mt-1 bg-black/70 px-1 rounded">分镜${shot.id.replace('shot', '')}</span>
                <span class="text-xs -mt-1 bg-black/50 px-1 rounded">${shotDuration}s</span>
              </div>
              <div class="shot-time-info text-xs text-white p-1 rounded-sm mt-1">
                
              </div>
            `;

            //  开始时间-结束时间
            /* ${startTimeFormatted} - ${endTimeFormatted} */
            
            // 确保背景图正确显示
            shotEl.style.backgroundImage = `url(${shot.background})`;
            shotEl.style.backgroundSize = 'cover';
            shotEl.style.backgroundPosition = 'center';
            
            // 添加点击事件以选中分镜
            shotEl.addEventListener('click', (e) => {
              e.stopPropagation();
              selectedShotId.value = shot.id;
              selectedRoleId.value = null; // 选中分镜时取消角色选中
            });
            
            shotContainer.value.appendChild(shotEl);
          });
        };
        
        // 表情片段拖拽状态变量
        let isDraggingExpEdge = false;
        let draggedExpTrack = null;
        let dragEdgeType = null;
        let draggingExpCurrentScene = null; // 'left' 或 'right'
        let lastMouseX = 0;

        // 绘制角色表情轨道
        const drawExpressionTracks = () => {
          
          //console.log('开始绘制表情轨道...');
          
          // 首先清空所有表情容器，确保没有残留的表情片段
          for (const roleId in expressionContainers.value) {
            if (expressionContainers.value[roleId]) {
              expressionContainers.value[roleId].innerHTML = '';
            }
          }
          
          // 根据筛选状态决定要绘制的角色列表
          let rolesToDraw = [];
          if (showAllRoleExpressions.value) {
            // 选中状态：绘制所有角色的表情轨道
            rolesToDraw = timeline.value.roles;
          } else {

            if (selectedRoleId.value) {
              console.log('选中角色：', selectedRoleId.value);
              rolesToDraw = timeline.value.roles.filter(role => role.id === selectedRoleId.value);
            }
          }
          
          rolesToDraw.forEach(role => {
            const container = expressionContainers.value[role.id];
            const track = expressionTracks.value[role.id];
            
            if (!container) {
              console.warn(`can't find role container: ${role.id}`);
              return;
            }
            
            if (!track) {
              console.warn(`can't find role track: ${role.id}`);
              return;
            }
            
            //console.log(`处理角色: ${role.id} (${role.name})`);
            
            // 找到该角色的所有表情轨道
            const expressions = timeline.value.expressionTracks.filter(
              track => track.roleId === role.id
            );
            
            //console.log(`${role.name}找到 ${expressions.length} 个表情片段`);
            
            expressions.forEach(exp => {
              // 计算表情片段在轨道上的位置和宽度
              const startX = ((exp.startTime - currentTime.value) / 1000) * MARGIN * zoom.value;
              const width = ((exp.endTime - exp.startTime) / 1000) * MARGIN * zoom.value; // 秒数*MARGIN
              if (role.id == 'role2' && exp.expressionId === 'exp2-2') {
                // console.trace(`表情片段: ${exp.id}, 宽度: ${width}`);
              }
              
              // 找到对应的表情，添加安全检查
              const expression = role.expressions.find(e => e && e.id === exp.expressionId);
              if (!expression) return;
              
              // 确保表情轨道有唯一ID
              if (!exp.id) {
                exp.id = `track_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              }
              
              // 创建表情片段元素
              const expEl = document.createElement('div');
              expEl.className = 'expression-item';
              expEl.style.left = `calc(50% + ${startX}px)`;
              expEl.style.top = '0'; // 明确设置Y坐标为0，确保所有表情从轨道顶部开始
              expEl.style.width = `${width}px`;
              expEl.style.maxWidth = `${width}px`; // 限制最大宽度
              expEl.textContent = expression.name;
              expEl.dataset.trackId = exp.id;
              expEl.dataset.roleId = role.id;
              expEl.style.position = 'absolute'; // 使用绝对定位确保正确定位
              expEl.style.zIndex = '1';
              expEl.style.backgroundColor = 'rgba(74, 222, 128, 0.2)';
              expEl.style.border = '1px solid rgba(0, 0, 0, 0.1)';
              // 处理文本溢出
              expEl.style.overflow = 'hidden';
              expEl.style.textOverflow = 'clip';
              expEl.style.whiteSpace = 'nowrap';
              expEl.style.fontSize = '10px'; // 减小字体大小以适应窄元素
              expEl.style.lineHeight = '1'; // 调整行高
              
              // 添加左右边缘拖拽句柄
              const leftHandle = document.createElement('div');
              leftHandle.className = 'expression-handle expression-handle-left';
              leftHandle.style.position = 'absolute';
              leftHandle.style.left = '0';
              leftHandle.style.top = '0';
              leftHandle.style.width = '3px';
              leftHandle.style.height = '100%';
              leftHandle.style.cursor = 'w-resize';
              leftHandle.style.backgroundColor = 'rgba(59, 130, 246, 0.5)';
              leftHandle.dataset.trackId = exp.id;
              leftHandle.dataset.edgeType = 'left';
              leftHandle.dataset.roleId = role.id;
              
              const rightHandle = document.createElement('div');
              rightHandle.className = 'expression-handle expression-handle-right';
              rightHandle.style.position = 'absolute';
              rightHandle.style.right = '0';
              rightHandle.style.top = '0';
              rightHandle.style.width = '3px';
              rightHandle.style.height = '100%';
              rightHandle.style.cursor = 'e-resize';
              rightHandle.style.backgroundColor = 'rgba(59, 130, 246, 0.5)';
              rightHandle.dataset.trackId = exp.id;
              rightHandle.dataset.edgeType = 'right';
              rightHandle.dataset.roleId = role.id;
              
              expEl.appendChild(leftHandle);
              expEl.appendChild(rightHandle);
              
              // 检查是否为带运动轨迹的表情（x,y与x1,y1不同）
              if (exp.x1 !== undefined && exp.y1 !== undefined && 
                  (exp.x !== exp.x1 || exp.y !== exp.y1)) {
                // 创建运动轨迹标记元素
                const trackMarker = document.createElement('div');
                trackMarker.className = 'expression-track-marker';
                trackMarker.style.position = 'absolute';
                trackMarker.style.top = '80%';
                trackMarker.style.transform = 'translateY(-50%)';
                trackMarker.style.left = '10%';
                trackMarker.style.width = '80%';
                trackMarker.style.height = '1px';
                trackMarker.style.backgroundColor = '#3B82F6';
                trackMarker.style.display = 'flex';
                trackMarker.style.alignItems = 'center';
                trackMarker.style.justifyContent = 'flex-end';
                
                // 添加向右的箭头符号
                const arrow = document.createElement('span');
                arrow.textContent = '>';
                arrow.style.color = '#3B82F6';
                arrow.style.fontSize = '8px';
                arrow.style.marginLeft = '2px';
                arrow.style.marginTop = '-2px';
                
                trackMarker.appendChild(arrow);
                expEl.appendChild(trackMarker);
              }
              
              // 确保添加到正确的容器
              // console.log(`  添加表情片段: ${exp.id} (${expression.name}) 到角色: ${role.id} (${role.name})`);
              container.appendChild(expEl);
            });
          });
          
          //console.log('表情轨道绘制完成');
        };

        // 添加表情片段边缘拖拽事件监听
        document.addEventListener('mousedown', (e) => {
          if ((e.button === 0) && e.target.classList.contains('expression-handle')) {
            e.stopPropagation();
            stopPlayback();
            
            const trackId = e.target.dataset.trackId;
            dragEdgeType = e.target.dataset.edgeType;
            
            // 获取当前点击的角色ID
            const roleId = e.target.dataset.roleId;
            
            // 找到对应的表情轨道 - 优先通过ID匹配
            draggedExpTrack = timeline.value.expressionTracks.find(track => 
              track.id && track.id === trackId
            );
            
            // 如果通过ID没有找到，再通过角色ID和位置进行近似匹配
            if (!draggedExpTrack && roleId) {
              const expItem = e.target.closest('.expression-item');
              if (expItem) {
                // 尝试解析left样式
                const leftStyle = expItem.style.left;
                let parsedLeft = 0;
                try {
                  // 处理calc()表达式或直接像素值
                  if (leftStyle.includes('calc')) {
                    // 简化处理：提取calc中的数值部分
                    const match = leftStyle.match(/calc\(50%\s*([+-])\s*(\d+)px\)/);
                    if (match) {
                      const sign = match[1];
                      const value = parseInt(match[2]);
                      parsedLeft = sign === '+' ? value : -value;
                    }
                  } else {
                    parsedLeft = parseInt(leftStyle);
                  }
                } catch (error) {
                  console.error('解析left样式失败:', error);
                }
                
                // 查找最接近的轨道
                const positionThreshold = 20; // 增大阈值以提高匹配成功率
                draggedExpTrack = timeline.value.expressionTracks.find(track => 
                  track.roleId === roleId &&
                  Math.abs(((track.startTime-currentTime.value) / 1000) * MARGIN * zoom.value - parsedLeft) < positionThreshold
                );
              }
            }
            
            if (draggedExpTrack) {
              isDraggingExpEdge = true;
              console.log(`isDraggingExpEdge = true`);
              lastMouseX = e.clientX;
            }
          }
        });
        
        // 为表情元素添加右键菜单功能
        const setupExpressionRightClickMenu = () => {
          // 创建右键菜单元素
          let contextMenu = document.getElementById('expression-context-menu');
          if (!contextMenu) {
            contextMenu = document.createElement('div');
            contextMenu.id = 'expression-context-menu';
            contextMenu.style.cssText = `
              display: none;
              position: fixed;
              background: white;
              border: 1px solid #ccc;
              border-radius: 4px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.2);
              z-index: 1000;
              min-width: 160px;
              padding: 4px 0;
              font-size: 14px;
            `;
            
            // 创建菜单项
            const menuItems = [
              { id: 'set-start', text: '设置开始位置' },
              { id: 'set-end', text: '设置结束位置' },
              { id: 'fix-start', text: '固定开始位置' },
              { id: 'scene-start', text: '开始时间同场景开始' },
              { id: 'scene-end', text: '结束时间同场景结束' }
            ];
            
            menuItems.forEach(item => {
              const menuItem = document.createElement('div');
              menuItem.id = `menu-${item.id}`;
              menuItem.textContent = item.text;
              menuItem.style.cssText = `
                padding: 8px 16px;
                cursor: pointer;
                white-space: nowrap;
              `;
              
              menuItem.addEventListener('mouseover', () => {
                menuItem.style.backgroundColor = '#f0f0f0';
              });
              
              menuItem.addEventListener('mouseout', () => {
                menuItem.style.backgroundColor = 'transparent';
              });
              
              menuItem.addEventListener('click', (e) => {
                e.stopPropagation();
                const expItem = document.querySelector('.context-menu-active');
                if (expItem) {
                  const trackId = expItem.dataset.trackId;
                  const roleId = expItem.dataset.roleId;
                  handleContextMenuAction(item.id, trackId, roleId);
                }
                hideContextMenu();
              });
              
              contextMenu.appendChild(menuItem);
            });
            
            document.body.appendChild(contextMenu);
          }
          
          // 显示右键菜单
          const showContextMenu = (e, element) => {
            const menu = document.getElementById('expression-context-menu');
            menu.style.top = e.clientY + 'px';
            menu.style.left = e.clientX + 'px';
            menu.style.display = 'block';
            
            // 添加激活状态类
            element.classList.add('context-menu-active');
          };
          
          // 隐藏右键菜单
          const hideContextMenu = () => {
            const menu = document.getElementById('expression-context-menu');
            menu.style.display = 'none';
            
            // 移除所有元素的激活状态
            document.querySelectorAll('.context-menu-active').forEach(el => {
              el.classList.remove('context-menu-active');
            });
          };
          
          // 处理菜单项点击事件
          const handleContextMenuAction = (action, trackId, roleId) => {
            // 找到对应的表情轨道
            const expTrack = timeline.value.expressionTracks.find(track => track.id === trackId);
            if (!expTrack) return;
            
            switch (action) {
              case 'set-start':
                // 设置开始位置为当前时间
                currentTime.value = expTrack.startTime;
                //console.log(`设置表情开始位置: ${trackId}, 时间: ${currentTime.value}`);
                renderFrame();
                break;
              case 'set-end':
                // 设置结束位置为当前时间
                currentTime.value = expTrack.endTime-1;
                console.log(`设置表情结束位置: ${trackId}, 时间: ${currentTime.value}`);
                renderFrame();
                break;
              case 'fix-start':
                // 固定开始位置（这里可以添加额外的逻辑，比如锁定开始位置防止拖动）
                expTrack.endTime=expTrack.startTime;
                renderFrame();

                break;
              case 'scene-start':
                // 开始时间同场景开始
                // 找到表情所在的场景
                const containingScene = timeline.value.scenes.find(scene => {
                  const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                  if (sceneShots.length === 0) return false;
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneStartTime = sortedShots[0].startTime;
                  const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
                  // 检查表情轨道是否在该场景时间范围内
                  return expTrack.startTime >= sceneStartTime && expTrack.startTime <= sceneEndTime;
                });
                if (containingScene) {
                  const sceneShots = timeline.value.shots.filter(shot => containingScene.shots.includes(shot.id));
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneStartTime = sortedShots[0].startTime;
                  expTrack.startTime = sceneStartTime;
                  console.log(`设置表情开始时间为场景开始: ${trackId}, 时间: ${sceneStartTime}`);
                  renderFrame();
                }
                break;
              case 'scene-end':
                // 结束时间同场景结束
                // 找到表情所在的场景
                const containingSceneEnd = timeline.value.scenes.find(scene => {
                  const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
                  if (sceneShots.length === 0) return false;
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneStartTime = sortedShots[0].startTime;
                  const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
                  // 检查表情轨道是否在该场景时间范围内
                  return expTrack.endTime >= sceneStartTime && expTrack.endTime <= sceneEndTime;
                });
                if (containingSceneEnd) {
                  const sceneShots = timeline.value.shots.filter(shot => containingSceneEnd.shots.includes(shot.id));
                  const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
                  const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
                  expTrack.endTime = sceneEndTime;
                  console.log(`设置表情结束时间为场景结束: ${trackId}, 时间: ${sceneEndTime}`);
                  renderFrame();
                }
                break;
            }
            
            // 更新显示
            updateTimelineDisplay();
            renderFrame();
          };
          
          // 为所有现有的表情元素添加右键菜单事件
          const addRightClickListeners = () => {
            document.querySelectorAll('.expression-item').forEach(item => {
              // 屏蔽浏览器右键菜单
              item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e, item);
              });
            });
          };
          
          // 监听点击其他区域隐藏右键菜单
          document.addEventListener('click', (e) => {
            const menu = document.getElementById('expression-context-menu');
            if (menu && menu.style.display === 'block' && 
                !menu.contains(e.target) && 
                !e.target.classList.contains('expression-item')) {
              hideContextMenu();
            }
          });
          
          // 监听drawExpressionTracks完成后的事件，为新创建的表情元素添加右键菜单
          // 创建一个包装器，不直接修改原函数
          const originalDrawExpressionTracks = drawExpressionTracks;
          const wrappedDrawExpressionTracks = function() {
            const result = originalDrawExpressionTracks.apply(this, arguments);
            // 延迟添加监听器，确保元素已完全渲染
            setTimeout(addRightClickListeners, 10);
            return result;
          };
          
          // 替换Vue实例中的方法引用
          if (typeof window !== 'undefined' && window.Vue && Vue._apps && Vue._apps[0]) {
            try {
              const app = Vue._apps[0];
              if (app._instance && app._instance.proxy) {
                // 在应用实例上注册我们的包装函数
                app._instance.proxy.wrappedDrawExpressionTracks = wrappedDrawExpressionTracks;
              }
            } catch (error) {
              console.warn('无法在Vue实例上注册包装函数:', error);
            }
          }
          
          // 额外添加定期检查的机制，确保新创建的元素也能被监听
          setInterval(() => {
            const newExpItems = document.querySelectorAll('.expression-item:not([data-right-click-bound])');
            if (newExpItems.length > 0) {
              newExpItems.forEach(item => {
                // 屏蔽浏览器右键菜单
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  showContextMenu(e, item);
                });
                // 标记为已绑定事件
                item.setAttribute('data-right-click-bound', 'true');
              });
            }
          }, 1000);
          
          // 初始添加监听器
          addRightClickListeners();
        };
        
        // 初始化表情右键菜单功能
        setupExpressionRightClickMenu();
        
        document.addEventListener('mousemove', (e) => {
          if (isDraggingExpEdge && draggedExpTrack) {
            
            const deltaX = e.clientX - lastMouseX;
            lastMouseX = e.clientX;
            
            // 计算时间变化 (像素差 -> 时间差)
            const timeDelta = (deltaX / MARGIN / zoom.value) * 1000;
            
            // 重叠检测函数 - 允许表情轨道相邻（新开始时间等于其他轨道结束时间或新结束时间等于其他轨道开始时间视为不重叠）
            const checkOverlap = (newStartTime, newEndTime) => {
              // 获取同角色的其他表情轨道
              const otherExpressions = timeline.value.expressionTracks.filter(
                track => track.roleId === draggedExpTrack.roleId && track.id !== draggedExpTrack.id
              );
              
              // 检查是否与任何其他表情轨道重c叠
              for (const exp of otherExpressions) {
                // 如果新的时间范围与其他表情轨道有重叠，则返回true
                // 允许轨道相邻：newEndTime <= exp.startTime 或 newStartTime >= exp.endTime 视为不重叠
                if (!(newEndTime <= exp.startTime || newStartTime >= exp.endTime)) {
                  console.log(`重叠:${exp}`)
                  return true;
                }
              }
              return false;
            };

            // 添加小的时间间隔（10毫秒）来解决浮点数精度问题
            const TIME_GAP = 10;


            const MIN_EXP_DURATION = 700; //表情最小持续时间

            // 找到表情轨道所在的场景
            let containingScene = timeline.value.scenes.find(scene => {
              const sceneShots = timeline.value.shots.filter(shot => scene.shots.includes(shot.id));
              if (sceneShots.length === 0) return false;
              const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
              const sceneStartTime = sortedShots[0].startTime;
              const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
              // 检查表情轨道是否在该场景时间范围内, 不能
              return draggedExpTrack.startTime >= sceneStartTime && draggedExpTrack.startTime < sceneEndTime-100 || 
                     draggedExpTrack.endTime >= sceneStartTime+100 && draggedExpTrack.endTime <= sceneEndTime;
            });

            if (containingScene) {

              if(draggingExpCurrentScene === null){
                draggingExpCurrentScene = containingScene;
              }else if(draggingExpCurrentScene.id !== containingScene.id){
                // console.log('表情轨道所在场景发生了变化')
                //表情轨道所在场景发生了变化，不允许变化，只能在同一场景中设置
                containingScene = draggingExpCurrentScene;
              }
              // 定义场景的开始时间和结束时间
              const sceneShots = timeline.value.shots.filter(shot => containingScene.shots.includes(shot.id));
              const sortedShots = [...sceneShots].sort((a, b) => a.startTime - b.startTime);
              const sceneStartTime = sortedShots[0].startTime;
              const sceneEndTime = Math.max(...sortedShots.map(shot => shot.startTime + shot.duration));
              
              if (dragEdgeType === 'left') {
                
                // 左边拖拽：修改开始时间，结束时间不变
                // 限制在场景开始时间和场景结束时间 - 最小持续时间之间
                // draggedExpTrack.startTime= Math.max(sceneStartTime, draggedExpTrack.startTime + timeDelta)
                let newStartTime = Math.max(sceneStartTime, 
                                              Math.min(sceneEndTime - MIN_EXP_DURATION, 
                                                       draggedExpTrack.startTime + timeDelta));
                
                //console.log(`左边拖拽：修改开始时间2- newStartTime=${newStartTime}, sceneStartTime=${sceneStartTime},sceneEndTime=${sceneEndTime}, MIN_EXP_DURATION=${MIN_EXP_DURATION}, draggedExpTrack.startTime=${draggedExpTrack.startTime}, timeDelta=${timeDelta}`)
                // 修复两个表情紧挨着时无法调整第二个表情开始时间的问题
                // 使用TIME_GAP来解决浮点数精度问题
                if (newStartTime < draggedExpTrack.endTime - MIN_EXP_DURATION + TIME_GAP) { // 确保有最小持续时间
                  // console.log('左边拖拽：修改开始时间3-'+newStartTime)
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(newStartTime, draggedExpTrack.endTime)) {
                    // console.log('左边拖拽：修改开始时间4 设置成功 -'+newStartTime)
                    draggedExpTrack.startTime = newStartTime;
                  }else{
                    // console.log('左边拖拽：修改开始时间5-'+newStartTime)
                  }
                }
              } else if (dragEdgeType === 'right') {
                // 右边拖拽：修改结束时间，开始时间不变
                // 限制在场景开始时间 + 最小持续时间和场景结束时间之间
                const newEndTime = Math.max(sceneStartTime + MIN_EXP_DURATION, 
                                            Math.min(sceneEndTime, 
                                                     draggedExpTrack.endTime + timeDelta));
                if (newEndTime > draggedExpTrack.startTime + MIN_EXP_DURATION) { // 确保有最小持续时间
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(draggedExpTrack.startTime, newEndTime)) {
                    draggedExpTrack.endTime = newEndTime;
                  }
                }
              }
            } else {
              // 如果没有找到所属场景，保持原有逻辑
              if (dragEdgeType === 'left') {
                // console.log('左边拖拽：修改开始时间')
                // 左边拖拽：修改开始时间，结束时间不变
                const newStartTime = Math.max(0, draggedExpTrack.startTime + timeDelta);
                // 修复两个表情紧挨着时无法调整第二个表情开始时间的问题
                // 使用TIME_GAP来解决浮点数精度问题
                if (newStartTime < draggedExpTrack.endTime - MIN_EXP_DURATION + TIME_GAP) { // 确保有最小持续时间
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(newStartTime, draggedExpTrack.endTime)) {
                    draggedExpTrack.startTime = newStartTime;
                  }
                }
              } else if (dragEdgeType === 'right') {
                // 右边拖拽：修改结束时间，开始时间不变
                const newEndTime = Math.min(totalDuration.value, draggedExpTrack.endTime + timeDelta);
                if (newEndTime > draggedExpTrack.startTime + MIN_EXP_DURATION) { // 确保有最小持续时间
                  // 检查是否与其他表情重叠
                  if (!checkOverlap(draggedExpTrack.startTime, newEndTime)) {
                    draggedExpTrack.endTime = newEndTime;
                  }
                }
              }
            }
            
            updateTimelineDisplay();
            renderFrame();
          }
        });

        document.addEventListener('mouseup', () => {
          if (isDraggingExpEdge && draggedExpTrack) {
            isDraggingExpEdge = false;
            
            // 打印修改后的表情对象JSON数据
            const expressionObject = {
              roleId: draggedExpTrack.roleId,
              startTime: draggedExpTrack.startTime,
              endTime: draggedExpTrack.endTime,
              expressionId: draggedExpTrack.expressionId,
              x: draggedExpTrack.x,
              y: draggedExpTrack.y
            };
            
            console.log('表情调整后的数据:', JSON.stringify(expressionObject, null, 2));
            
            draggingExpCurrentScene = null;
            draggedExpTrack = null;
            dragEdgeType = null;
          }
        });
        
        // 更新时间轴显示
        const updateTimelineDisplay = () => {
          drawTimeMarkers();
          drawShotTrack();
          drawSceneTrack();
          drawExpressionTracks();
          
          // 自动滚动到当前时间点，但添加边界检查避免滚动到不合理的位置
          const container = document.querySelector('.overflow-x-auto');
          const scrollPosition = Math.max(0, Math.min(
            (currentTime.value / 1000) * zoom.value + 20 - markerPosition.value,
            timelineWidth.value - container.clientWidth
          ));
          container.scrollLeft = scrollPosition;
        };
        
        // 渲染当前帧
        // 渲染当前帧 - 采用分层绘制逻辑
        const renderFrame = () => {
            // 1. 前置检查
            if (!canvas.value || !ctx.value || !offscreenCanvas || !offscreenCtx) {
              debugInfo.value = `Canvas or context invalid: canvas=${!!canvas.value}, ctx=${!!ctx.value}`;
              return;
            }
            
            // 添加调试信息，显示当前渲染状态
            debugInfo.value = `render frame: ${formatTime(currentTime.value)}, play=${isPlaying.value}, FPS=${fps.value}, canvas size=${canvas.value.width}x${canvas.value.height}`;
            
            // 2. 清空离屏画布
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
          
            // 3. 找到当前分镜
            const currentShot = timeline.value.shots.find(shot => 
              currentTime.value >= shot.startTime && 
              currentTime.value < shot.startTime + shot.duration
            );
            
            // 4. 绘制底层背景
            // 设置基础背景色
            offscreenCtx.fillStyle = '#f0f0f0';
            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            
            // 如果有当前分镜，绘制分镜背景
            let isBackgroundDrawn = false;
            if (currentShot) {
              // 绘制分镜背景层
              isBackgroundDrawn = drawBackgroundLayer(currentShot);
            } else if(currentTime.value >= totalDuration.value){
              // 如果没有当前分镜，尝试使用最后一个分镜的背景图
              // 找到最后一个分镜
              const lastShot = timeline.value.shots.length > 0 ? 
                timeline.value.shots.reduce((last, current) => 
                  (current.startTime > last.startTime) ? current : last
                ) : null;
              
              if (lastShot) {
                // 使用最后一个分镜的背景作为底层
                const cachedImage = bgImagesCache.value[lastShot.background];
                if (cachedImage) {
                  offscreenCtx.drawImage(cachedImage, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
                  isBackgroundDrawn = true;
                }
              }
            }
            
            // 保存当前状态，准备应用坐标系变换
            offscreenCtx.save();
            
            // 应用坐标系变换：将原点从左上角移到左下角，并翻转Y轴
            offscreenCtx.translate(0, offscreenCanvas.height);
            offscreenCtx.scale(1, -1);
            
            // 5. 绘制角色层（中间层）
            drawRoles();
            
            // 恢复原始坐标系状态
            offscreenCtx.restore();
            
            // 6. 绘制上层信息（FPS等）
            drawTopLayerInfo();
            
            // 7. 将离屏Canvas内容复制到可见Canvas（顶层合成）
            ctx.value.drawImage(offscreenCanvas, 0, 0);
            
            // 8. 为异步加载场景提供备用渲染
            if (currentShot && !isBackgroundDrawn) {
              // 对于正在加载的图片，设置备用渲染
              setupAsyncRenderFallback(currentShot);
            }
        };
        
        // 绘制背景层
        const drawBackgroundLayer = (shot) => {
          const cachedImage = bgImagesCache.value[shot.background];
          
          if (cachedImage) {
            // 图片已预加载完成，直接绘制
            offscreenCtx.drawImage(cachedImage, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
            return true;
          } else if (cachedImage === null) {
            // 图片已标记为加载失败，绘制备用背景
            drawErrorBackground();
            return true;
          } else {
            // 图片未加载完成，需要异步处理
            return false;
          }
        };
        
        // 绘制错误背景
        const drawErrorBackground = () => {
          const gradient = offscreenCtx.createLinearGradient(0, 0, offscreenCanvas.width, offscreenCanvas.height);
          gradient.addColorStop(0, '#4a5568');
          gradient.addColorStop(1, '#2d3748');
          offscreenCtx.fillStyle = gradient;
          offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
          offscreenCtx.fillStyle = '#cbd5e0';
          offscreenCtx.font = '16px Arial';
          offscreenCtx.textAlign = 'center';
          offscreenCtx.fillText('背景图加载失败', offscreenCanvas.width/2, offscreenCanvas.height/2);
        };
        
        // 绘制顶层信息
        const drawTopLayerInfo = () => {
          // 在左上角显示FPS信息
          offscreenCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          offscreenCtx.fillRect(10, 10, 60, 25);
          offscreenCtx.fillStyle = '#ffffff';
          offscreenCtx.font = '14px Arial';
          offscreenCtx.textAlign = 'left';
          offscreenCtx.fillText(`FPS: ${fps.value}`, 15, 28);
        };
        
        // 设置异步渲染备用方案
        const setupAsyncRenderFallback = (shot) => {
          // 异步临时加载背景
          loadImageWithCORS(
            shot.background,
            (bgImg) => {
              console.log('async load bg-success: ' + shot.background);
              // 直接调用renderFrame函数进行完整重绘
              renderFrame();
            },
            () => {
              console.error('async load bg-error: ' + shot.background);
              debugInfo.value = 'load bg error: ' + shot.background;
              bgImagesCache.value[shot.background] = null; // 标记为加载失败
              // 直接调用renderFrame函数进行完整重绘
              renderFrame();
            }
          );
          
          // 立即渲染角色的备用图形，避免图片加载时的空白期
          // 注意：不直接使用renderFrame，因为它会调用setupAsyncRenderFallback导致循环调用
          // drawImmediateFallback是专门设计的轻量级快速渲染函数
          const drawImmediateFallback = () => {
            // 更全面的前置检查，与renderFrame保持一致
            if (!canvas.value || !ctx.value || !offscreenCanvas || !offscreenCtx) {
              console.warn('Canvas not init，skip');
              return;
            }
            
            try {
              // 清空画布并重新绘制当前状态
              offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
              
              // 重绘基础背景
              offscreenCtx.fillStyle = '#f0f0f0';
              offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
              
              // 重绘中间层
              drawRoles();
              
              // 重绘顶层
              drawTopLayerInfo();
              
              // 合成并显示
              ctx.value.drawImage(offscreenCanvas, 0, 0);
            } catch (error) {
              console.error('render backup image error:', error);
            }
          };
          
          // 立即执行一次，确保用户看到内容
          drawImmediateFallback();
          
          // 添加小延迟后再次执行，确保在DOM更新后有更好的渲染效果
          //setTimeout(drawImmediateFallback, 50);
        };
        
        // 图像缓存，提高播放时的渲染性能
        const imageCache = {};
        
        // 角色表情管理类，负责管理表情数据存储、播放控制、点击检测和绘制
        class RoleExpressionManager {
          constructor() {
            // 存储表情数据缓存
            this.expressionCache = {};
            // 存储每个角色的播放状态
            this.roleStates = {};
            // 存储最后一帧的时间戳
            this.lastFrameTime = {};
            // 配置项
            this.config = {
              roleWidth: 100,
              roleHeight: 150,
              roleColors: {
                'role1': '#3B82F6', // 蓝色
                'role2': '#10B981', // 绿色
                'role3': '#8B5CF6'  // 紫色
              },
              defaultColor: '#6B7280' // 默认灰色
            };
          }
          
          // 初始化表情数据
          init(roles, expressionTracks) {
            // 构建表情缓存
            roles.forEach(role => {
              if (role.expressions) {
                role.expressions.forEach(expr => {
                  if (expr && expr.id) {
                    this.expressionCache[expr.id] = expr;
                  }
                });
              }
            });
          }
          
          // 获取表情数据
          getExpression(expressionId) {
            return this.expressionCache[expressionId];
          }
          
          // 更新角色表情状态
          updateRoleState(roleId, currentExpression, frameInterval, currentTime) {
            if (!this.roleStates[roleId]) {
              this.roleStates[roleId] = {
                expressionId: null,
                currentFrameIndex: 0,
                startTime: currentTime // 使用当前时间轴时间作为起始时间
              };
            }
            
            const state = this.roleStates[roleId];
            
            // 如果表情发生变化，重置状态
            if (state.expressionId !== currentExpression.id) {
              state.expressionId = currentExpression.id;
              state.currentFrameIndex = 0;
              state.startTime = currentTime; // 使用当前时间轴时间作为起始时间
            }
            
            // 基于时间轴时间计算经过的时间，而不是系统时间
            const elapsed = currentTime - state.startTime;
            
            // 计算应该显示的帧索引，确保与时间轴指针同步
            // 使用 Math.floor 确保整数帧索引
            const expectedFrameIndex = Math.floor(elapsed / frameInterval) % currentExpression.frames.length;
            state.currentFrameIndex = expectedFrameIndex;
            
            return state.currentFrameIndex;
          }
          
          // 获取指定角色的当前帧索引
          getCurrentFrameIndex(roleId) {
            if (!this.roleStates[roleId]) {
              return 0;
            }
            
            return this.roleStates[roleId].currentFrameIndex;
          }
          
          // 获取指定角色的当前帧图片
          getCurrentFrame(roleId, currentExpression) {
            if (!this.roleStates[roleId] || !currentExpression || !currentExpression.frames || currentExpression.frames.length === 0) {
              return null;
            }
            
            const state = this.roleStates[roleId];
            return currentExpression.frames[state.currentFrameIndex];
          }
          
          // 计算角色当前实际位置（基于时间的线性插值）
          calculateCurrentPosition(currentExpressionTrack, currentTime) {
            // 检查是否存在临时位置（拖拽过程中使用）
            if (currentExpressionTrack._tempX !== undefined && currentExpressionTrack._tempY !== undefined) {
              // 返回临时位置时，确保Y坐标在渲染坐标系中是正确的
              // 注意：这里不进行额外转换，因为拖拽时已经计算好了正确的坐标
              return { 
                x: currentExpressionTrack._tempX, 
                y: currentExpressionTrack._tempY, 
                width: currentExpressionTrack._tempWidth || this.config.roleWidth,
                height: currentExpressionTrack._tempHeight || this.config.roleHeight,
                angle: currentExpressionTrack._tempAngle || 0,
                isValid: true 
              };
            }
            
            // 获取当前时间点的场景级角色配置
            const sceneRoles = getSceneRolesByTime(currentTime);
            const roleConfig = sceneRoles ? sceneRoles.find(r => r.roleId === currentExpressionTrack.roleId) : null;
            
            // 计算当前表情位置（基于当前时间的线性插值）
            const duration = currentExpressionTrack.endTime - currentExpressionTrack.startTime;
            const elapsed = currentTime - currentExpressionTrack.startTime;
            const progress = Math.min(Math.max(elapsed / duration, 0), 1);
                
            // 获取结束位置，如果没有则使用开始位置
            let endX = currentExpressionTrack.x1;
            let endY = currentExpressionTrack.y1;
            if (endX === undefined) {
              endX = currentExpressionTrack.x;
            }
            if (endY === undefined) {
              endY = currentExpressionTrack.y;
            }
            
            // 线性插值计算当前位置
            const currentX = currentExpressionTrack.x + (endX - currentExpressionTrack.x) * progress;
            const currentY = currentExpressionTrack.y + (endY - currentExpressionTrack.y) * progress;
            
            // 检查坐标是否有效
            if (Number.isNaN(currentX) || Number.isNaN(currentY)) {
              return { 
                x: currentExpressionTrack.x, 
                y: currentExpressionTrack.y, 
                width: roleConfig?.width || this.config.roleWidth,
                height: roleConfig?.height || this.config.roleHeight,
                angle: roleConfig?.angle || 0,
                isValid: false 
              };
            }
            
            // 返回位置和场景配置中的尺寸和角度
            return { 
              x: currentX, 
              y: currentY, 
              width: roleConfig?.width || this.config.roleWidth,
              height: roleConfig?.height || this.config.roleHeight,
              angle: roleConfig?.angle || 0,
              isValid: true 
            };
          }
          
          // 检测角色点击
          checkRoleClick(x, y, roles, expressionTracks, currentTime) {
            // 遍历所有角色，检查点击位置是否在角色范围内
            const clickedRole = roles.find(role => {
              // 找到当前时间点该角色的表情轨道
              let currentExpressionTrack = expressionTracks.find(track => 
                track.roleId === role.id && 
                currentTime >= track.startTime && 
                currentTime < track.endTime
              );
              
              console.log('当前时间点的角色表情轨道:', currentExpressionTrack);
              // 如果没有找到，检查是否在最后一帧
              if (!currentExpressionTrack && currentTime >= totalDuration.value) {
                // 找到最后一个结束的轨道
                const lastTracks = expressionTracks  
                  .filter(track => track.roleId === role.id && track.endTime <= currentTime && track.endTime > currentTime-1)
                  .sort((a, b) => b.endTime - a.endTime);
                
                currentExpressionTrack = lastTracks.length > 0 ? lastTracks[0] : null;
              }
              
              if (!currentExpressionTrack) return false;
              
              // 使用calculateCurrentPosition方法获取当前实际位置
              const currentPosition = this.calculateCurrentPosition(currentExpressionTrack, currentTime);
              
              // 如果坐标计算无效，返回false
              if (!currentPosition.isValid) {
                console.log(`角色 ${role.name} 在时间点 ${currentTime} 位置计算无效`);
                return false;
              }
              
              const { currentX, currentY } = { currentX: currentPosition.x, currentY: currentPosition.y };
              
              // 检查点击是否在角色当前位置的区域内
              return x >= currentX && 
                     x <= currentX + this.config.roleWidth && 
                     y >= currentY && 
                     y <= currentY + this.config.roleHeight;
            });
            
            return clickedRole;
          }
          
          // 绘制角色表情
          drawRoleExpression(ctx, role, currentExpressionTrack, expression, imageCache) {
            if (!ctx || !role || !currentExpressionTrack || !expression) {
              return false;
            }
            
            try {
              // 获取当前帧索引
              const frameIndex = this.updateRoleState(role.id, expression, expression.frameInterval);
              
              // 检查是否有有效的表情帧
              if (!expression.frames || !expression.frames[frameIndex]) {
                return false;
              }
              
              // 获取图片URL
              const imageUrl = expression.frames[frameIndex];
              
              // 返回图片信息供外部加载和绘制
              return {
                imageUrl: imageUrl,
                x: currentExpressionTrack.x,
                y: currentExpressionTrack.y,
                width: this.config.roleWidth,
                height: this.config.roleHeight,
                role: role,
                expression: expression
              };
            } catch (error) {
              console.error(`绘制角色表情出错: ${error}`);
              return false;
            }
          }
          
          // 绘制角色选中状态
          drawRoleSelection(ctx, track, role) {
            if (!ctx || !track || !role) return;
            
            // 使用calculateCurrentPosition方法获取当前实际位置和尺寸
            // 注意：这里需要currentTime，但该方法没有传入，我们假设使用当前时间
            // 由于calculateCurrentPosition需要currentTime参数，但drawRoleSelection没有直接获取
            // 所以这里使用了全局的currentTime.value
            const currentPosition = this.calculateCurrentPosition(track, currentTime.value);
            
            const x = currentPosition.isValid ? currentPosition.x : track.x;
            const y = currentPosition.isValid ? currentPosition.y : track.y;
            const width = currentPosition.isValid ? currentPosition.width : this.config.roleWidth;
            const height = currentPosition.isValid ? currentPosition.height : this.config.roleHeight;
            
            // 绘制闪烁的黄色边框
            ctx.strokeStyle = '#EAB308';
            ctx.lineWidth = 8;
            
            // 绘制圆角矩形边框
            const radius = 10;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.stroke();
            
            // 重置线条样式
            ctx.setLineDash([]);
            
            // 保存当前状态，准备绘制表情名称标签
            ctx.save();
            
            // 绘制表情名称标签
            const expression = role.expressions.find(exp => exp && exp.id === track.expressionId);
            const expressionName = expression ? expression.name : '未知表情';
            
            // 计算文本宽度以正确设置背景
            ctx.font = '12px Arial';
            const textWidth = ctx.measureText(expressionName).width + 10;
            const textHeight = 20;
            const labelX = x + width / 2 - textWidth / 2;
            
            // 由于全局坐标系已经翻转，需要将Y坐标调整为在角色下方
            const labelY = y + height + 5;
            
            // 应用反向缩放，确保标签在翻转的坐标系中是正立的
            const centerX = labelX + textWidth / 2;
            const centerY = labelY + textHeight / 2;
            ctx.translate(centerX, centerY);
            ctx.scale(1, -1);
            ctx.translate(-centerX, -centerY);
            
            // 绘制标签背景
            ctx.fillStyle = '#10B981';
            ctx.beginPath();
            ctx.moveTo(labelX + 5, labelY);
            ctx.lineTo(labelX + textWidth - 5, labelY);
            ctx.quadraticCurveTo(labelX + textWidth, labelY, labelX + textWidth, labelY + 5);
            ctx.lineTo(labelX + textWidth, labelY + textHeight - 5);
            ctx.quadraticCurveTo(labelX + textWidth, labelY + textHeight, labelX + textWidth - 5, labelY + textHeight);
            ctx.lineTo(labelX + 5, labelY + textHeight);
            ctx.quadraticCurveTo(labelX, labelY + textHeight, labelX, labelY + textHeight - 5);
            ctx.lineTo(labelX, labelY + 5);
            ctx.quadraticCurveTo(labelX, labelY, labelX + 5, labelY);
            ctx.closePath();
            ctx.fill();
            
            // 绘制标签文本
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(expressionName, labelX + textWidth / 2, labelY + textHeight / 2);
            
            // 恢复原始状态
            ctx.restore();
          }
          
          // 绘制角色备用图形
          drawRolePlaceholder(ctx, track, role, highlight = false) {
            if (!ctx || !track || !role) return;
            
            // 保存当前状态，准备临时应用反向缩放以抵消全局翻转
            ctx.save();
            
            // 选择角色专属颜色
            const color = this.config.roleColors[role.id] || this.config.defaultColor;
            
            // 绘制一个更美观的备用图形
            ctx.fillStyle = highlight ? color : `${color}80`; // 透明度
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            
            // 尝试获取场景级角色配置
            const currentPosition = this.calculateCurrentPosition(track, currentTime.value);
            
            // 绘制圆角矩形
            const x = currentPosition.isValid ? currentPosition.x : track.x;
            const y = currentPosition.isValid ? currentPosition.y : track.y;
            const width = currentPosition.isValid ? currentPosition.width : this.config.roleWidth;
            const height = currentPosition.isValid ? currentPosition.height : this.config.roleHeight;
            const radius = 10;
            
            // 应用反向缩放，确保备用图形在翻转的坐标系中是正立的
            ctx.translate(x + width / 2, y + height / 2);
            ctx.scale(1, -1);
            ctx.translate(-(x + width / 2), -(y + height / 2));
            
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            
            ctx.fill();
            ctx.stroke();
            
            // 绘制角色图标
            ctx.fillStyle = 'white';
            ctx.font = 'bold 48px FontAwesome';
            ctx.textAlign = 'center';
            ctx.fillText(
              '\uf007', // 用户图标
              x + width/2, 
              y + height/2 + 15
            );
            
            // 恢复原始状态
            ctx.restore();
          }
          
  
        

          // 重置所有状态
          reset() {
            this.roleStates = {};
            this.lastFrameTime = {};
          }
          
          // 重置特定角色的状态
          resetRole(roleId) {
            if (this.roleStates[roleId]) {
              delete this.roleStates[roleId];
              delete this.lastFrameTime[roleId];
            }
          }

          // 绘制角色图片的具体实现
          drawRoleImage(ctx, role, currentExpressionTrack, expression, imageUrl, img, currentTime, selectedRoleId, isPlaying, imageCache) {
            if (!ctx || !role || !currentExpressionTrack || !expression) {
              return;
            }
            
            // 如果在播放状态且图片已缓存，则直接使用缓存图片
            if (img) {
              console.log('使用缓存图片: ' + imageUrl);
              try {
                // 使用calculateCurrentPosition方法获取当前实际位置和尺寸角度
                const currentPosition = this.calculateCurrentPosition(currentExpressionTrack, currentTime);
                
                // 如果坐标计算无效，返回
                if (!currentPosition.isValid) {
                  console.log(`${role.name} ${currentExpressionTrack.expressionId} ${expression.name} miss start/end pos`);
                  return;
                }
                
                const currentX = currentPosition.x;
                const currentY = currentPosition.y;
                const currentWidth = currentPosition.width;
                const currentHeight = currentPosition.height;
                const currentAngle = currentPosition.angle;
                
                
                // 保存当前状态，准备临时应用反向缩放以抵消全局翻转
                ctx.save();
                
                // 在角色绘制前应用反向缩放，确保图片在翻转的坐标系中是正立的
                ctx.translate(currentX + currentWidth / 2, currentY + currentHeight / 2);
                ctx.scale(1, -1);
                ctx.translate(-(currentX + currentWidth / 2), -(currentY + currentHeight / 2));
                
                // 如果有角度，应用旋转
                if (currentAngle && currentAngle !== 0) {
                  ctx.save();
                  ctx.translate(currentX + currentWidth / 2, currentY + currentHeight / 2);
                  ctx.rotate((currentAngle * Math.PI) / 180); // 转换为弧度
                  ctx.translate(-(currentX + currentWidth / 2), -(currentY + currentHeight / 2));
                }
                
                // 绘制角色图片
                ctx.drawImage(
                  img, 
                  currentX, 
                  currentY,
                  currentWidth, // 使用场景配置的宽度
                  currentHeight  // 使用场景配置的高度
                );
                
                // 如果应用了旋转，恢复状态
                if (currentAngle && currentAngle !== 0) {
                  ctx.restore();
                }
                
                // 恢复原始状态
                ctx.restore();

                // // 检查是否为带运动轨迹的表情（x,y与x1,y1不同）
                // if (currentExpressionTrack.x1 !== undefined && currentExpressionTrack.y1 !== undefined && 
                //     (currentExpressionTrack.x !== currentExpressionTrack.x1 || currentExpressionTrack.y !== currentExpressionTrack.y1)) {
                //     // 保存当前状态，准备绘制运动轨迹标记
                //     ctx.save();
                    
                //     // 绘制从左到右的横线
                //     ctx.strokeStyle = 'white';
                //     ctx.lineWidth = 2;
                //     ctx.beginPath();
                //     ctx.moveTo(currentX, currentY - 10);
                //     ctx.lineTo(currentX + this.config.roleWidth - 15, currentY - 10);
                //     ctx.stroke();
                    
                //     // 绘制向右的箭头
                //     ctx.fillStyle = 'white';
                //     ctx.font = '10px Arial';
                //     ctx.textAlign = 'center';
                //     ctx.textBaseline = 'middle';
                //     ctx.fillText('>', currentX + this.config.roleWidth - 8, currentY - 10);
                    
                //     // 恢复原始状态
                //     ctx.restore();
                // }

                // 保存当前状态，准备绘制角色名称
                ctx.save();
                
                // 不使用save/restore和缩放，直接在正确的位置绘制角色名称
                // 由于全局坐标系已经翻转，需要将Y坐标调整为在角色上方
                const nameY = currentY + currentHeight + 15;
                
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText(
                  role.name, 
                  currentX + currentWidth / 2, 
                  nameY
                );
                ctx.fillText(
                    role.name, 
                    currentX + currentWidth / 2, 
                    nameY
                  );
                  
                  // 恢复原始状态
                  ctx.restore();
              } catch (error) {
                console.error('绘制缓存图片时出错: ' + error);
                this.drawRolePlaceholder(ctx, currentExpressionTrack, role, true);
              }
            } else {
              // 使用统一的图片加载函数
              try {
                if (img === null || img === undefined) {
                  // 保存this上下文，以便在回调函数中使用
                  const self = this;
                  img = loadImageWithCORS(
                    imageUrl,
                    (loadedImg) => {
                      // 添加到缓存
                      //console.log('加载角色图片成功: ' + imageUrl);
                      imageCache[imageUrl] = loadedImg;
                      self.drawRoleImage(ctx, role, currentExpressionTrack, expression, imageUrl, loadedImg, currentTime, selectedRoleId, isPlaying, imageCache);
                    },
                    () => {
                      console.error('无法加载角色图片: ' + imageUrl);
                      debugInfo.value = '角色图片加载失败: ' + role.name;
                      // 最终失败时，确保备用图形清晰可见
                      self.drawRolePlaceholder(ctx, currentExpressionTrack, role, true);
                    }
                  );
                }
              } catch (error) {
                console.error('设置图片源时出错: ' + error);
                this.drawRolePlaceholder(ctx, currentExpressionTrack, role, true);
              }
            }

            // 在Canvas上绘制选中状态
            if (!isPlaying && selectedRoleId === role.id) {
              this.drawRoleSelection(ctx, currentExpressionTrack, role);
            }
          }
        }
        
        // 创建RoleExpressionManager实例
        const expressionManager = new RoleExpressionManager();
        
        // 绘制角色
        const drawRoles = () => {
          if (!offscreenCtx) {
            debugInfo.value = 'offscreenCtx null ';
            return;
          }
          
          // 确保总是绘制一些内容，即使没有角色
          if (timeline.value.roles.length === 0) {
            offscreenCtx.fillStyle = '#4a5568';
            offscreenCtx.font = '16px Arial';
            offscreenCtx.textAlign = 'center';
            offscreenCtx.fillText('无角色数据', offscreenCanvas.width/2, offscreenCanvas.height/2 + 30);
            return;
          }
          
          // 初始化角色表情管理器
          if (Object.keys(expressionManager.expressionCache).length === 0) {
            expressionManager.init(timeline.value.roles, timeline.value.expressionTracks);
          }
          
          timeline.value.roles.forEach(role => {
            // 找到当前时间点该角色的表情轨道
            let currentExpressionTrack = timeline.value.expressionTracks.find(track => 
              track.roleId === role.id && 
              currentTime.value >= track.startTime && 
              currentTime.value < track.endTime
            );
            
            // 如果没有找到，使用默认表情和最后位置
            if (!currentExpressionTrack && currentTime.value >= totalDuration.value) {
              // 找到最后一个结束的轨道
              const lastTracks = timeline.value.expressionTracks  
                .filter(track => track.roleId === role.id && track.endTime <= currentTime.value && track.endTime > currentTime.value-1)
                .sort((a, b) => b.endTime - a.endTime);
              
              currentExpressionTrack = lastTracks.length > 0 
                ? { ...lastTracks[0], endTime: Infinity }
                : null;
            }

            if(!currentExpressionTrack) return;
            
            // 获取表情，添加安全检查
            const expression = role.expressions.find(exp => exp && exp.id === currentExpressionTrack.expressionId) ||
                              role.expressions.find(exp => exp && exp.id === role.defaultExpressionId);
            
            if (!expression || !expression.frames || expression.frames.length === 0) return;
            
            // 使用角色表情管理器更新角色状态并获取当前帧索引
            const frameIndex = expressionManager.updateRoleState(role.id, expression, expression.frameInterval, currentTime.value);
            
            
            
            // 检查是否有有效的表情帧
            if (!expression || !expression.frames || !expression.frames[frameIndex]) {
              // 使用角色表情管理器创建备用图形
            // expressionManager.drawRolePlaceholder(offscreenCtx, currentExpressionTrack, role);
              return;
            }
            
            // 检查图片是否已在缓存中
            var imageUrl = expression.frames[frameIndex];
            var img = imageCache[imageUrl];
            
            if (img === null || img === undefined) {
              console.log('draw role no expression frame cache: ' + imageUrl);
            }

            // 调用抽取的drawRoleImage函数来处理具体的图片加载和绘制逻辑
            expressionManager.drawRoleImage(offscreenCtx, role, currentExpressionTrack, expression, imageUrl, img, currentTime.value, selectedRoleId.value, isPlaying.value, imageCache);
          });
        };
        

  
        // 动画循环
        const animate = (timestamp) => {
          if (!isPlaying.value) return;
          
          // 计算时间增量
          if (!lastTime.value) lastTime.value = timestamp;
          const deltaTime = timestamp - lastTime.value;
          
          // 根据目标FPS控制帧更新
          const targetFrameInterval = 1000 / targetFps.value;
          
          // 只有当经过的时间大于目标帧间隔时才更新时间和渲染
          if (deltaTime >= targetFrameInterval) {
            lastTime.value = timestamp;
            
            // 更新当前时间
            currentTime.value += deltaTime;
            
            // 计算FPS
            frameCount.value++;
            if (!lastFpsUpdate.value) lastFpsUpdate.value = timestamp;
            if (timestamp - lastFpsUpdate.value >= 1000) { // 每秒更新一次FPS
              fps.value = Math.round((frameCount.value * 1000) / (timestamp - lastFpsUpdate.value));
              frameCount.value = 0;
              lastFpsUpdate.value = timestamp;
            }
            // 检查是否结束
            if (currentTime.value >= totalDuration.value) {
              if (loop.value) {
                currentTime.value = 0;
              } else {
                stopPlayback();
                currentTime.value = totalDuration.value;
              }
            }
            
            // 更新显示
            updateTimelineDisplay();
            renderFrame();
          }
          
          // 继续动画
          animationFrameId.value = requestAnimationFrame(animate);
        };
        
        // 播放/暂停切换
        const playPause = () => {
          if (isPlaying.value) {
            stopPlayback();
          } else {
            startPlayback();
          }
        };
        
        // 开始播放
        const startPlayback = () => {
          isPlaying.value = true;
          lastTime.value = null;
          // 重置角色表情管理器，确保从当前时间点开始正确播放表情
          expressionManager.reset();
          // 立即渲染一帧
          renderFrame();
          animationFrameId.value = requestAnimationFrame(animate);
        };
        
        // 停止播放
        const stopPlayback = () => {
          isPlaying.value = false;
          if (animationFrameId.value) {
            cancelAnimationFrame(animationFrameId.value);
          }
          // 暂停时重新渲染，确保显示正确的画面
          renderFrame();
        };
        
        // 跳转到开始
        const goToStart = () => {
          currentTime.value = 0;
          // 重置角色表情管理器，确保从开始位置重新播放表情
          expressionManager.reset();
          updateTimelineDisplay();
          renderFrame();
        };
        
        // 跳转到结束
        const goToEnd = () => {
          currentTime.value = totalDuration.value;
          updateTimelineDisplay();
          renderFrame();
        };
        
        // 切换循环模式
        const toggleLoop = () => {
          loop.value = !loop.value;
        };
        
        // 缩放控制
        const zoomIn = () => {
          zoom.value = Math.min(zoom.value * 1.2, 5);
          updateTimelineDisplay();
        };
        
        const zoomOut = () => {
          zoom.value = Math.max(zoom.value / 1.2, 0.1);
          updateTimelineDisplay();
        };
        
        const resetZoom = () => {
          zoom.value = 1;
          updateTimelineDisplay();
        };
        
        // 选中角色
        const selectRole = (roleId) => {
          console.log('设置选中角色：', selectedRoleId.value);
          selectedRoleId.value = roleId;
          selectedShotId.value = null; // 选中角色时取消分镜选中
          
          // 当选择角色时，默认选择其第一个表情
          if (selectedRoleId.value) {
            const role = timeline.value.roles.find(r => r.id === selectedRoleId.value);
            if (role && role.expressions.length > 0) {
              selectedExpressionId.value = role.expressions[0].id;
            }
          } else {
            selectedExpressionId.value = null;
          }

          // 刷新表情轨道显示
          //updateExpressionTracks();
          drawExpressionTracks();
        };
        
        // 处理Canvas点击
        const handleCanvasClick = (event) => {
          if (isPlaying.value) return;
          
          // 获取Canvas元素
          const canvasElement = canvas.value;
          const rect = canvasElement.getBoundingClientRect();
          
          // 计算点击位置在Canvas中的坐标（考虑缩放）
          const scaleX = canvasElement.width / rect.width;
          const scaleY = canvasElement.height / rect.height;
          
          const x = (event.clientX - rect.left) * scaleX;
          const y = (event.clientY - rect.top) * scaleY;
          
          // 检测角色点击
          checkRoleClick(x, y);
        };
        
        // 检测角色点击
        const checkRoleClick = (x, y) => {
          const canvasElement = document.getElementById('animationCanvas');
          const canvasHeight = canvasElement.height;
          
          // 在新坐标系下，需要将点击Y坐标转换为内部使用的Y坐标
          // 数学坐标系：原点在左下角，Y轴向上
          const flippedY = canvasHeight - y;
          
          // 使用角色表情管理器检测点击的角色
          const clickedRole = expressionManager.checkRoleClick(x, flippedY, timeline.value.roles, timeline.value.expressionTracks, currentTime.value);
          
          if (clickedRole) {
            selectRole(clickedRole.id);
            // 关闭表情面板，下次点击表情按钮再打开
            showExpressionPanel.value = false;
            // 调用renderFrame更新选中状态显示
            renderFrame();
          } else {
            // 点击空白处取消选择
            selectRole(null);
            showExpressionPanel.value = false;
            // 调用renderFrame更新取消选中状态显示
            renderFrame();
          }
        };
        
        // 切换表情面板显示
        const toggleExpressionPanel = () => {
          showExpressionPanel.value = !showExpressionPanel.value;
        };
        
        // 处理表情点击事件的安全包装器
        const handleExpressionClick = (expression) => {
          console.log('handleExpressionClick调用 - 原始传入:', expression);
          
          try {
            // 检查传入参数是否存在
            if (!expression) {
              console.error('错误: 传入的表情为undefined或null');
              return;
            }
            
            // 确保传入的是一个对象
            if (typeof expression !== 'object') {
              console.error('错误: 传入的不是对象类型:', expression);
              return;
            }
            
            // 安全地调用selectExpression函数
            selectExpression(expression);
          } catch (error) {
            console.error('handleExpressionClick执行出错:', error);
            console.error('错误栈:', error.stack);
          }
        };
        
        // 选择表情
        const selectExpression = (expression) => {
          // 增强的调试信息
          console.log('selectExpression调用 - 传入的表达式:', expression);
          
          // 更严格的类型和属性检查
          if (!expression) {
            console.error('错误: 传入的表情为undefined或null');
            return;
          }
          
          if (typeof expression !== 'object') {
            console.error('错误: 传入的不是对象类型:', expression);
            return;
          }
          
          if (!('id' in expression) || expression.id === undefined || expression.id === null) {
            console.error('错误: 表情对象没有有效的id属性:', expression);
            return;
          }
          
          // 确保表达式id是字符串类型
          const expressionId = String(expression.id);
          selectedExpressionId.value = expressionId;
          console.log('表情选择成功:', expressionId, '表情名称:', getExpressionName(expressionId));
        };
        
        // 添加表情
        const addExpression = () => {
          if (!selectedRoleId.value || !selectedExpressionId.value) return;
          
          // 检查当前时间点是否已有该角色的表情轨道
          const hasExistingTrack = timeline.value.expressionTracks.some(track => 
            track.roleId === selectedRoleId.value && 
            track.startTime <= currentTime.value && 
            track.endTime > currentTime.value
          );
          
          if (!hasExistingTrack) {
            // 创建新的表情轨道，时长2秒
            const newTrack = {
              id: 'track_' + Date.now(),
              roleId: selectedRoleId.value,
              expressionId: selectedExpressionId.value,
              x: 100, // 默认x坐标
              y: 300, // 默认y坐标
              x1: 100, // 默认结束x坐标
              y1: 300, // 默认结束y坐标
              startTime: currentTime.value,
              endTime: currentTime.value + 2000 // 2秒时长
            };
            
            // 获取角色当前时间点的位置信息（与checkRoleClick函数使用相同的逻辑）
            const currentTrack = timeline.value.expressionTracks.find(track => 
              track.roleId === selectedRoleId.value && 
              currentTime.value >= track.startTime && 
              currentTime.value < track.endTime
            );
            
            if (currentTrack) {
              newTrack.x = currentTrack.x;
              newTrack.y = currentTrack.y;
            }
            
            timeline.value.expressionTracks.push(newTrack);
            renderFrame();
          }
        };
        
        // 替换表情
        const replaceExpression = () => {
          if (!selectedRoleId.value || !selectedExpressionId.value) return;
          
          // 查找当前时间点该角色的表情轨道
          const currentTrackIndex = timeline.value.expressionTracks.findIndex(track => 
            track.roleId === selectedRoleId.value && 
            track.startTime <= currentTime.value && 
            track.endTime > currentTime.value
          );
          
          if (currentTrackIndex !== -1) {
            // 替换现有轨道的表情
            timeline.value.expressionTracks[currentTrackIndex].expressionId = selectedExpressionId.value;
            renderFrame();
          } else {
            // 如果没有现有轨道，则添加新轨道
            addExpression();
          }
        };
        
        // 删除表情
        const deleteExpression = () => {
          if (!selectedRoleId.value) return;
          
          // 查找当前时间点该角色的表情轨道
          const currentTrackIndex = timeline.value.expressionTracks.findIndex(track => 
            track.roleId === selectedRoleId.value && 
            track.startTime <= currentTime.value && 
            track.endTime > currentTime.value
          );
          
          if (currentTrackIndex !== -1) {
            // 删除当前轨道
            timeline.value.expressionTracks.splice(currentTrackIndex, 1);
            renderFrame();
          }
        };
        
        // 保存项目
        const saveProject = () => {
          const dataStr = JSON.stringify(timeline.value, null, 2);
          const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
          
          const exportFileDefaultName = 'animation-project.json';
          
          const linkElement = document.createElement('a');
          linkElement.setAttribute('href', dataUri);
          linkElement.setAttribute('download', exportFileDefaultName);
          linkElement.click();
        };
        
        // 导出动画
        const exportAnimation = () => {
          alert('动画导出功能 - 模拟实现');
        };
        
        // 预加载所有背景图
        const preloadBackgroundImages = () => {
          // 获取所有需要预加载的背景图URL
          const backgroundUrls = timeline.value.shots.map(shot => shot.background);
          const uniqueUrls = [...new Set(backgroundUrls)]; // 去重
          
          // console.log('开始预加载背景图:', uniqueUrls);
          debugInfo.value = `开始预加载背景图: ${uniqueUrls.length}张`;
          
          // 预加载每张图片
          uniqueUrls.forEach(url => {
            if (!bgImagesCache.value[url]) {
              loadImageWithCORS(
                url,
                (img) => {
                  
                  bgImagesCache.value[url] = img; // 缓存已加载的图片
                  console.log('成功加载背景图:', url);
                  //预加载成功后，刷新下，否则背景是未渲染状态
                  renderFrame();
                },
                () => {
                  console.error('无法预加载背景图:', url);
                  bgImagesCache.value[url] = null; // 标记为加载失败
                }
              );
            }
          });
        };
        


        // 初始化
        onMounted(() => {
          // 初始化画布
          initCanvas();
          
          // 预加载所有背景图
          preloadBackgroundImages();
          
          // 打印初始化结果，用于调试
          //console.log('初始化后的角色表情容器:', expressionContainers.value);
          
          // 初始渲染
          updateTimelineDisplay();
          renderFrame();
          
          // 角色拖拽相关状态
          let isDraggingRole = false;
          let draggedRoleId = null;
          let dragOffsetX = 0;
          let dragOffsetY = 0;
          
          // 获取Canvas元素
          const canvasElement = document.getElementById('animationCanvas');
          
          // 添加角色拖拽事件监听
          canvasElement.addEventListener('mousedown', (e) => {
            if (isPlaying.value) return;
            
            const rect = canvasElement.getBoundingClientRect();
            const scaleX = canvasElement.width / rect.width;
            const scaleY = canvasElement.height / rect.height;
            // 关键点：使用与渲染时完全相同的Canvas高度（offscreenCanvas）进行坐标系转换
            const canvasHeight = offscreenCanvas.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            console.log(`点击位置:, ${x}, ${y}`);
            
            // 检查是否点击了选中的角色
            if (selectedRoleId.value) {
              // 找到当前时间点该角色的表情轨道
              const currentExpTrack = timeline.value.expressionTracks.find(track => 
                track.roleId === selectedRoleId.value &&
                currentTime.value >= track.startTime &&
                currentTime.value < track.endTime
              );
              
              if (currentExpTrack) {
                // 计算角色当前位置
                const pos = expressionManager.calculateCurrentPosition(currentExpTrack, currentTime.value);
                const roleWidth = expressionManager.config.roleWidth;
                const roleHeight = expressionManager.config.roleHeight;
                
                // 在新坐标系下，Y轴需要翻转
                const flippedY = canvasHeight - y;
                
                // 检查点击是否在角色范围内
                if (x >= pos.x && x <= pos.x + roleWidth &&
                    flippedY >= pos.y && flippedY <= pos.y + roleHeight) {
                  isDraggingRole = true;
                  draggedRoleId = selectedRoleId.value;
                  
                  // 精确计算点击位置相对于角色左下角原点的偏移量
                  // 这样无论点击角色的哪个位置，拖拽时都会保持这个相对位置
                  dragOffsetX = x - pos.x;
                  dragOffsetY = flippedY - pos.y;
                  
                  console.log(`拖拽偏移量: X=${dragOffsetX.toFixed(2)}, Y=${dragOffsetY.toFixed(2)}`);
                  canvasElement.style.cursor = 'grabbing';
                }
              }
            }
          });
          
          // 鼠标移动事件（添加到document以确保拖拽过程中鼠标离开Canvas也能继续）
          document.addEventListener('mousemove', (e) => {
            const rect = canvasElement.getBoundingClientRect();
            const scaleX = canvasElement.width / rect.width;
            const scaleY = canvasElement.height / rect.height;
            // 关键点：使用与渲染时完全相同的Canvas高度（offscreenCanvas）进行坐标系转换
            const canvasHeight = offscreenCanvas.height;
            
            // 计算当前鼠标在Canvas中的X坐标，减去偏移量以获得角色左下角应该在的位置
            const mouseX = (e.clientX - rect.left) * scaleX;
            const x = mouseX - dragOffsetX;
            
            // 计算当前鼠标在Canvas中的Y坐标，转换为与绘制时一致的坐标系，然后减去偏移量
            // 注意：使用与渲染时完全相同的坐标系转换方式，以确保精确匹配
            const mouseY = (e.clientY - rect.top) * scaleY;
            // 坐标系转换：与offscreenCtx.translate(0, offscreenCanvas.height)和offscreenCtx.scale(1, -1)完全匹配
            const flippedY = canvasHeight - mouseY;
            const y = flippedY - dragOffsetY;
            
            if (!isDraggingRole || !draggedRoleId || isPlaying.value) return;
            
            // 只有在拖拽角色时才打印日志
            console.log(`鼠标位置: (${mouseX.toFixed(2)}, ${flippedY.toFixed(2)}), 角色位置: (${x.toFixed(2)}, ${y.toFixed(2)})`);
            // 找到当前时间点该角色的表情轨道
            const currentExpTrack = timeline.value.expressionTracks.find(track => 
              track.roleId === draggedRoleId &&
              currentTime.value >= track.startTime &&
              currentTime.value < track.endTime
            );
            
            if (currentExpTrack) {
              // 临时更新位置，用于预览
              currentExpTrack._tempX = x;
              currentExpTrack._tempY = y;
              renderFrame();
            }
          });
          
          // 鼠标释放事件
          document.addEventListener('mouseup', () => {
            if (!isDraggingRole || !draggedRoleId) return;
            
            isDraggingRole = false;
            canvasElement.style.cursor = 'default';
            
            // 找到当前时间点该角色的表情轨道
            const currentExpTrack = timeline.value.expressionTracks.find(track => 
              track.roleId === draggedRoleId &&
              currentTime.value >= track.startTime &&
              currentTime.value < track.endTime
            );
            
            if (currentExpTrack && currentExpTrack._tempX !== undefined && currentExpTrack._tempY !== undefined) {
              // 检查是否是表情的最后时刻
              const isLastMoment = Math.abs(currentTime.value - (currentExpTrack.endTime - 100)) < 400;
              
              if (isLastMoment) {
                // 如果是最后时刻，更新x1,y1
                currentExpTrack.x1 = currentExpTrack._tempX;
                currentExpTrack.y1 = currentExpTrack._tempY;
              } else {
                // 否则更新x,y
                currentExpTrack.x = currentExpTrack._tempX;
                currentExpTrack.y = currentExpTrack._tempY;
              }
              
              // 清除临时位置
              delete currentExpTrack._tempX;
              delete currentExpTrack._tempY;
              
              // 重新渲染
              renderFrame();
              // 更新表情轨道显示
              drawExpressionTracks();
            }
            
            draggedRoleId = null;
          });
          


          ///////////////////////////////////////////
          // timeline
          ///////////////////////////////////////////


          // 监听鼠标拖动时间轴和刻度
          let isDragging = false;
          let lastMouseX = 0;
          let isDraggingTick = false;
          let draggedTickId = null;
          
          const timelineArea = document.querySelector('.overflow-x-auto');
          
          timelineArea.addEventListener('mousedown', (e) => {
            // 检查是否正在拖拽表情边缘，如果是则不触发时间轴拖拽
            if (isDraggingExpEdge) {
              //console.log('按下1:',e.button,timeMarkers)
              return;
            }


            //TODO: 检查是否点击了刻度
            if ((e.button === 0) && (e.target.className.includes('time-tick') || e.target == timeMarkers.value)) {

              isDragging = true;
              isDraggingTick = true;
              draggedTickId = e.target.id;
              lastMouseX = e.clientX;
              timelineArea.style.cursor = 'grabbing';
              stopPlayback();
              selectedShotId.value = null; // 取消选中
              //selectedRoleId.value = null;
              
              // 添加拖拽中的样式
              e.target.classList.add('time-tick-dragging');
              
              // 从刻度ID中提取时间（例如 'tick-5' 对应 5 秒）
              const timeStr = draggedTickId.split('-')[1];
              const time = parseInt(timeStr) * 1000; // 转换为毫秒
              //currentTime.value = Math.max(0, Math.min(time, totalDuration.value));
              updateTimelineDisplay();
              renderFrame();
              
            } 
            // 分镜轨道拖拽 - 支持直接点击分镜轨道进行拖拽
            else if ((e.button === 0) && (e.target === timelineArea || e.target.className.includes('timeline-track') || 
                     (e.target.closest('.timeline-track') && !e.target.classList.contains('shot-item')))) {
              isDragging = true;
              lastMouseX = e.clientX;
              timelineArea.style.cursor = 'grabbing';
              stopPlayback();
              selectedShotId.value = null; // 取消选中
              //selectedRoleId.value = null;
            }
            // 分镜项拖拽 - 当点击分镜项但不是点击分镜内部的子元素时，也支持拖拽
            else if (e.target.classList.contains('shot-item') || e.target.closest('.shot-item')) {
              // 如果点击的是分镜的子元素，找到最外层的分镜元素
              const shotItem = e.target.classList.contains('shot-item') ? e.target : e.target.closest('.shot-item');
              
              // 检查点击是否在分镜的特定交互区域外（例如点击的是分镜本身而不是其内部按钮等）
              if (!e.target.classList.contains('shot-header') && !e.target.closest('.shot-header')) {
                isDragging = true;
                lastMouseX = e.clientX;
                timelineArea.style.cursor = 'grabbing';
                stopPlayback();
                selectedShotId.value = null; // 取消选中
                //selectedRoleId.value = null;
                
                // 阻止事件冒泡到分镜点击事件
                e.stopPropagation();
              }
            }
          });
          
          timelineArea.addEventListener('mousemove', (e) => {
            // 检查是否正在拖拽表情边缘，如果是则不触发时间轴拖拽
            if (isDraggingExpEdge) {
              return;
            }
            
            if (isDragging) {
              const deltaX = e.clientX - lastMouseX;
              lastMouseX = e.clientX;
              
              // 计算时间变化 (像素差 -> 时间差)
              const timeDelta = (deltaX / MARGIN / zoom.value) * 1000;
              currentTime.value = Math.max(0, Math.min(currentTime.value - timeDelta, totalDuration.value));
              
              updateTimelineDisplay();
              renderFrame();
            }
          });
          
          timelineArea.addEventListener('mouseup', () => {
            if (isDragging) {
              isDragging = false;
              timelineArea.style.cursor = 'default';
              
              // 如果是拖拽刻度，清除拖拽状态
              if (isDraggingTick) {
                isDraggingTick = false;
                draggedTickId = null;
                
                // 移除所有刻度的拖拽样式
                document.querySelectorAll('.time-tick-dragging').forEach(tick => {
                  tick.classList.remove('time-tick-dragging');
                });
              }
            }
          });
          
          // 添加CSS样式使拖拽更直观
            const style = document.createElement('style');
            style.textContent = `
              .time-tick {
                cursor: grab;
                transition: all 0.2s ease;
              }
              
              .time-tick:hover {
                background-color: #3B82F6;
                opacity: 0.8;
                transform: scaleY(1.2);
              }
              
              .time-tick-dragging {
                cursor: grabbing;
                background-color: #EBF5FF ;
                opacity: 1;
                // transform: scaleY(1.5);
                z-index: 100;
              }
              
              .time-tick-major {
                background-color: #6B7280;
                height: 20px;
              }
              
              .time-tick-medium {
                background-color: #9CA3AF;
                height: 15px;
              }
              
              .time-tick-minor {
                background-color: #D1D5DB;
                height: 10px;
              }
              
              #animationCanvas {
                cursor: default;
              }
              
              #animationCanvas:hover {
                cursor: pointer;
              }
              
              .role-dragging {
                cursor: grabbing !important;
              }
            `;
            document.head.appendChild(style);
        });
        
        // 监听currentTime变化，更新显示
        watch(currentTime, () => {
          updateTimelineDisplay();
          renderFrame();
        });
        
        // 监听选中的分镜变化，更新显示
        watch(selectedShotId, () => {
          drawShotTrack();
        });
        
        // 添加专门的函数来处理分镜高亮，确保在播放时能够正确更新
        const updateShotHighlights = () => {
          if (!shotContainer.value) return;
          
          // 获取所有分镜元素
          const shotElements = shotContainer.value.querySelectorAll('.shot-item');
          
          // 遍历所有分镜元素
          timeline.value.shots.forEach((shot, index) => {
            const shotEl = shotElements[index];
            if (!shotEl) return;
            
            // 使用更严格的计算逻辑
            const shotEndTime = shot.startTime + shot.duration;
            const isTimeInShot = currentTime.value >= shot.startTime && currentTime.value < shotEndTime;
            
            if (isTimeInShot) {
              // 确保添加高亮类
              shotEl.classList.add('time-pointer-active');
              
              if (selectedShotId.value === shot.id) {
                shotEl.classList.add('editing-breathing-bg');
              } else {
                shotEl.classList.remove('editing-breathing-bg');
              }
            } else {
              // 确保移除高亮类
              shotEl.classList.remove('time-pointer-active');
              shotEl.classList.remove('editing-breathing-bg');
            }
          });
        };
        
        // 在播放时额外调用更新分镜高亮的函数
        watch([currentTime, isPlaying], () => {
          // 强制重新绘制分镜轨道
          drawShotTrack();
          // 然后额外应用高亮效果
          setTimeout(() => updateShotHighlights(), 0);
        });
        
        return {
          debugInfo,
          canvas,
          fps,
          timeScale,
          timeMarkers,
          shotTrack,
          shotContainer,
          sceneTrack,
          sceneContainer,
          expressionContainers,
          expressionTracks,
          timeline,
          isPlaying,
          currentTime,
          loop,
          zoom,
          markerPosition,
          totalDuration,
          timelineWidth,
          selectedRoleExpression,
          formatTime,
          getExpressionName,
          playPause,
          goToStart,
          goToEnd,
          toggleLoop,
          zoomIn,
          zoomOut,
          resetZoom,
          saveProject,
          exportAnimation,
          targetFps,
          selectedShotId,
          selectedRoleId,
          selectRole,
          setExpressionContainerRef,
          setExpressionTrackRef,
          canvasSizes,
          selectedCanvasSize,
          handleCanvasClick,
          showExpressionPanel,
          selectedExpressionId,
          toggleExpressionPanel,
          selectExpression,
          handleExpressionClick,
          addExpression,
          replaceExpression,
          deleteExpression,
          showAllRoleExpressions,
          updateTimelineDisplay
        };
      }
    }).mount('#app');
    // 添加全局错误处理器，专门捕获表情选择相关的错误
    window.addEventListener('error', function(e) {
      if (e.message && e.message.includes("Cannot read properties of undefined (reading 'id')")) {
        console.error('捕获到表情选择相关错误:', e.message);
        console.error('错误栈:', e.error.stack);
        
        // 尝试找出可能的undefined对象
        if (e.error && e.error.stack && e.error.stack.includes('Proxy.render')) {
          console.error('错误发生在Vue渲染过程中');
          // 尝试打印当前的timeline数据状态
          try {
            const app = Vue._apps[0];
            if (app && app._instance && app._instance.proxy) {
              console.log('当前Vue组件状态:', {
                selectedRoleId: app._instance.proxy.selectedRoleId,
                selectedExpressionId: app._instance.proxy.selectedExpressionId,
                showExpressionPanel: app._instance.proxy.showExpressionPanel,
                timelineRolesCount: app._instance.proxy.timeline?.roles?.length || 0
              });
            }
          } catch (err) {
            console.error('无法获取Vue组件状态:', err);
          }
        }
      }
    });
  </script>
</body>
</html>
    